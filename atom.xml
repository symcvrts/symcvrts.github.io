<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chris Chan&#39;s BLOG</title>
  
  <subtitle>那些在阳光下挥洒青春的日子啊！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-05-12T10:36:53.336Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Chris Chan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>加载css样式的两个方法</title>
    <link href="http://yoursite.com/2018/05/12/%E5%8A%A0%E8%BD%BDcss%E6%A0%B7%E5%BC%8F%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2018/05/12/加载css样式的两个方法/</id>
    <published>2018-05-12T07:27:19.000Z</published>
    <updated>2018-05-12T10:36:53.336Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="背景说明">背景说明</span></h2><p>环境： <code>django 2.0</code>+<code>python 3.6</code>+<code>pycharm 2018</code></p><p>project名称: <code>blog</code></p><h2><span id="普通的网页加载css">普通的网页加载css</span></h2><p>网页使用了css才会更好看更炫酷，一般情况下的网页是这样的：</p><p><img src="/images/css0.png" alt="akb48"></p><p>上面这个html文件里用到了模板，而且又对div和 a标签做了class定义，最后分别对各自的class进行了css说明。整个文档看下来比较直观。</p><p>但是这样就会有一个问题，就是把html内容和css内容写到了一起，一般来说为了后期维护，都会把css单独写到一个文件夹里，然后让这个html来引用这个css文件夹的具体某个css文件。</p><p>于是，我们就在<code>blog</code>这个project目录下建立一个叫static的文件夹，用它来专门装<code>css\js</code>这样的静态文件。</p><p>首先，建立了这个static文件，肯定就涉及到引用的问题，而如何让django可以识别static呢？</p><p>打开<code>blog/settings.py</code>这个文件，这个文件是整个project的配置文件，在文件末尾加上这样的话，如下：</p><p>​    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#将项目根目录里的static制定成项目的静态文件夹,这样django就可以识别</span><br><span class="line">#注意，static前面没有&apos;/&apos;</span><br><span class="line">STATICFILES_DIRS = [    os.path.join(BASE_DIR, &apos;static&apos;),]</span><br><span class="line"></span><br><span class="line">​</span><br></pre></td></tr></table></figure></p><p>这样blog这个根目录就可以识别了<code>static</code>文件夹了。</p><p>然后在pycharm里新建一个css文件叫<code>base.css</code>，如果是专业版的pycharm是可以直接建立css类型文件的，免费社区版是没有这个功能。再将原文里面的所有关于css的内容拷贝到这个<code>base.css</code>里，如下：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">margin: 5px;</span><br><span class="line">padding: 10px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div.nav &#123;</span><br><span class="line">background-color: gold;</span><br><span class="line">border-bottom: 2px solid #ccc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div.nav a&#123;</span><br><span class="line">text-decoration:none;</span><br><span class="line">color: blue;</span><br><span class="line">padding: 5px 10px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div.nav a.logo&#123;</span><br><span class="line">display: inline-block;</span><br><span class="line">font-size: 120%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>保存之后，为了验证django是否成功的识别此文件，可以在浏览器里输入<code>外网IP：端口号/static/base.css</code>查看是否返回就是上面内容，如果是就代表识别成功，如果是404就要重新检查<code>settings.py</code>了。</p><p>在原有的html里删除掉<code>&lt;style&gt;</code>标签内css内容，还要在head里添加一句话：<code>&lt;link  rel=&quot;stylesheet&quot; href=&quot;/static/base.css&quot;&gt;</code>,如下：</p><p><img src="/images/css1.png" alt="akb48"></p><p>这样就达到了引用css所在的static文件夹的目的。</p><h2><span id="django内部的加载css方法">Django内部的加载css方法</span></h2><p>上面说的是普通html加载css的方法，而django内部也有自己的一套方法，再次打开settings.py里看到有如下的内容：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">INSTALLED_APPS = [   </span><br><span class="line"> <span class="string">'django.contrib.admin'</span>,   </span><br><span class="line"> <span class="string">'django.contrib.auth'</span>,   </span><br><span class="line"> <span class="string">'django.contrib.contenttypes'</span>,   </span><br><span class="line"> <span class="string">'django.contrib.sessions'</span>,   </span><br><span class="line"> <span class="string">'django.contrib.messages'</span>,    </span><br><span class="line"> <span class="string">'django.contrib.staticfiles'</span>,   </span><br><span class="line"> <span class="string">'blog'</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>上面的django.contrib.staticfiles就是django的css加载方法，使用这个方法也很简单。</p><p>首先要在html文件最上面先声明要调用这个方法:<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% load staticfiles %&#125;</span><br><span class="line">&#123;# 这个staticfiles是django自带的，可以在settings文件里看到 #&#125;</span><br></pre></td></tr></table></figure></p><p>然后把link标签改成如下：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link  rel=&quot;stylesheet&quot; href=&quot;&#123;% static &apos;base.css&apos; %&#125;&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>保存文件刷新即可，而且用了这种方法，在chrome浏览器里F12 查看，会解析成普通模式的方法，如图：<br><img src="/images/css2.png" alt="akb48"></p><p>在django项目里，还是更推荐用django的方法。</p><h2><span id="额外补充">额外补充</span></h2><p>如果html文件开头声明引用了某个模板，比如：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% extends &apos;base.html&apos; %&#125;#声明引用了base.html这个模板</span><br><span class="line">&#123;% load staticfiles %&#125;</span><br></pre></td></tr></table></figure></p><p>那么<code>extends</code>语句必须在最上面，不然就会报错：TemplateSyntaxError at /</p><p><extendsnode: extends="" 'base.html'=""> must be the first tag in the template.</extendsnode:></p>]]></content>
    
    <summary type="html">
    
      如果html里没有header这个标签，就需要在模板文件里面新加一个块，在块里声明css的地址
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="django" scheme="http://yoursite.com/tags/django/"/>
    
      <category term="前端技术" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>创建Mysql容器过程</title>
    <link href="http://yoursite.com/2018/05/12/%E5%88%9B%E5%BB%BAMysql%E5%AE%B9%E5%99%A8%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/05/12/创建Mysql容器过程/</id>
    <published>2018-05-12T02:28:46.000Z</published>
    <updated>2018-05-12T02:47:42.128Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="过程记录">过程记录</span></h2><p>先<code>docker pull mysql</code>，当前最近的版本是8.0，然后<code>docker images</code>查看一下效果。</p><p>然后就是启动一个容器，命令是：<code>docker run --name test-mysql -p 3306:3306 -e MYSQL\_ROOT\_PASSWORD=123456 -d mysql</code>,这句话的意思是：启动一个叫test-mysql的容器， 端口影射是3306到宿主机的3306，同时设置root的密码是123456，然后以守护进程的形式启动。</p><p>但是如果在宿主机上使用<code>mysql -h127.0.0.1 -uroot -p123456</code>可能会报错，报错内容是：“Authentication plugin ‘caching_sha2_password’ cannot be loaded:”</p><p>那么就<code>docker exec -it 容器ID号 env LANG=C.UTF-8 /bin/bash</code>进入到容器里，使用<code>mysql -uroot -p123456</code>，看一下在容器里是否可以正常登录，如果可以的话，那么就在mysql的命令行里执行<code>ALTER USER &#39;root&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;123456&#39;;</code>。  </p><p>退出容器在宿主机上重新连接，这样就OK了。至于原因就是，mysql的客户端是yum安装的，虽然是centos 7，但是安装的版本也是5.5版本的，所以8.0的客户端有一个新的密码加密方式：<code>caching_sha2_password</code>，客户端不支持，所以需要手动到命令行里更改一下。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="http://binary-space.iteye.com/blog/2412769" target="_blank" rel="noopener">http://binary-space.iteye.com/blog/2412769</a></p><p><img src="/images/rondopass1.gif" alt="paradin"></p>]]></content>
    
    <summary type="html">
    
      据说mysql的容器坑很多...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="docker容器" scheme="http://yoursite.com/tags/docker%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>python报错：importError: No module named bz2</title>
    <link href="http://yoursite.com/2018/05/12/python%E6%8A%A5%E9%94%99%EF%BC%9A&#39;importError-No-module-named-bz2&#39;/"/>
    <id>http://yoursite.com/2018/05/12/python报错：&#39;importError-No-module-named-bz2&#39;/</id>
    <published>2018-05-12T02:08:07.000Z</published>
    <updated>2018-05-12T04:19:32.054Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>每日统计阿里云同步延迟的邮件早就编写完毕了，现在要放到专门跑脚本的服务器里，进去到这个服务器里发现这个机器已经被人装了两个python，分别是python 2.7.5（默认路径）和python 2.7.13（路径是<code>/usr/local/python/bin/python</code>），说实话我个人不太明白这么做的原因何在。</p><p>但是既然已经被人搞成这样了，那就适应环境吧，把脚本拷贝过来，把依赖库都安装好，但是在执行<code>matplotlib</code>的库的时候，爆了一个错误：<code>ImportError: No module named bz2</code>。</p><p>这就是因为两个python，但是启动的那个python文件夹里面是没有<code>bz2.so</code>这个文件的，于是就需要把系统里默认的2.7.5的<code>bz2.so</code>拷贝到2.7.13的lib路径里。</p><p>首先<code>find / -name bz2.so</code>找一下文件，如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@dvl-stun-002 GETDTS]# find / -name bz2.so</span><br><span class="line">/usr/local/aegis/PythonLoader/lib/python2<span class="number">.7</span>/lib-dynload/bz2.so</span><br><span class="line">/usr/local/aegis/SecureCheck/lib/python2<span class="number">.7</span>/lib-dynload/bz2.so</span><br><span class="line">/usr/lib64/python2<span class="number">.7</span>/lib-dynload/bz2.so</span><br></pre></td></tr></table></figure></p><p>然后<code>cd /usr/local/python/lib/python2.7/</code>，把<code>/usr/lib64/python2.7/lib-dynload/bz2.so</code>复制到这个文件夹里即可。<br><img src="/images/rubio3kill.gif" alt="paradin"></p>]]></content>
    
    <summary type="html">
    
      双python的蛋疼...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>在已经运行的docker容器里面使用中文</title>
    <link href="http://yoursite.com/2018/05/10/%E5%9C%A8%E5%B7%B2%E7%BB%8F%E8%BF%90%E8%A1%8C%E7%9A%84docker%E5%AE%B9%E5%99%A8%E9%87%8C%E9%9D%A2%E4%BD%BF%E7%94%A8%E4%B8%AD%E6%96%87/"/>
    <id>http://yoursite.com/2018/05/10/在已经运行的docker容器里面使用中文/</id>
    <published>2018-05-10T14:52:57.000Z</published>
    <updated>2018-05-10T14:56:16.775Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>公司搭建的gitlab现在需要开启ldap服务，也就是这样就可以用公司的域账号登陆gitlab，而不用开发一个一个去注册账号了。</p><p>开启ldap登陆的任务光荣了落到了我的身上，于是我就登陆到gitlab服务器一看，嚯，这还是在容器下启动的，如图：<br><img src="/images/gitlab2.png" alt="paradin"></p><p>于是我就<code>docker exec -it 容器ID号 /bin/bash</code>登陆到这个容器里，编辑<code>/opt/gitlab/embedded/service/gitlab-rails/config/gitlab.yml</code>，如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ldap:    </span><br><span class="line">  enabled: <span class="literal">true</span></span><br><span class="line">  sync_time:</span><br><span class="line">  host: <span class="string">'公司域账号服务器IP地址'</span></span><br><span class="line">  port: <span class="number">389</span></span><br><span class="line">  uid: <span class="string">'sAMAccountName'</span></span><br><span class="line">  method: 'plain' # "tls" or "ssl" or "plain"</span><br><span class="line">  bind_dn: <span class="string">'dahuatech\Ldap_System'</span></span><br><span class="line">  password: <span class="string">'对应的密码'</span></span><br><span class="line">  active_directory:</span><br><span class="line">  allow_username_or_email_login:    </span><br><span class="line">  lowercase_usernames:</span><br><span class="line">  base: </span><br><span class="line">  user_filter:</span><br></pre></td></tr></table></figure></p><p>但是在填写到base的时候发现了一个问题，公司的base是中文的，是<code>&#39;OU=大数据研究院,OU=研发中心,OU=大华技术,DC=dahuatech,DC=com&#39;</code>，但是在文件里输入中文却是乱码，如图：<br><img src="/images/gitlab3.png" alt="paradin"></p><p>容器默认是不支持中文的，在容器里的命令行输入中文也是空白。那么面对一个已经运行的容器，如何正常的输入中文呢？</p><p>答案是：使用<code>docker exec -it 容器ID号 env LANG=C.UTF-8 /bin/bash</code>登陆，这样就能正常使用中文了，如图：<br><img src="/images/gitlab1.png" alt="paradin"></p><p>修改好配置文件之后，<code>gitlab-ctl restart</code>，登陆到gitlab页面一看，已经添加ldap访问方式：<br><img src="/images/gitlab4.png" alt="paradin"></p>]]></content>
    
    <summary type="html">
    
      如果要是dockerfile里都直接使用中文就更好了
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>通过阿里云服务器ID添加服务器资料到django的脚本</title>
    <link href="http://yoursite.com/2018/05/07/%E9%80%9A%E8%BF%87%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8ID%E6%B7%BB%E5%8A%A0%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%B5%84%E6%96%99%E5%88%B0django%E7%9A%84%E8%84%9A%E6%9C%AC/"/>
    <id>http://yoursite.com/2018/05/07/通过阿里云服务器ID添加服务器资料到django的脚本/</id>
    <published>2018-05-07T13:48:29.000Z</published>
    <updated>2018-05-12T06:13:54.179Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>本文的环境是：<code>centos 7</code> + <code>django 2.0</code> + <code>python 3.6</code></p><p>先给django里的project创建了<code>models.py</code>，里面内容如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"># Create your models here.</span><br><span class="line">class ecs(models.Model):</span><br><span class="line">    name = models.CharField(verbose_name=<span class="string">'云服务器名称'</span>,max_length=<span class="number">30</span>)</span><br><span class="line">    ecsid = models.CharField(verbose_name=<span class="string">'云服务器ID'</span>,max_length=<span class="number">30</span>,<span class="keyword">default</span>=<span class="string">''</span>)</span><br><span class="line">    inIP = models.GenericIPAddressField(verbose_name=<span class="string">'云服务器内网地址'</span>)</span><br><span class="line">    outIP = models.GenericIPAddressField(verbose_name=<span class="string">'云服务器外网地址'</span>)</span><br><span class="line">    osname = models.CharField(verbose_name=<span class="string">'操作系统'</span>,max_length=<span class="number">50</span>,<span class="keyword">default</span>=<span class="string">''</span>)</span><br><span class="line">    networktype = models.CharField(verbose_name=<span class="string">'网络类型'</span>,max_length=<span class="number">20</span>)</span><br><span class="line">    CPU = models.IntegerField(verbose_name=<span class="string">'云服务器CPU'</span>,<span class="keyword">default</span>=<span class="string">'2'</span>)</span><br><span class="line">    memory = models.IntegerField(verbose_name=<span class="string">'云服务器内存'</span>,<span class="keyword">default</span>=<span class="string">'2048'</span>)</span><br><span class="line">    netwidth = models.IntegerField(verbose_name=<span class="string">'云服务器外网带宽'</span>,<span class="keyword">default</span>=<span class="string">'0M'</span>)</span><br><span class="line">    signtime = models.DateField(auto_now_add=True)</span><br><span class="line">    remark = models.CharField(verbose_name=<span class="string">'备注'</span>,max_length=<span class="number">255</span>,blank=True)</span><br></pre></td></tr></table></figure></p><p>可以看出这个就是一个很简单的云服务器的配置统计，但是要录入的阿里云服务器很多，一个一个手动输入实在太累，于是就要写一个脚本来达到django同步的效果！</p><p>脚本内容如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line">#coding=utf-8</span><br><span class="line">#这个脚本通过查询阿里云服务器ID来达到同步django的目的</span><br><span class="line"><span class="keyword">import</span> json,pymysql</span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore <span class="keyword">import</span> client</span><br><span class="line"><span class="keyword">from</span> aliyunsdkecs.request.v20140526 <span class="keyword">import</span> DescribeInstancesRequest</span><br><span class="line"></span><br><span class="line">clt = client.AcsClient(<span class="string">'这里是ak'</span>,<span class="string">'这里是sk'</span>,<span class="string">'这里是地域名'</span>)</span><br><span class="line"></span><br><span class="line"># 设置参数</span><br><span class="line">request = DescribeInstancesRequest.DescribeInstancesRequest()</span><br><span class="line">request.set_accept_format(<span class="string">'json'</span>)</span><br><span class="line"></span><br><span class="line">request.add_query_param(<span class="string">'RegionId'</span>, <span class="string">'cn-hangzhou'</span>)</span><br><span class="line">request.add_query_param('InstanceIds', ['这里是服务器ID'])#如果是多个服务器ID，可以继续往下写</span><br><span class="line"></span><br><span class="line"># 发起请求</span><br><span class="line">response = clt.do_action(request)</span><br><span class="line"></span><br><span class="line">#print(response)#这里可以看一下返回的response，但是它是byte格式的</span><br><span class="line">data=str(response, encoding = <span class="string">"utf-8"</span>)</span><br><span class="line">ecs = json.loads(data)#转换成str格式</span><br><span class="line">name = str(ecs[<span class="string">'Instances'</span>][<span class="string">'Instance'</span>][<span class="number">0</span>][<span class="string">'InstanceName'</span>])</span><br><span class="line">ecsid = str(ecs[<span class="string">'Instances'</span>][<span class="string">'Instance'</span>][<span class="number">0</span>][<span class="string">'InstanceId'</span>])</span><br><span class="line">inIP = str(ecs['Instances']['Instance'][0]['VpcAttributes']['PrivateIpAddress']['IpAddress'])[1:-1]#如果不加[1:-1]的话，得到的是一个IP外面还有中括号</span><br><span class="line">outIP = str(ecs[<span class="string">'Instances'</span>][<span class="string">'Instance'</span>][<span class="number">0</span>][<span class="string">'PublicIpAddress'</span>][<span class="string">'IpAddress'</span>])[<span class="number">1</span>:<span class="number">-1</span>]</span><br><span class="line">networktype = str(ecs[<span class="string">'Instances'</span>][<span class="string">'Instance'</span>][<span class="number">0</span>][<span class="string">'InstanceNetworkType'</span>])</span><br><span class="line">CPU = int(ecs[<span class="string">'Instances'</span>][<span class="string">'Instance'</span>][<span class="number">0</span>][<span class="string">'Cpu'</span>])</span><br><span class="line">memory = int(ecs[<span class="string">'Instances'</span>][<span class="string">'Instance'</span>][<span class="number">0</span>][<span class="string">'Memory'</span>])</span><br><span class="line">osname = str(ecs[<span class="string">'Instances'</span>][<span class="string">'Instance'</span>][<span class="number">0</span>][<span class="string">'OSName'</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#创建数据库连接，注意这里我加入了charset和cursorclass参数</span><br><span class="line">conn = pymysql.connect(</span><br><span class="line">    host = <span class="string">"127.0.0.1"</span>,</span><br><span class="line">    user = <span class="string">"数据库账号"</span>,</span><br><span class="line">    password = <span class="string">"数据库密码"</span>,</span><br><span class="line">    database = <span class="string">"数据库名称"</span>,</span><br><span class="line">    charset = <span class="string">'utf8'</span>,</span><br><span class="line">    cursorclass = pymysql.cursors.DictCursor)</span><br><span class="line">#获取游标</span><br><span class="line">cursor = conn.cursor()</span><br><span class="line"></span><br><span class="line">#三个引号里如何加入变量</span><br><span class="line">sql = <span class="string">""</span><span class="string">"INSERT INTO ecs_ecs (name,ecsid,inIP,outIP,networktype,CPU,memory,netwidth,signtime,osname) VALUES (%(name)s,%(ecsid)s,%(inIP)s,%(outIP)s,%(networktype)s,%(CPU)d,%(memory)d,%(netwidth)d,NOW(),%(osname)s);"</span><span class="string">""</span> % dict(name=<span class="string">'\''</span>+name+<span class="string">'\''</span>,ecsid= <span class="string">'\''</span>+ecsid+<span class="string">'\''</span>,inIP=inIP,outIP=outIP,networktype=<span class="string">'\''</span>+networktype+<span class="string">'\''</span>,CPU=CPU,memory=memory,netwidth=<span class="number">1</span>,osname=<span class="string">'\''</span>+osname+<span class="string">'\''</span>)</span><br><span class="line"></span><br><span class="line">#print (sql)#在这里可以先看看sql输出的是否正确</span><br><span class="line">cursor.execute(sql)</span><br><span class="line"></span><br><span class="line"># 关闭数据库连接</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure></p><p>正常来说应该是先建立一个def来获取阿里云服务器配置，再来一个def来将各配置录入到数据库里，同时让阿里云服务器的id作为变量，而且还要加上如果sql执行失败就回滚的语句。而我由于是临时使用，所以这个脚本按照流水式写下来的，不过不影响阅读。</p><p>ps.进化之后的脚本在我的github里，地址是： <a href="https://github.com/RorschachChan/chenWORK/blob/master/通过阿里云ID号将服务器信息同步到django.py" target="_blank" rel="noopener">https://github.com/RorschachChan/chenWORK/blob/master/通过阿里云ID号将服务器信息同步到django.py</a></p><p>比如现在要添加一个服务器，这个服务器的id是：<code>i-bp12ego6x9srzsytxeqo</code>，如图：<br><img src="/images/django3.png" alt="akb48"></p><p>那么对应填写好脚本里的ak/sk之后，就把<code>i-bp12ego6x9srzsytxeqo</code>填写到“服务器ID”的位置 ，执行这个脚本，结果如下：<br><img src="/images/django5.png" alt="akb48"></p><p>不过这个脚本有两个缺点：<br>第一：如果阿里云服务器是中文名称，那么使用api查询出现的是十六进制的符号；<br>第二：如果服务器里没有外网IP或者是后开的临时带宽，那么在outIP的地方得到的值是空，sql语句会因为少一项而报错；<br>第三：这个api没有查询服务器带宽值的功能，还需要另外写一个脚本搭配。</p>]]></content>
    
    <summary type="html">
    
      最近我又把django捡起来了
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="python3" scheme="http://yoursite.com/tags/python3/"/>
    
      <category term="django2" scheme="http://yoursite.com/tags/django2/"/>
    
  </entry>
  
  <entry>
    <title>记一次nginx负载均衡配置问题</title>
    <link href="http://yoursite.com/2018/04/28/%E8%AE%B0%E4%B8%80%E6%AC%A1nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/04/28/记一次nginx负载均衡配置问题/</id>
    <published>2018-04-28T13:48:40.000Z</published>
    <updated>2018-04-28T14:00:42.648Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="故障背景">故障背景</span></h2><p>公司有三个实体服务器，内网IP分别是<code>10.1.82.83</code>、<code>10.1.82.84</code>、<code>10.1.82.113</code>，这三个作为源站使用专线连接到了阿里云的一台nginx服务器上，并且通过这个nginx做负载均衡展示这三个服务器里面的网页。负载均衡使用的是<code>nginx 1.12</code>版本，最外面在上一个CDN起到静态页面加速的作用。整个架构如图：<br><img src="/images/aliCDN2.png" alt="paradin"></p><p>CDN的配置界面如下：<br><img src="/images/aliCDN6.png" alt="paradin"></p><p>但是现在很奇怪的是，所有节点启动之后，外网用户通过负载后访问均指向了<code>10.1.82.84</code>这一台服务器，<code>nginx.conf</code>配置是<code>最小连接数</code>的配置，如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">upstream eln.dahuatech.com &#123;</span><br><span class="line">      #ip_hash;</span><br><span class="line">      #hash $http_x_forwarded_for;</span><br><span class="line">      #sticky;</span><br><span class="line">      least_conn;</span><br><span class="line">      server  <span class="number">10.1</span><span class="number">.82</span><span class="number">.83</span> max_fails=<span class="number">2</span> fail_timeout=<span class="number">30</span>s;</span><br><span class="line">      server  <span class="number">10.1</span><span class="number">.82</span><span class="number">.84</span> max_fails=<span class="number">2</span> fail_timeout=<span class="number">30</span>s;</span><br><span class="line">      server  <span class="number">10.1</span><span class="number">.82</span><span class="number">.113</span> max_fails=<span class="number">2</span> fail_timeout=<span class="number">30</span>s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">        server_name  eln.dahuatech.com;</span><br><span class="line">            listen     <span class="number">80</span>;</span><br><span class="line">            listen     <span class="number">443</span> ssl;</span><br><span class="line"></span><br><span class="line">        access_log logs/eln.dahuatech.com.access.log main;</span><br><span class="line">        error_log  logs/eln.dahuatech.com.error.log;</span><br><span class="line"></span><br><span class="line">        proxy_set_header Host $host:$server_port;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header REMOTE-HOST $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line"></span><br><span class="line">   location / &#123;</span><br><span class="line">            proxy_pass http:<span class="comment">//eln.dahuatech.com;</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试的时候发现，即使绑定美国和香港的节点去<code>curl</code>，是能正常解析到其他机器上的。如下：<br><img src="/images/aliCDN3.png" alt="paradin"></p><p>然而源站过来的请求IP集中到了只有一个，这太奇怪了。</p><h2><span id="故障解决">故障解决</span></h2><p>后来发现ngnix后端会把http1.1转换成1.0变成短连接，这个连接存在的时间非常短，因为后端响应非常快。所以即使配上了<code>least_conn</code>，其实是没有任何效果的。这样负载均衡的nginx看到所有源站其实一直都是没有连接的，所以也就一直在给第一个转。</p><p>既然这样，就取消了<code>least_conn</code>改用轮询，nginx.conf也改成如下的样子：<br><img src="/images/aliCDN1.png" alt="paradin"></p><p>最后终于均衡了，大功告成！<br><img src="/images/aliCDN5.png" alt="paradin"></p><p>后来琢磨了一下，是用sticky其实也是OK的。</p><h2><span id="几个主流负载均衡软件配置cookie的方法">几个主流负载均衡软件配置cookie的方法</span></h2><p>1.Apache的话首先打开<code>httpd.conf</code>配置文件，确保如下配置没有被注释。<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LoadModule usertrack_module modules/mod_usertrack.so</span><br></pre></td></tr></table></figure></p><p>再在<code>virtual host</code>中添加以下配置。<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CookieName name</span><br><span class="line">CookieExpires <span class="string">"1 days"</span></span><br><span class="line">CookieStyle Cookie</span><br><span class="line">CookieTracking on</span><br></pre></td></tr></table></figure></p><p>2.Nginx参考以下配置，设置Cookie。<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen <span class="number">8080</span>;</span><br><span class="line">    server_name wqwq.example.com;</span><br><span class="line">    location / &#123;</span><br><span class="line">      add_header <span class="built_in">Set</span>-Cookie name=xxxx;</span><br><span class="line">        root   html;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3.Lighttpd参考以下配置，设置Cookie。<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server.modules  = ( <span class="string">"mod_setenv"</span> )</span><br><span class="line">$HTTP[<span class="string">"host"</span>] == <span class="string">"test.example.com"</span> &#123;</span><br><span class="line">      server.document-root = <span class="string">"/var/www/html/"</span></span><br><span class="line">      setenv.add-response-header = ( <span class="string">"Set-Cookie"</span> =&gt; <span class="string">"name=XXXXXX"</span>      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2><span id="扩展阅读">扩展阅读</span></h2><p><a href="https://cloud.tencent.com/document/product/214/2736" target="_blank" rel="noopener">https://cloud.tencent.com/document/product/214/2736</a><br><a href="http://blog.text.wiki/2015/08/01/nginx-sticky-problem.html" target="_blank" rel="noopener">http://blog.text.wiki/2015/08/01/nginx-sticky-problem.html</a><br><a href="https://cloud.tencent.com/developer/article/1004547" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1004547</a></p>]]></content>
    
    <summary type="html">
    
      真正站在运维的层面讲nginx的书不多的...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
      <category term="负载均衡" scheme="http://yoursite.com/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
  </entry>
  
  <entry>
    <title>记一次阿里云oss云存储删除失败的问题</title>
    <link href="http://yoursite.com/2018/04/27/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%98%BF%E9%87%8C%E4%BA%91oss%E4%BA%91%E5%AD%98%E5%82%A8%E5%88%A0%E9%99%A4%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/04/27/记一次阿里云oss云存储删除失败的问题/</id>
    <published>2018-04-27T14:24:58.000Z</published>
    <updated>2018-04-27T14:49:33.284Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>公司每天云存储都要删除过期的内容，工作细节是这样的：每天零点，采集模块开始收集应该删除掉的内容，然后把这个消息传给阿里云MQ，阿里云MQ又把消息传给删除模块，删除模块拿到名单之后，开始调用阿里云OSS的删除API进行删除。架构如图：<br><img src="/images/oss6.png" alt="paradin"></p><p>但是今天登陆监控平台发现，昨天oss没有删除，上涨了80多个T，如图：<br><img src="/images/oss1.png" alt="paradin"></p><p>老板一看，卧槽这怎么可以，80多个T的云存储费用可是不容小视的，于是责令追查一下为啥会发生这样的情况。</p><p>昨天我的手机又没有收到任何阿里云消息队列告警的信息，可见MQ应该是没问题的，查看一下是否有MQ的产生和消费情况，如下图：<br><img src="/images/oss2.png" alt="paradin" title="这个是消息产生情况"></p><p><img src="/images/oss3.png" alt="paradin" title="这个是消息消费情况"></p><p>产生的消息基本都消费掉了，由此推断之前的过程都应该是OK的。再查看一下会不会是删除模块外网带宽到期的问题，此时发现两天的流量有显著的不同：<br><img src="/images/oss7.png" alt="paradin" title="这个是正常的流量情况"></p><p><img src="/images/oss8.png" alt="paradin" title="这个是异常的流量情况"></p><p>流量明显减少，可以说是删除模块执行任务少了。于是到执行OSS删除API的模块上去抓了几个包，里面情况如下：<br><img src="/images/oss4.png" alt="paradin"></p><p>但是跑到阿里云对应的bucket里看一下文件情况，比如<code>https://lechangecloud.oss-cn-hangzhou.aliyuncs.com/lechange/4B01F1FPAGE4E9D_img/Alarm/20180427000913997_0_fa62bec6dee24cc0bee42e1ee3e75743_thumb_qcif.dav</code>这个文件，这个文件明明还在里面躺着好好的。如图：<br><img src="/images/oss5.png" alt="paradin"></p><p>文件00：27的时候就在了，但是2：53分的时候调用阿里云OSS的API去删除，明明返回了200，但是文件却没有真正的从OSS删除掉。</p><p>我觉得这样就拿去跟阿里云撕逼还是有点不太妥当，又回到刚刚的那个包里，我发现里面还有一些返回的内容是这样的：<br><img src="/images/oss9.png" alt="paradin"></p><p>这个图跟之前的图明显路径上不同，而这些文件在OSS上确认是被成功删除掉的，可见的确是文件路径的问题：失败的文件路径是完全路径，而成功的都是相对路径。于是就告诉开发赶快整改代码，把路径统一…</p><p><img src="/images/朝韩会面.png" alt="paradin" title="历史性的会面"></p>]]></content>
    
    <summary type="html">
    
      这一周六天班通宵了三次...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="阿里云" scheme="http://yoursite.com/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>在安装docker私有仓库的时候遇到的openssl问题</title>
    <link href="http://yoursite.com/2018/04/21/%E5%9C%A8%E5%AE%89%E8%A3%85docker%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E7%9A%84%E6%97%B6%E5%80%99%E9%81%87%E5%88%B0%E7%9A%84openssl%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/04/21/在安装docker私有仓库的时候遇到的openssl问题/</id>
    <published>2018-04-20T16:45:39.000Z</published>
    <updated>2018-04-26T15:30:53.852Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>按照<a href="http://wiki.jikexueyuan.com/project/docker-technology-and-combat/local_repo.html" target="_blank" rel="noopener">http://wiki.jikexueyuan.com/project/docker-technology-and-combat/local_repo.html</a> 的方法本地安装一个私有仓库，在执行<code>sudo pip install docker-registry</code>这一步的时候，出现了这样的一个错误：<br><img src="/images/openssl1.png" alt="paradin"></p><p>既然说我没有swig，于是我<code>yum install swig -y</code>，安装的是<code>2.0.10-5.el7</code>版本。然后再次<code>pip install docker-registry</code>，一顿噼里啪啦之后，这次成了这样：<br><img src="/images/openssl2.png" alt="paradin"></p><p>又说没有openssl的文件，那执行<code>yum install openssl-devel</code>，OK了之后再次<code>pip install docker-registry</code>，再一次噼里啪啦，如下：<br><img src="/images/openssl3.png" alt="paradin"></p><p>反馈我：<code>/usr/include/openssl/opensslconf.h:44: Error: CPP #error &quot;&quot;This openssl-devel package does not work your architecture?&quot;&quot;. Use the -cpperraswarn option to continue swig processing.</code>,这个提示大意是说openssl-devel版本不适合你的系统架构，也就是x86的去找x86的头文件，x86_64的去找x86_64文件，但现在是互相找不到对方。</p><p>既然说<code>/usr/include/openssl/opensslconf.h</code>这个第44行有错误，那我们就打开这个文件去看看第44行写的是啥：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">41 #elif defined(__x86_64__)</span><br><span class="line">42 #include "opensslconf-x86_64.h"</span><br><span class="line">43 #else</span><br><span class="line">44 #error "This openssl-devel package does not work your architecture?"</span><br><span class="line">45 #endif</span><br><span class="line"><span class="number">46</span> </span><br><span class="line">47 #undef openssl_opensslconf_multilib_redirection_h</span><br></pre></td></tr></table></figure></p><p>这里我把第44行改成了这样：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">41 #elif defined(__x86_64__)</span><br><span class="line">42 #include &quot;opensslconf-x86_64.h&quot;</span><br><span class="line">43 #else</span><br><span class="line">44 #include &quot;opensslconf.h&quot;    #去掉了原来的error提示，改成了安装opensslconf.h文件。</span><br><span class="line">45 #endif</span><br><span class="line">46 </span><br><span class="line">47 #undef openssl_opensslconf_multilib_redirection_h</span><br></pre></td></tr></table></figure></p><p>这一次重新执行<code>sudo pip install docker-registry</code>，终于成功…<br><img src="/images/openssl4.png" alt="paradin"></p><p><img src="/images/agirl.gif" alt="akb48"></p>]]></content>
    
    <summary type="html">
    
      这破玩意查了半天...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
      <category term="容器技术" scheme="http://yoursite.com/tags/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>在国王杯前夕评巴萨</title>
    <link href="http://yoursite.com/2018/04/21/%E5%9C%A8%E5%9B%BD%E7%8E%8B%E6%9D%AF%E5%89%8D%E5%A4%95%E8%AF%84%E5%B7%B4%E8%90%A8/"/>
    <id>http://yoursite.com/2018/04/21/在国王杯前夕评巴萨/</id>
    <published>2018-04-20T16:44:17.000Z</published>
    <updated>2018-04-20T17:40:54.008Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>今天凌晨的马竞在西甲意外输给了皇家社会，巴萨的积分优势扩大到了12分。这个周末巴萨要跟塞维利亚打国王杯决赛，4月30号对拉科鲁尼亚的西甲联赛巴萨只要获胜，就会拿到今年的西甲联赛冠军，从而以冠军姿态在诺坎普迎接本赛季第二场国家德比。</p><h2><span id="巴尔韦德的困境">巴尔韦德的困境</span></h2><p>巴萨今年可以说是低姿态开始：从内马尔突然的离开到西超杯被皇马灌了5个，不可为说不惨。但是巴尔韦德在联赛却目前保持不败，这个成绩单可以说是相当不错的，这中间还有在伯纳乌的三球胜利。</p><p>赛季中前段，巴萨三线顺风顺水，前有塞梅多惊艳开场，后有大祭司维尔马伦扎实顶上，主教练巴尔韦德也给了阿奈斯这样小将出场机会，哪怕登贝莱那时候养伤，报纸媒体一片其乐融融。如果保利尼奥再有进球，更是一片狂欢。</p><p>然后巴尔韦德的保守开始慢慢让人所诟病，他是一个重视防守的教练，这很好，但是他有了库迪尼奥也有了归来的登贝莱，结果反而不敢搞轮换，甚至坚持让布教授打封闭出场，虽然不少人抱怨，但是由于球队整体战绩还算平稳，所以没有大规模的重视。可是巴萨欧冠的结果跟恩里克的第二个赛季一样，倒在了与罗马的第二回合比赛里，连续三年没有闯入欧冠四强。</p><p>其实对战罗马的第一回合，巴萨的4：1已经是靠意志拼下来的比赛，球员难免在第二回合的心态上有所轻敌，这种心态上的轻敌难免会影响到身体，但是巴尔韦德的临场指挥也让人严重不满。落下这耻辱一战，媒体和球迷之前的“忍气吞声”一并爆发，狂轰滥炸，直到现在依旧有人说“哪怕真的赛季双冠，也会因为欧冠的失利而让那两冠索然无味”。<br><img src="/images/fcb4.png" alt="paradin"></p><p>所以，巴尔韦德要在这个周日的国王杯决赛和对阵拉科鲁尼亚的西甲联赛里稳扎稳打，把国王杯和西甲冠军彻底拿到手里，这样整个人也能轻松一些。可是说来说去罗马一役这一个跟头摔得太疼了，在那么重大的比赛里失败，肯定需要在一个同样重大的比赛里胜利以挽回颜面，第二回合的国家德比无疑就是一个好的机会，如果巴尔韦德成功捍卫了诺坎普，“联赛双杀皇马+国内双冠”也能成为一个功劳。但是如果那场比赛，一心要打破巴萨不败金身的皇马真的成功了，那巴尔韦德势必在巴萨主帅的位置上也是飘摇。</p><p>所以巴帅，请务必要拿下国王杯冠军+西甲冠军！在第二个国家德比里也请拼尽全力！这样才能多少挽回一点“罗马之耻”的颜面。<br><img src="/images/fcb1.png" alt="paradin"></p><h2><span id="夏季转会展望">夏季转会展望</span></h2><p>我个人认为，巴萨很有可能在今年夏天卖掉如下几个人：西莱森、戈麦斯、小苏亚雷斯、艾尔卡塞尔、比达尔，自由走人的可能会是小白。这些人能套现7000万应该就满足了。</p><p>巴萨后卫现在四个人皮克和维尔马伦属于潜藏的伤员病号，米纳技术还是太糙，稍微让人放心的就是乌姆蒂蒂，他的续约问题肯定是休赛期的一个大事。不过我觉得米纳其实可以再留一年看看，他身体素质很好，而且人还年轻没伤病，只要心态练得沉稳，当一个合格的中后卫不难。</p><p>至于中场，个人希望小白再踢一年，现在我也觉得一个满血的小白应付普通的联赛、欧冠小组赛和杯赛都不是什么难事。但是目前的媒体趋势是小白赛季结束会来中超重庆队，即使这样巴萨也需要一个山寨的坎特和一个山寨的埃里克森，而罗贝托集这两个属性于一身，所以他就是一个“奉献的砖”，但是这样如果比达尔真的不留下来的话，巴萨还需要补进一个右后卫跟塞梅多良性竞争，这个右后卫的人选就比较挠头了。贝莱林？或许是一个选择，但是这个选择跟当年小法一样—要是双输就不好了。</p><p>前场如果能拿下格里兹曼肯定是好的，艾尔卡塞尔这种“躲着后卫”的踢法，虽然进球效率可以，但是没有真正起到轮换苏亚雷斯的作用。这样巴萨还需要在板凳上补充一个中锋（不用多能进球，哪怕搅屎棍也可以），同时也做好登贝莱/苏亚雷斯/梅西/格里兹曼（假设他真的来）的轮换。</p><p>总而言之，现在巴萨还是回归433比较好，配合442和4312的变化。那么休赛期最重要的补强就是格里兹曼+能抗中卫的前锋+一个中场+一个优秀的边后卫。</p><p>我个人希望的引援名单如下：<br>中场是魏格尔和B队的阿莱尼亚，埃里克森、博格巴和维拉蒂这三个不算是好的选择，要么太贵，要么节奏太慢。至于伊斯科、大卫席尔瓦、皮亚尼奇，那想都别想了，母队不会放人的。至于格雷茨卡，拜仁不是善茬；<br>边后卫可以考虑贝莱林，这个要看一下阿森纳的新教练是谁，摩纳哥的法比尼奥也可以，我知道他现在改中场了，也不耽误来一下跟罗贝托交叉换位…<br>前锋的话，我个人推荐B队阿奈斯试试看，其他的人选估计就是在西甲联赛内部找了；<br>这几个位置，最重要就是中场！梅西当初在哈白布的配合下威力无穷，一旦巴萨的中场重新掌握了控制力，不用频繁回撤的梅西依旧会进球如麻，这一点毋庸置疑。<br><img src="/images/fcb3.png" alt="paradin"></p><h2><span id="温格会来">温格会来？</span></h2><p>我个人首先不希望巴尔韦德下课，毕竟现在巴萨联赛冠军十拿九稳，国王杯如果也揽入怀中，这样一个成绩单也是一个80分，如果这个分数都炒掉主教练，那么继任者的压力势必很大，所以我个人倾向巴尔韦德留任，好好想一下，等阿图尔以及可能会来的格里兹曼到位了，巴萨应该怎么打。</p><p>不过如果温格真的来了，我个人也是赞成的，因为阿森纳的球风本来跟巴萨相似，相信温格跟梅西等人也会无缝接入，到时候教授或许真的可以在巴萨圆了欧冠梦想，不过这个想法成真的可能性低于5%，想想就得了。</p><h2><span id="下赛季的任务">下赛季的任务</span></h2><p>1.进攻体系依旧围绕梅西建队，让梅西继续火力全开的同时保证休息，欧冠要他有大用；<br>2.新球员（包括库蒂尼奥和登贝莱）适应巴萨的风格和体系，让皮克和布教授也能轮换得到休息；<br>3.欧冠一定要进入四强；<br>4.欧冠四强的基础上，西甲联赛冠军和国王杯能拿还是要拿，同时最好也能阻击皇马；<br><img src="/images/fcb2.png" alt="paradin"></p>]]></content>
    
    <summary type="html">
    
      这几天的巴萨真是风雨飘摇，操碎我的心
    
    </summary>
    
      <category term="追乱花天" scheme="http://yoursite.com/categories/%E8%BF%BD%E4%B9%B1%E8%8A%B1%E5%A4%A9/"/>
    
    
      <category term="国际足坛" scheme="http://yoursite.com/tags/%E5%9B%BD%E9%99%85%E8%B6%B3%E5%9D%9B/"/>
    
      <category term="巴塞罗那" scheme="http://yoursite.com/tags/%E5%B7%B4%E5%A1%9E%E7%BD%97%E9%82%A3/"/>
    
  </entry>
  
  <entry>
    <title>国内Docker的加速方法</title>
    <link href="http://yoursite.com/2018/04/20/%E5%9B%BD%E5%86%85Docker%E7%9A%84%E5%8A%A0%E9%80%9F%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2018/04/20/国内Docker的加速方法/</id>
    <published>2018-04-19T16:00:04.000Z</published>
    <updated>2018-04-19T16:17:09.102Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>由于大陆政府的特殊政策，国内想访问一些国外的资源是非常的曲折和痛苦，比较有代表性的就是亚马逊的云存储以及docker，尤其在<code>docker pull</code>一些镜像的时候，更是心惊胆战，祈求不要出现timout，然而现实往往很骨感。如下图：<br><img src="/images/jiasu.png" alt="paradin"></p><p>那么应该如何达到加速的效果呢？</p><p>在<code>CentOS 7</code>里，对于使用<code>systemd</code>的系统，请在<code>/etc/docker/daemon.json</code>中写入如下内容：（如果文件不存在请新建该文件）<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"registry-mirrors"</span>: [</span><br><span class="line">    <span class="string">"https://registry.docker-cn.com"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意，一定要保证该文件符合 json 规范，否则 Docker 将不能启动。</p><p>之后重新启动服务。<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></table></figure></p><p>注意：如果您之前查看旧教程，修改了<code>docker.service</code>文件内容，请去掉您添加的内容（–registry-mirror=<a href="https://registry.docker-cn.com）。" target="_blank" rel="noopener">https://registry.docker-cn.com）。</a></p><p>配置加速之后，如果拉取镜像仍然十分缓慢，请手动检查加速器配置是否生效，在命令行执行<code>docker info |grep &#39;Registry Mirrors&#39; -A</code>，如果从结果中看到了如下内容，说明配置成功。<br><img src="/images/jiasu2.png" alt="paradin"></p><p>现在再重新尝试一下<code>docker pull training/webapp</code>，看看效果：<br><img src="/images/jiasu3.png" alt="paradin"></p><p>仅用17秒就pull了几乎400MB的镜像，高下立判！</p>]]></content>
    
    <summary type="html">
    
      墙内想干点事的确挺费劲
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>在Grafana里添加worldping插件</title>
    <link href="http://yoursite.com/2018/04/19/%E5%9C%A8Grafana%E9%87%8C%E6%B7%BB%E5%8A%A0worldping%E6%8F%92%E4%BB%B6/"/>
    <id>http://yoursite.com/2018/04/19/在Grafana里添加worldping插件/</id>
    <published>2018-04-19T02:41:18.000Z</published>
    <updated>2018-04-19T03:53:34.284Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="安装插件">安装插件</span></h2><p>worldping是一个监控网站的dns、ping、http响应、https响应的插件，要安装它很简单，在granafa服务器里执行如下命令：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grafana-cli plugins install raintank-worldping-app</span><br><span class="line">systemctl restart grafana-server.service</span><br></pre></td></tr></table></figure></p><p>执行完毕之后在grafana的界面里选择<code>Plugins</code>，然后在<code>APP</code>里找到<code>worldping</code>，启动它，但是此时发现需要一个api，如图：<br><img src="/images/worldping.png" alt="paradin"></p><p>此时你需要登录grafana的官网，然后点击<code>api keys</code>和<code>ADD API KEY</code>，就可以生成一个<code>API KEY</code>，名字可以随便起，如下：<br><img src="/images/worldping2.png" alt="paradin"></p><p>将生成的api key保存好，并且填回到grafana的api key里，这样worldping插件就可以使用了，如图：<br><img src="/images/worldping3.png" alt="paradin"></p><h2><span id="监控网站节点">监控网站节点</span></h2><p>此时点击黄色旋涡，发现多了worldping的选项，点击<code>worldping Home</code>，如图：<br><img src="/images/worldping4.png" alt="paradin"></p><p>然后点击<code>+ New Endpoint</code>，这里我输入我公司的官网域名，然后<code>begin auto-discovery</code>，如图：<br><img src="/images/worldping5.png" alt="paradin"></p><p>生成了结果之后，点击add，此时开始检查几个大城市，如芝加哥、东京、纽约、巴黎等大城市连接到刚刚输入的域名的情况，如图：<br><img src="/images/worldping6.png" alt="paradin"></p><p>大约需要1~2分钟后，数据检查完成，可以点击<code>GO to Summary Dashboard</code>，就会看到图像了：<br><img src="/images/worldping7.png" alt="paradin"></p><p>为什么我这个图里没有http?因为在nginx里我们做了http强制rewrite跳转到https，所以是读不到值的。</p><h2><span id="删除网站节点">删除网站节点</span></h2><p>如果要删除网站节点，还是在worldping里点击要删除网站后面的齿轮图标，如图：<br><img src="/images/worldping8.png" alt="paradin"></p><p>然后选择<code>configuration</code>，这里可以修改网站域名，要删除的话，选择最下面的<code>destory</code>，输入DELETE确认，然后就可以点击<code>DELETE</code>删除了，如图：<br><img src="/images/worldping9.png" alt="paradin"></p>]]></content>
    
    <summary type="html">
    
      这个搭配zabbix的网站监控，双重check!
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="grafana" scheme="http://yoursite.com/tags/grafana/"/>
    
      <category term="图像监控" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%83%8F%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>用非root用户启动tomcat进程</title>
    <link href="http://yoursite.com/2018/04/18/%E4%BD%BF%E7%94%A8%E6%99%AE%E9%80%9A%E7%94%A8%E6%88%B7%E5%90%AF%E5%8A%A8tomcat/"/>
    <id>http://yoursite.com/2018/04/18/使用普通用户启动tomcat/</id>
    <published>2018-04-18T14:19:34.000Z</published>
    <updated>2018-04-19T14:05:04.577Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>使用非root用户启动进程是运维安全的一个主要环节，拿tomcat进程来说，如果是使用root用户去启动了tomcat，那么有一个严重的问题，那就是tomcat具有root权限。这意味着你的任何一个jsp脚本都具有root权限，所以那些不怀好意的人可以轻易地用jsp脚本去搞破坏，甚至删除你整个硬盘里的东西！所以为了活着，我们要极力避免这种现象。很多的软件都自带的用户/用户组，比如nginx、zabbix、elasticsearch，但是也有很多的软件没有这么贴心的服务，这就需要我们手动的更改了。</p><h2><span id="使用非root用户启动tomcat">使用非root用户启动tomcat</span></h2><p>以tomcat为例，打算用chris账号(属于chen这个group)启动。那么首先先创建账号和组，如下：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@chen-docker ~]groupadd chen    #创建chen这个组</span><br><span class="line">[root@chen-docker ~]useradd -s /bin/bash -g chen chris    #在这个组里面添加chris这个用户</span><br><span class="line">[root@chen-docker ~]passwd chris    #给这个用户设定密码</span><br><span class="line">[root@chen-docker ~]# id chris</span><br><span class="line">uid=1000(chris) gid=1002(chen) groups=1002(chen)    #可见添加成功</span><br></pre></td></tr></table></figure></p><p><code>su chris</code>切换到chris用户，在<code>/home/chris</code>里使用<code>wget http://apache.fayea.com/tomcat/tomcat-9/v9.0.7/bin/apache-tomcat-9.0.7.tar.gz</code>下载tomcat。然后解压缩在/home/chris里，因为chris用户在这里是有权限的。然后进行如下的操作：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd  ~<span class="regexp">/ 代表用户所在目录</span></span><br><span class="line"><span class="regexp">mkdir -p ~/</span>shell-script</span><br><span class="line">cd ~<span class="regexp">/shell-script/</span></span><br><span class="line">touch start.sh</span><br><span class="line">toush stop.sh</span><br></pre></td></tr></table></figure></p><p>这个<code>start.sh</code>的内容很简单，如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#/bin/bash</span><br><span class="line">if [ "root" == "$USER" ]    #不让root启动</span><br><span class="line">then</span><br><span class="line">    echo <span class="string">"can't start with user 'root',retry after change user!"</span></span><br><span class="line">    exit <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    cd /home/chris/apache-tomcat<span class="number">-9.0</span><span class="number">.7</span>/bin/    &amp;&amp; ./start.sh</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p><p><code>shutdown.sh</code>的内容同理：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#/bin/bash</span><br><span class="line">if [ "root" == "$USER" ]    #不让root启动</span><br><span class="line">then</span><br><span class="line">    echo <span class="string">"can't start with user 'root',retry after change user!"</span></span><br><span class="line">    exit <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    cd /home/chris/apache-tomcat<span class="number">-9.0</span><span class="number">.7</span>/bin/    &amp;&amp; ./shutdown.sh</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p><p><code>chmod +x *.sh</code>给上面两个脚本可执行权限，但是现在执行startup.sh或者shutdown.sh会出现一个问题：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Neither the JAVA_HOME nor the JRE_HOME environment variable is defined</span><br><span class="line">At least one <span class="keyword">of</span> these environment variable is needed to run <span class="keyword">this</span> program</span><br></pre></td></tr></table></figure></p><p>这是因为chris用户没有权限去启动java这个可执行程序，如果使用<code>java -version</code>回答是<code>bash: java: command not found</code>，这个时候怎么办？</p><p>编辑<code>~/.bash_profile</code>，在末尾处加上如下的内容：<br><img src="/images/noroot2.png" alt="paradin"></p><p>然后<code>source .bash_profile</code>，再使用<code>java -version</code>确认一下应该是OK了。这个时候也是可以使用chris用户去启动刚刚的那个start.sh和shutdown.sh的。<br><img src="/images/noroot3.png" alt="paradin"></p><p>由于我们的tomcat是源码解压缩，所以要使用root用户去创建一下<code>/etc/init.d/tomcat</code>。里面内容如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">case</span> $<span class="number">1</span> <span class="keyword">in</span></span><br><span class="line">start)</span><br><span class="line">su - chris -lc "sh /home/chris/shell-script/start.sh";;     #如果要root启动，那就是su - root -lc "sh /home/utomcat/shell-script/start.sh";;</span><br><span class="line">stop)</span><br><span class="line">su - chris -lc <span class="string">"sh /home/chris/shell-script/shutdown.sh"</span>;;</span><br><span class="line">*)</span><br><span class="line">echo <span class="string">"parameter error, usage:(start|stop)"</span>;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure></p><p>保存之后，执行一下<code>service tomcat start</code>看看效果。<br><img src="/images/noroot4.png" alt="paradin"></p><p>如果要设置开机自启动，别忘了<code>chkconfig --add tomcat</code>和<code>chkconfig tomcat on</code>，在浏览器打开<code>ip:8080</code>看见汤姆猫~<br><img src="/images/noroot5.png" alt="paradin"></p><h2><span id="当普通用户要使用1024以下的端口">当普通用户要使用1024以下的端口</span></h2><p>众所周知，linux默认是不准许普通用户调用1024以下的端口的，那么遇到这样的需求怎么办呢？最好的方法是使用iptables。</p><p>首先让程序运行在非root帐户下，并绑定高于1024的端口，在确保能正常工作的时候，将低端口通过端口转发，将低端口转到高端口，从而实现非root运行的程序绑定低端口。要使用此方法可以使用下面的方式：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w net.ipv4.ip_forward=1        #要长久保存，需要在/etc/sysctl.conf文件内修改，然后sysctl -p /etc/sysctl.conf</span><br><span class="line">iptables -F -t nat</span><br><span class="line">iptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to:8088    #将80端口转发到8088</span><br><span class="line">iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 8080    #这句话也可以</span><br></pre></td></tr></table></figure></p><p>这么操作在速度上没有任何影响。</p>]]></content>
    
    <summary type="html">
    
      chmod u+s 就是给某个程序的所有者以suid权限，可以像root用户一样操作
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="centos" scheme="http://yoursite.com/tags/centos/"/>
    
      <category term="运维安全" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>使用docker做一个主从同步的redis集群</title>
    <link href="http://yoursite.com/2018/04/18/%E4%BD%BF%E7%94%A8docker%E5%81%9A%E4%B8%80%E4%B8%AA%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E7%9A%84redis%E9%9B%86%E7%BE%A4/"/>
    <id>http://yoursite.com/2018/04/18/使用docker做一个主从同步的redis集群/</id>
    <published>2018-04-17T16:14:44.000Z</published>
    <updated>2018-04-19T03:51:26.430Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="查看容器内部信息">查看容器内部信息</span></h2><p>之前用<code>docker run -it --name redis-master redis /bin/bash</code>创建了一个redis的docker，现在登陆发现状态已经是exit，于是就使用<code>docker container start 容器ID号or容器名称</code>来重新启动。如图：<br><img src="/images/docker4.png" alt="paradin"></p><p>然后书里说到要用<code>docker inspect</code>来查看所挂载volume的情况，使用命令:<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@chen-docker ~]# docker inspect --format &quot;&#123;&#123; .Volumes &#125;&#125;&quot; f391531120b0</span><br></pre></td></tr></table></figure></p><p>但是很不幸，系统反馈给我一个错误：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Template parsing error: template: :1:3: executing &quot;&quot; at &lt;.Volumes&gt;: map has no entry for key &quot;Volumes&quot;</span><br></pre></td></tr></table></figure></p><p>没有这个<code>Volumes</code>，那就干脆查看一下这个容器的所有信息：<code>docker inspect f391531120b0</code>，这个命令里面有<code>Config、Mounts</code>、<code>HostConfig</code>、<code>NetworkSettings</code>等等整个容器的所有信息，比如看一下NetworkSettings相关的内容，如图：<br><img src="/images/docker6.png" alt="paradin"></p><p>此时使用如下命令：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@chen-docker ~]# docker inspect --format &quot;&#123;&#123; .NetworkSettings.IPAddress &#125;&#125;&quot; f391531120b0    #注意前面的.</span><br><span class="line">192.168.0.2</span><br><span class="line">[root@chen-docker ~]# docker inspect --format &quot;&#123;&#123; .NetworkSettings.MacAddress &#125;&#125;&quot; f391531120b0</span><br><span class="line">02:42:c0:a8:00:02</span><br></pre></td></tr></table></figure></p><p>这样就可以获取到内网IP和mac地址，同理换成<code>docker inspect f391531120b0 | grep Mounts -A 10</code>，看一下挂载信息，如图：<br><img src="/images/docker5.png" alt="paradin"></p><p>原来容器里的/data其实就是宿主机的<code>/var/lib/docker/volumes/94b3c20a6d269c7498ab59ee45c560e84fed64a636767a4baa54fa7befbcd4ff/_data</code>这个文件夹。为了验证这一点，我先到宿主机去创建一个叫aaa文件，如下：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@f391531120b0:/data# cat aaa </span><br><span class="line">123123</span><br></pre></td></tr></table></figure></p><p>再返回到宿主机上看：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@chen-docker ~]# cd /var/lib/docker/volumes/94b3c20a6d269c7498ab59ee45c560e84fed64a636767a4baa54fa7befbcd4ff/_data</span><br><span class="line">[root@chen-docker _data]# ls</span><br><span class="line">aaa</span><br><span class="line">[root@chen-docker _data]# cat aaa </span><br><span class="line">123123</span><br></pre></td></tr></table></figure></p><p>这就搞定了！</p><h2><span id="主从同步排错">主从同步排错</span></h2><p>就是按书里写的开始配置和启动<code>redis-slave</code>，但是却发现同步没有成功，在<code>redis-slave</code>日志里发现这样的话：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">32677:S 08 Feb 16:14:40.952 * Connecting to MASTER 172.168.10.70:6379</span><br><span class="line">32677:S 08 Feb 16:14:40.952 * MASTER &lt;-&gt; SLAVE sync started</span><br><span class="line">32677:S 08 Feb 16:14:40.953 # Error condition on socket for SYNC: Connection refused</span><br></pre></td></tr></table></figure></p><p>这个的原因就是redis主服务器绑定了127.0.0.1，那么跨服务器IP的访问就会失败，从服务器用IP和端口访问主的时候，主服务器发现本机6379端口绑在了127.0.0.1上，也就是只能本机才能访问，外部请求会被过滤。所以需要修改<code>redis-master</code>的<code>redis.conf</code>，注释掉<code>bind 127.0.0.1</code>，如果是线上生产环境建议绑定IP地址。</p><p>重新启动redis之后，发现同步依然失败，日志变成了这样：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">90:S 17 Apr 09:27:35.906 * Non blocking connect for SYNC fired the event.</span><br><span class="line">90:S 17 Apr 09:27:35.907 # Error reply to PING from master: &apos;-DENIED Redis is running in protected mode because protected mode is enabled, no bind address was specified, no authentication password is requested to clients. In this mode connections are only accepted from the loopback interface. If you want to connect&apos;</span><br><span class="line">90:S 17 Apr 09:27:36.908 * Connecting to MASTER 192.168.0.2:6379</span><br><span class="line">90:S 17 Apr 09:27:36.909 * MASTER &lt;-&gt; SLAVE sync started</span><br><span class="line">90:S 17 Apr 09:27:36.909 * Non blocking connect for SYNC fired the event.</span><br><span class="line">90:S 17 Apr 09:27:36.909 # Error condition on socket for SYNC: Connection reset by peer</span><br></pre></td></tr></table></figure></p><p>这个日志的意思是说redis在没有开启bind和密码的情况下，保护模式被开启。然后Redis的只接受来自环回IPv4和IPv6地址的连接。于是还是要修改redis-master的<code>redis.conf</code>关闭保护模式：<code>portected-mode no</code>，然后重启redis-master即可。</p><h2><span id="容器内安装ping">容器内安装ping</span></h2><p>先检查你的容器是使用什么系统的景象，如果是ubantu那就是<code>apt-get</code>，安装ping的命令如下：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install inetutils-ping</span><br></pre></td></tr></table></figure></p><h2><span id="如何让容器一直启动">如何让容器一直启动</span></h2><p>如果用了一段时间的docker就会发现，我们的容器经常用了一段时间就自动退出了，<code>docker ps</code>已经找不到了，在<code>docker ps -a</code>里面了，如图：<br><img src="/images/docker7.png" alt="paradin"></p><p>然后我们<code>docker start containerId</code>想重新开启这个容器，可能这次来的更快，没几分钟容器又自己关了，由这个问题又可能引发其它很多的问题。</p><p><code>docker run</code>指定的命令如果不是那些一直挂起的命令（比如运行top，不断echo），就是会自动退出的。<code>-d</code>命令是设置detach为<code>true</code>，根据官方的文档，意思是让这个命令在后台运行，但并不是一直运行，Docker容器后台运行,就必须有一个前台进程。主线程结束，容器会退出。</p><p>我们启动容器的时候不要<code>-d</code>命令启动，用<code>-dit</code>就好了，例如：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d hello-world(不要这么做)</span><br><span class="line">docker run -dit hello-world(推荐)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      从《容器与容器云》 的第19页开始...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
      <category term="主从同步" scheme="http://yoursite.com/tags/%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>使用zabbix监控memcache</title>
    <link href="http://yoursite.com/2018/04/03/%E4%BD%BF%E7%94%A8zabbix%E7%9B%91%E6%8E%A7memcache/"/>
    <id>http://yoursite.com/2018/04/03/使用zabbix监控memcache/</id>
    <published>2018-04-03T11:00:58.000Z</published>
    <updated>2018-04-03T11:05:46.074Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>监控memcache的原理跟监控redis差不多，都是通过一个类似info的东西可以查询到memcache的状态值，然后通过脚本去获取这些值给zabbix，当发现某值不正常就发出告警。</p><p>查询当年memcache状态的命令是<code>echo stats |nc 127.0.0.1  11211</code>，如果没有<code>nc</code>命令，那就<code>yum install -y nc</code>。</p><p>获得到的结果是这个样子的：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">[root@lconline-ec2 ~]# echo stats |nc 127.0.0.1  11211</span><br><span class="line">STAT pid <span class="number">1859</span>        memcache服务进程ID</span><br><span class="line">STAT uptime <span class="number">491093</span>    服务器已运行秒数</span><br><span class="line">STAT time <span class="number">1522740969</span>    服务器当前Unix时间戳</span><br><span class="line">STAT version <span class="number">1.4</span><span class="number">.25</span>        memcache版本</span><br><span class="line">STAT libevent <span class="number">1.4</span><span class="number">.13</span>-stable</span><br><span class="line">STAT pointer_size <span class="number">64</span>        操作系统指针大小</span><br><span class="line">STAT rusage_user <span class="number">14.321822</span>        进程累计用户时间</span><br><span class="line">STAT rusage_system <span class="number">14.095857</span>        进程累计系统时间</span><br><span class="line">STAT curr_connections <span class="number">5</span>        当前连接数量</span><br><span class="line">STAT total_connections <span class="number">51010</span>    Memcached运行以来连接总数</span><br><span class="line">STAT connection_structures <span class="number">8</span>    Memcached分配的连接结构数量</span><br><span class="line">STAT reserved_fds <span class="number">20</span></span><br><span class="line">STAT cmd_get <span class="number">0</span>        get命令请求次数</span><br><span class="line">STAT cmd_set <span class="number">0</span>        set命令请求次数</span><br><span class="line">STAT cmd_flush <span class="number">0</span>    flush命令请求次数</span><br><span class="line">STAT cmd_touch <span class="number">0</span>    touch命令请求次数</span><br><span class="line">STAT get_hits <span class="number">0</span>        get命令命中次数</span><br><span class="line">STAT get_misses <span class="number">0</span>    get命令未命中次数</span><br><span class="line">STAT delete_misses <span class="number">0</span>    <span class="keyword">delete</span>命令未命中次数</span><br><span class="line">STAT delete_hits <span class="number">0</span>        <span class="keyword">delete</span>命令命中次数</span><br><span class="line">STAT incr_misses <span class="number">0</span>        incr命令未命中次数</span><br><span class="line">STAT incr_hits <span class="number">0</span>        incr命令命中次数</span><br><span class="line">STAT decr_misses <span class="number">0</span>        decr命令未命中次数</span><br><span class="line">STAT decr_hits <span class="number">0</span>        decr命令命中次数</span><br><span class="line">STAT cas_misses <span class="number">0</span>        cas命令未命中次数</span><br><span class="line">STAT cas_hits <span class="number">0</span>            cas命令命中次数</span><br><span class="line">STAT cas_badval <span class="number">0</span>        使用擦拭次数</span><br><span class="line">STAT touch_hits <span class="number">0</span></span><br><span class="line">STAT touch_misses <span class="number">0</span></span><br><span class="line">STAT auth_cmds <span class="number">0</span>        认证命令处理的次数    </span><br><span class="line">STAT auth_errors <span class="number">0</span>        认证失败数目</span><br><span class="line">STAT bytes_read <span class="number">357040</span>        读取总字节数    </span><br><span class="line">STAT bytes_written <span class="number">60197691</span>        发送总字节数</span><br><span class="line">STAT limit_maxbytes <span class="number">1073741824</span>        分配的内存总大小（字节）</span><br><span class="line">STAT accepting_conns <span class="number">1</span>        服务器是否达到过最大连接（<span class="number">0</span>/<span class="number">1</span>）</span><br><span class="line">STAT listen_disabled_num <span class="number">0</span>        失效的监听数</span><br><span class="line">STAT time_in_listen_disabled_us <span class="number">0</span></span><br><span class="line">STAT threads <span class="number">4</span>        当前线程数</span><br><span class="line">STAT conn_yields <span class="number">0</span>        连接操作主动放弃数目</span><br><span class="line">STAT hash_power_level <span class="number">16</span></span><br><span class="line">STAT hash_bytes <span class="number">524288</span>        当前存储占用的字节数</span><br><span class="line">STAT hash_is_expanding <span class="number">0</span></span><br><span class="line">STAT malloc_fails <span class="number">0</span>    </span><br><span class="line">STAT bytes <span class="number">0</span>        当前存储占用的字节数</span><br><span class="line">STAT curr_items <span class="number">0</span>        当前存储的数据总数</span><br><span class="line">STAT total_items <span class="number">0</span>        启动以来存储的数据总数</span><br><span class="line">STAT expired_unfetched <span class="number">0</span>    </span><br><span class="line">STAT evicted_unfetched <span class="number">0</span></span><br><span class="line">STAT evictions <span class="number">0</span>        LRU释放的对象数目</span><br><span class="line">STAT reclaimed <span class="number">0</span>        已过期的数据条目来存储新数据的数目</span><br><span class="line">STAT crawler_reclaimed <span class="number">0</span></span><br><span class="line">STAT crawler_items_checked <span class="number">0</span></span><br><span class="line">STAT lrutail_reflocked <span class="number">0</span>    </span><br><span class="line">END</span><br></pre></td></tr></table></figure></p><p>修改<code>zabbix_agentd.conf</code>，添加一个新的自定义项：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UserParameter=memcached.stat[*],(echo stats; sleep <span class="number">1</span>) | telnet <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">11211</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span> | awk <span class="string">'/STAT $1 / &#123;print $NF&#125;'</span></span><br></pre></td></tr></table></figure></p><p>然后重启<code>zabbix-agent</code>，模板就用github里的就好，看到的效果如下：<br><img src="/images/check-memcached.png" alt="paradin"></p>]]></content>
    
    <summary type="html">
    
      上帝抛弃了吃不饱饭的人民
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="zabbix" scheme="http://yoursite.com/tags/zabbix/"/>
    
      <category term="memcached" scheme="http://yoursite.com/tags/memcached/"/>
    
  </entry>
  
  <entry>
    <title>使用zabbix去监控网站和tcp连接</title>
    <link href="http://yoursite.com/2018/04/02/%E4%BD%BF%E7%94%A8zabbix%E5%8E%BB%E7%9B%91%E6%8E%A7%E7%BD%91%E7%AB%99/"/>
    <id>http://yoursite.com/2018/04/02/使用zabbix去监控网站/</id>
    <published>2018-04-02T01:42:45.000Z</published>
    <updated>2018-04-03T11:58:22.848Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="网页状态码监控">网页状态码监控</span></h2><p>在zabbix的web界面，<code>配置</code>–<code>主机</code>–选择一个有外网权限的服务器，比如选择zabbix server–<code>Web检测</code>，如图：<br><img src="/images/checkweb1.png" alt="paradin"></p><p>然后点击右上角的<code>创建Web场景</code>，然后依次填入<code>名称</code>，<code>间隔</code>，<code>客户端</code>等等，如图：<br><img src="/images/checkweb2.png" alt="paradin"></p><p>然后编辑<code>步骤</code>，先<code>添加</code>，填入对应的url，然后写上200状态码，意思就是返回200是OK的。<br><img src="/images/checkweb4.png" alt="paradin"><br>保存即可，如果还有http认证，那么就继续填写认证。</p><p>至此，一个简单的监控官网状态码的配置过程就结束了，剩下就是增添一下触发器，如下：<br><img src="/images/checkweb3.png" alt="paradin"></p><h2><span id="tcp连接监控">tcp连接监控</span></h2><p>首先在<code>zabbix-agentd.conf</code>里添加一个新的自定义监控项：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UserParameter=tcp.status[*],netstat -a | awk <span class="string">'/^tcp/ &#123;++y[$NF]&#125; END &#123;for(i in y) print i,y[i]&#125;'</span> |  grep $<span class="number">1</span> | awk <span class="string">'&#123;print $NF&#125;'</span></span><br></pre></td></tr></table></figure></p><p>然后<code>service zabbix-agent restart</code>重启客户端，模板就是<a href="https://gitee.com/careyjike_173/zabbix/tree/master/template" target="_blank" rel="noopener">https://gitee.com/careyjike_173/zabbix/tree/master/template</a> 里的<code>zbx_tcp_status_templates.xml</code>，直接导入即可。如图：<br><img src="/images/checkweb5.png" alt="paradin"></p><p>然后自己配置一下<code>time_wait</code>/<code>close_wait</code>的告警阈值。</p><p><img src="/images/裤子卡世界波.gif" alt="akb48" title="裤子卡中圈世界波"></p>]]></content>
    
    <summary type="html">
    
      我可算是那个zabbix监控模板扒个精光...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="zabbix" scheme="http://yoursite.com/tags/zabbix/"/>
    
      <category term="web监控" scheme="http://yoursite.com/tags/web%E7%9B%91%E6%8E%A7/"/>
    
      <category term="tcp连接" scheme="http://yoursite.com/tags/tcp%E8%BF%9E%E6%8E%A5/"/>
    
  </entry>
  
  <entry>
    <title>使用zabbix去监控php-fpm</title>
    <link href="http://yoursite.com/2018/04/02/%E4%BD%BF%E7%94%A8zabbix%E5%8E%BB%E7%9B%91%E6%8E%A7php-fpm/"/>
    <id>http://yoursite.com/2018/04/02/使用zabbix去监控php-fpm/</id>
    <published>2018-04-02T01:42:36.000Z</published>
    <updated>2018-04-03T11:58:46.168Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="开启状态统计">开启状态统计</span></h2><p>nginx有一个status来获取nginx处理信息的总览情况，php-fpm也有一个状态统计。要打开这个状态统计，需要先打开php-fpm.conf，将<code>pm.status_path = /status</code>前面的注释去掉。</p><p>然后跑到nginx里，在<code>nginx.conf</code>里添加一个location：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   location ~ ^<span class="regexp">/(status|ping) &#123;</span></span><br><span class="line"><span class="regexp">       fastcgi_pass 127.0.0.1:9000;</span></span><br><span class="line"><span class="regexp">       include fastcgi.conf;</span></span><br><span class="line"><span class="regexp">       access_log off;</span></span><br><span class="line"><span class="regexp">       allow 127.0.0.1;</span></span><br><span class="line"><span class="regexp">       deny all;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p><p>然后重启一下php-fpm和nginx，在命令行里输入<code>curl -s http://127.0.0.1:80/status</code>，就会看到php的状态统计，如下图：<br><img src="/images/checkphp.png" alt="paradin"></p><h2><span id="php-fpm-status详解">php-fpm status详解</span></h2><p><code>pool</code> - fpm池子名称，大多数为www<br><code>process manager</code> – 进程管理方式,值：static, dynamic<br><code>start time</code>– 启动日期,如果reload了php-fpm，时间会更新<br><code>start since</code> – 运行时长<br><code>accepted conn</code> – 当前池子接受的请求数<br><code>listen queue</code> – 请求等待队列，如果这个值不为0，那么要增加FPM的进程数量<br><code>max listen queue</code> – 请求等待队列最高的数量<br><code>listen queue len</code> – socket等待队列长度<br><code>idle processes</code> – 空闲进程数量<br><code>active processes</code> – 活跃进程数量<br><code>total processes</code> – 总进程数量<br><code>max active processes</code> – 最大的活跃进程数量（FPM启动开始算）<br><code>max children reached</code> - 大道进程最大数量限制的次数，如果这个数量不为0，那说明你的最大进程数量太小了，请改大一点。<br><code>slow requests</code> – 启用了php-fpm slow-log，缓慢请求的数量 </p><h2><span id="配置监控">配置监控</span></h2><p>跑到<code>zabbix-agentd.conf</code>里添加一个自定义监控项，如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UserParameter=php-fpm.status[*],/usr/bin/curl -s <span class="string">"http://127.0.0.1/php-fpm_status?xml"</span> | grep <span class="string">"&lt;$1&gt;"</span> | awk -F<span class="string">'&gt;|&lt;'</span> <span class="string">'&#123; print $$3&#125;'</span></span><br></pre></td></tr></table></figure></p><p>然后重启一下<code>zabbix-agent</code>，模板就是<a href="https://gitee.com/careyjike_173/zabbix/tree/master/template" target="_blank" rel="noopener">https://gitee.com/careyjike_173/zabbix/tree/master/template</a> 里的<code>zbx_php-fpm_templates.xml</code>，直接导入即可！</p><p>效果如下图：<br><img src="/images/checkphp2.png" alt="paradin"></p><p><img src="/images/百年美洲杯对委内瑞拉助攻伊瓜因.gif" alt="paradin" title="梅西百年美洲杯对委内瑞拉助攻伊瓜因"></p>]]></content>
    
    <summary type="html">
    
      php-fpm得多一点了解，不然即使有报警了也不知道怎么办
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="zabbix" scheme="http://yoursite.com/tags/zabbix/"/>
    
      <category term="php-fpm" scheme="http://yoursite.com/tags/php-fpm/"/>
    
  </entry>
  
  <entry>
    <title>使用zabbix去监控nginx</title>
    <link href="http://yoursite.com/2018/04/02/%E4%BD%BF%E7%94%A8zabbix%E5%8E%BB%E7%9B%91%E6%8E%A7nginx/"/>
    <id>http://yoursite.com/2018/04/02/使用zabbix去监控nginx/</id>
    <published>2018-04-02T01:42:24.000Z</published>
    <updated>2018-04-03T11:58:00.111Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="准备工作">准备工作</span></h2><p>zabbix监控nginx，首先要确认nginx里是否有<code>http_stub_status_module</code>这个模块，一般来说，这个模块是自动安装的，<code>nginx -V</code>如下图：<br><img src="/images/checknginx1.png" alt="paradin"></p><p>如果你的nginx没有这个模块，请去看<a href="https://rorschachchan.github.io/2018/01/03/Nginx动态编译新的模块/" target="_blank" rel="noopener">https://rorschachchan.github.io/2018/01/03/Nginx动态编译新的模块/</a> 。</p><p>然后在<code>nginx.conf</code>里添加一段话：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> location = <span class="regexp">/nginx-status  &#123;</span></span><br><span class="line"><span class="regexp">    stub_status   on;</span></span><br><span class="line"><span class="regexp">    access_log   off;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p><p><code>nginx -s reload</code>一下，然后在命令行输入<code>curl http://127.0.0.1/nginx-status</code>，就会看到如下的界面：<br><img src="/images/checknginx2.png" alt="paradin"></p><p>这样就可以通过<code>http_stub_status_module</code>检查nginx情况了！</p><h2><span id="nginx-status详解">nginx status详解</span></h2><p>以上图的<code>nginx status</code>来做例子说明一下各个数字的意思：<br><code>active connections</code> – 活跃的连接数量<br><code>accepts</code> — 总共处理了3832000个连接<br><code>handled</code> — 成功创建3832000次握手<br><code>requests</code> —  总共处理了3295877个请求<br><code>reading</code> — 读取客户端的连接数<br><code>writing</code> — 响应数据到客户端的数量<br><code>waiting</code> — 开启<code>keep-alive</code>的情况下,这个值等于<code>active – (reading+writing)</code>, 意思就是 Nginx 已经处理完正在等候下一次请求指令的驻留连接</p><h2><span id="配置监控">配置监控</span></h2><p>有了模块，还需要添加一个脚本，然后就可以获取上面的数值了，脚本如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"># Method of use</span><br><span class="line"></span><br><span class="line">HOST=<span class="string">"127.0.0.1"</span></span><br><span class="line">PORT="80"#这个根据实际情况填写</span><br><span class="line">URL=<span class="string">"http://$&#123;HOST&#125;:$&#123;PORT&#125;/nginx-status"</span></span><br><span class="line"></span><br><span class="line">active() &#123;</span><br><span class="line">       curl <span class="string">"$&#123;URL&#125;"</span> <span class="number">2</span>&gt;<span class="regexp">/dev/</span><span class="literal">null</span> | grep  <span class="string">"Active"</span> | awk <span class="string">'&#123;print $NF&#125;'</span></span><br><span class="line">&#125;</span><br><span class="line">reading() &#123;</span><br><span class="line">       curl <span class="string">"$&#123;URL&#125;"</span> <span class="number">2</span>&gt;<span class="regexp">/dev/</span><span class="literal">null</span> | grep <span class="string">"Reading"</span> | awk <span class="string">'&#123;print $2&#125;'</span></span><br><span class="line">&#125;</span><br><span class="line">writing() &#123;</span><br><span class="line">       curl <span class="string">"$&#123;URL&#125;"</span> <span class="number">2</span>&gt;<span class="regexp">/dev/</span><span class="literal">null</span> | grep <span class="string">"Writing"</span> | awk <span class="string">'&#123;print $4&#125;'</span></span><br><span class="line">&#125;</span><br><span class="line">waiting() &#123;</span><br><span class="line">       curl <span class="string">"$&#123;URL&#125;"</span> <span class="number">2</span>&gt;<span class="regexp">/dev/</span><span class="literal">null</span> | grep <span class="string">"Waiting"</span> | awk <span class="string">'&#123;print $NF&#125;'</span></span><br><span class="line">&#125;</span><br><span class="line">accepts() &#123;</span><br><span class="line">       curl <span class="string">"$&#123;URL&#125;"</span> <span class="number">2</span>&gt;<span class="regexp">/dev/</span><span class="literal">null</span> | awk NR==<span class="number">3</span> | awk <span class="string">'&#123;print $1&#125;'</span></span><br><span class="line">&#125;</span><br><span class="line">handled() &#123;</span><br><span class="line">       curl <span class="string">"$&#123;URL&#125;"</span> <span class="number">2</span>&gt;<span class="regexp">/dev/</span><span class="literal">null</span> | awk NR==<span class="number">3</span> | awk <span class="string">'&#123;print $2&#125;'</span></span><br><span class="line">&#125;</span><br><span class="line">requests() &#123;</span><br><span class="line">       curl <span class="string">"$&#123;URL&#125;"</span> <span class="number">2</span>&gt;<span class="regexp">/dev/</span><span class="literal">null</span> | awk NR==<span class="number">3</span> | awk <span class="string">'&#123;print $NF&#125;'</span></span><br><span class="line">&#125;</span><br><span class="line">ping() &#123;</span><br><span class="line">       ps -ef | grep nginx | grep -v grep -c</span><br><span class="line">&#125;</span><br><span class="line">$<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>然后再去<code>zabbix_agentd.conf</code>里添加一句话:<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UserParameter=nginx.status[*],/usr/local/zabbix/script/nginx_status.sh $<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>然后<code>service zabbix-agent restart</code>，自定义项就搞定了。</p><p>如果要导入模板，<a href="https://gitee.com/careyjike_173/zabbix" target="_blank" rel="noopener">https://gitee.com/careyjike_173/zabbix</a> 这个朋友的模板已经非常全面了，根据实际情况修改之后再导入他的xml就好，感谢前人付出！</p><p><img src="/images/埃里克森落叶球.gif" alt="paradin" title="埃尔克森远射破蓝军"></p>]]></content>
    
    <summary type="html">
    
      这一周又要把zabbix重新搭建并且搞起来了！
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
      <category term="zabbix" scheme="http://yoursite.com/tags/zabbix/"/>
    
  </entry>
  
  <entry>
    <title>金山云api调用的两个例子</title>
    <link href="http://yoursite.com/2018/03/29/%E9%87%91%E5%B1%B1%E4%BA%91api%E8%B0%83%E7%94%A8%E7%9A%84%E4%B8%A4%E4%B8%AA%E4%BE%8B%E5%AD%90/"/>
    <id>http://yoursite.com/2018/03/29/金山云api调用的两个例子/</id>
    <published>2018-03-29T14:55:09.000Z</published>
    <updated>2018-03-29T15:26:45.306Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>今天另外一个运维要看一下金山云API返回的格式，于是就临时写了两个demo，也顺便记录下来，说不定以后开发脚本的时候可能用的着。</p><h2><span id="查询数据库的脚本">查询数据库的脚本</span></h2><p>需要先获取<code>https://github.com/kscdb/krds_openapi_sdk.git</code>，然后执行<code>python setup.py install</code>安装所用的金山库。</p><p>这个脚本是查询某个数据库的具体情况：<br><img src="/images/ksapi4.png" alt="paradin"></p><p>脚本如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line"># -*- encoding:utf-8 -*-</span><br><span class="line"><span class="keyword">from</span> kscore.session <span class="keyword">import</span> get_session</span><br><span class="line"><span class="keyword">from</span> krds_client <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">#密钥</span><br><span class="line">ACCESS_KEY_ID = <span class="string">"这里填写ak"</span></span><br><span class="line">SECRET_ACCESS_KEY = <span class="string">"这里填写sk"</span></span><br><span class="line"></span><br><span class="line">#连接</span><br><span class="line">s = get_session()</span><br><span class="line">krds_client = KRDSClient(ACCESS_KEY_ID, SECRET_ACCESS_KEY, <span class="string">'地域名'</span>)</span><br><span class="line">r = krds_client.DescribeDBInstances(DBInstanceIdentifier='5c664b16-fbfe-4373-8a00-67c9476e7386',DBInstanceType='HA')#DBInstanceIdentifier后面是实例ID</span><br><span class="line">print r</span><br></pre></td></tr></table></figure></p><p>执行脚本之后，可以看到返回的结果包括数据库里很多的资料，如图：<br><img src="/images/ksapi1.png" alt="paradin" title="执行效果"></p><p>如果不加参数的话，就是返回账号内所有的数据库情况。</p><h2><span id="查询服务器的脚本">查询服务器的脚本</span></h2><p>需要先获取<code>https://github.com/KscSDK/ksc-sdk-python.git</code>，然后执行<code>python setup.py install</code>安装所用的金山库。</p><p>这个脚本是查询下面这个服务器的情况：<br><img src="/images/ksapi3.png" alt="paradin"></p><p>脚本如下：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line"># -*- encoding:utf-8 -*-</span><br><span class="line"><span class="keyword">from</span> kscore.session <span class="keyword">import</span> get_session</span><br><span class="line"></span><br><span class="line">#密钥</span><br><span class="line">ACCESS_KEY_ID = <span class="string">"这里填写ak"</span></span><br><span class="line">SECRET_ACCESS_KEY = <span class="string">"这里填写sk"</span></span><br><span class="line"></span><br><span class="line">#连接</span><br><span class="line">s = get_session()</span><br><span class="line">client = s.create_client(<span class="string">"kec"</span>, <span class="string">"地域名"</span>, use_ssl=True,ks_access_key_id=ACCESS_KEY_ID, ks_secret_access_key=SECRET_ACCESS_KEY)</span><br><span class="line">print client.describe_instances(Search=['js-online-hlsproxy-20'])#Search后面接实例名</span><br></pre></td></tr></table></figure></p><p>执行脚本之后，可以看到返回的结果包括数据库里很多的资料，如图：<br><img src="/images/ksapi2.png" alt="paradin" title="执行效果"></p><p>如果不加参数的话，就是返回账号内所有的服务器情况。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://github.com/KscSDK/ksc-sdk-python" target="_blank" rel="noopener">https://github.com/KscSDK/ksc-sdk-python</a><br><a href="https://github.com/kscdb/krds_openapi_sdk" target="_blank" rel="noopener">https://github.com/kscdb/krds_openapi_sdk</a></p>]]></content>
    
    <summary type="html">
    
      留下两个例子，日后说不定用得着
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="金山云" scheme="http://yoursite.com/tags/%E9%87%91%E5%B1%B1%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>使用pandas来做html表格</title>
    <link href="http://yoursite.com/2018/03/27/%E4%BD%BF%E7%94%A8pandas%E6%9D%A5%E5%81%9Ahtml%E8%A1%A8%E6%A0%BC/"/>
    <id>http://yoursite.com/2018/03/27/使用pandas来做html表格/</id>
    <published>2018-03-27T15:31:28.000Z</published>
    <updated>2018-03-27T15:56:17.698Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="前言">前言</span></h2><p>最近电子商城慢sql问题引了小BOSS的重视，于是就打算给开发们搞一个表格，在表格里可以看到前一天阿里云数据库的慢sql。这一次我不打算用html邮件了，因为慢sql数量不固定，今天可能三个，明天可能五个，后天抽风可能就一百个。而html邮件的格式是要事先写死的，于是我就用pandas来做这个表格，直接生成一个html文件，通过访问浏览器去让开发看慢sql。</p><h2><span id="慢日志脚本">慢日志脚本</span></h2><p>我要承认，阿里云自带的api在线调试工具真是一个好东西，有了它，脚本demo可以直接生成，地址是：<a href="https://api.aliyun.com/?spm=a2c4g.750001.952925.6.1QrDYe" target="_blank" rel="noopener">https://api.aliyun.com/?spm=a2c4g.750001.952925.6.1QrDYe</a> ，于是乎，阿里云获取慢日志脚本<code>test.py</code>如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line">#coding=utf-8</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore <span class="keyword">import</span> client</span><br><span class="line"><span class="keyword">from</span> aliyunsdkrds.request.v20140815 <span class="keyword">import</span> DescribeSlowLogRecordsRequest</span><br><span class="line"></span><br><span class="line">clt = client.AcsClient(<span class="string">'这里是ak'</span>,<span class="string">'这里是sk'</span>,<span class="string">'这里是地域'</span>)</span><br><span class="line"></span><br><span class="line"># 设置参数</span><br><span class="line">request = DescribeSlowLogRecordsRequest.DescribeSlowLogRecordsRequest()</span><br><span class="line">request.set_accept_format(<span class="string">'json'</span>)</span><br><span class="line"></span><br><span class="line">request.add_query_param(<span class="string">'DBInstanceId'</span>, <span class="string">'RDS的ID号'</span>)</span><br><span class="line">request.add_query_param('StartTime', '2018-03-26T08:00Z')#3月26日早上8点开始</span><br><span class="line">request.add_query_param('EndTime', '2018-03-27T08:00Z')#3月27日早上8点结束</span><br><span class="line">request.add_query_param(<span class="string">'DBName'</span>, <span class="string">'对应的数据库名'</span>)</span><br><span class="line">request.add_query_param('PageSize', 100)#这个值只能是30/50/100</span><br><span class="line"></span><br><span class="line"># 发起请求</span><br><span class="line">response = clt.do_action_with_exception(request)</span><br><span class="line">print response</span><br><span class="line"></span><br><span class="line">#把json格式的返回值改成dict格式</span><br><span class="line">slow_log=json.loads(response)</span><br><span class="line">num = slow_log[<span class="string">'TotalRecordCount'</span>]</span><br><span class="line">Hostaddress = []</span><br><span class="line">LockTimes = []</span><br><span class="line">ParseRowCounts = []</span><br><span class="line">QueryTimes = []</span><br><span class="line">SQLText = []</span><br><span class="line"></span><br><span class="line">#将有用的值做成list</span><br><span class="line"><span class="keyword">if</span> num &lt; <span class="number">100</span>:</span><br><span class="line">       <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,num):</span><br><span class="line">               Hostaddress.append(slow_log[<span class="string">'Items'</span>][<span class="string">'SQLSlowRecord'</span>][i][<span class="string">'HostAddress'</span>])</span><br><span class="line">               LockTimes.append(slow_log[<span class="string">'Items'</span>][<span class="string">'SQLSlowRecord'</span>][i][<span class="string">'LockTimes'</span>])</span><br><span class="line">               ParseRowCounts.append(slow_log[<span class="string">'Items'</span>][<span class="string">'SQLSlowRecord'</span>][i][<span class="string">'ParseRowCounts'</span>])</span><br><span class="line">               QueryTimes.append(slow_log[<span class="string">'Items'</span>][<span class="string">'SQLSlowRecord'</span>][i][<span class="string">'QueryTimes'</span>])</span><br><span class="line">               SQLText.append(slow_log[<span class="string">'Items'</span>][<span class="string">'SQLSlowRecord'</span>][i][<span class="string">'SQLText'</span>])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">       <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">100</span>):</span><br><span class="line">               Hostaddress.append(slow_log[<span class="string">'Items'</span>][<span class="string">'SQLSlowRecord'</span>][i][<span class="string">'HostAddress'</span>])</span><br><span class="line">               LockTimes.append(slow_log[<span class="string">'Items'</span>][<span class="string">'SQLSlowRecord'</span>][i][<span class="string">'LockTimes'</span>])</span><br><span class="line">               ParseRowCounts.append(slow_log[<span class="string">'Items'</span>][<span class="string">'SQLSlowRecord'</span>][i][<span class="string">'ParseRowCounts'</span>])</span><br><span class="line">               QueryTimes.append(slow_log[<span class="string">'Items'</span>][<span class="string">'SQLSlowRecord'</span>][i][<span class="string">'QueryTimes'</span>])</span><br><span class="line">               SQLText.append(slow_log[<span class="string">'Items'</span>][<span class="string">'SQLSlowRecord'</span>][i][<span class="string">'SQLText'</span>])</span><br></pre></td></tr></table></figure></p><p>这个<code>response</code>的格式是一个<code>json</code>，在<code>www.json.cn</code>里查看是这个样子：<br><img src="/images/pandas1.png" alt="paradin"></p><p>可以看到返回值里面<code>TotalRecordCount</code>就是总返回值，如果这个值大于<code>PageSize</code>，那么就会有第二篇，需要手动翻篇。所以我这里直接最大值就是100，一篇100已经够开发看了…</p><h2><span id="脚本如下">脚本如下</span></h2><p>在上面的脚本里可以获取到所有慢sql的<code>json</code>格式，那么就可以再写一个脚本把<code>json</code>转化成<code>html</code>格式并且生成一个<code>html</code>文件，然后在nginx里直接把这个文件展示出来。既然用到了<code>pandas</code>库，那么就要先安装<code>pandas</code>,方法如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pip install --upgrade pip</span><br><span class="line">pip install pandas</span><br><span class="line">如果有“Please upgrade numpy to &gt;= <span class="number">1.9</span><span class="number">.0</span> to use <span class="keyword">this</span> pandas version”的反应，那么执行下一句</span><br><span class="line">pip install -U numpy</span><br></pre></td></tr></table></figure></p><p>生成html的整个脚本如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line">#coding=utf-8</span><br><span class="line">from test import Hostaddress,LockTimes,ParseRowCounts,QueryTimes,SQLText#从刚写的test.py里得到那些list变量</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">def convertToHtml(result,title):</span><br><span class="line">    #将数据转换为html的table</span><br><span class="line">    #result是list[list1,list2]这样的结构</span><br><span class="line">    #title是list结构；和result一一对应。titleList[0]对应resultList[0]这样的一条数据对应html表格中的一列</span><br><span class="line">    d = &#123;&#125;</span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> title:</span><br><span class="line">        d[t]=result[index]</span><br><span class="line">        index = index+<span class="number">1</span></span><br><span class="line">    pd.set_option('max_colwidth',200)#默认的行长度是50，这里我调成了200</span><br><span class="line">    df = pd.DataFrame(d)</span><br><span class="line">    df = df[title]</span><br><span class="line">    h = df.to_html(index=False)</span><br><span class="line">    <span class="keyword">return</span> h</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    result = [Hostaddress,LockTimes,ParseRowCounts,QueryTimes,SQLText]</span><br><span class="line">    title = [u<span class="string">'HostAddress'</span>,u<span class="string">'LockTimes'</span>,u<span class="string">'ParseRowCounts'</span>,u<span class="string">'QueryTimes'</span>,u<span class="string">'SQLText'</span>]</span><br><span class="line">    #生成一个叫biaoge.html</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'/nginxhtml路径/biaoge.html'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(convertToHtml(result,title))</span><br><span class="line">        print <span class="string">"html文件已经生成！"</span></span><br></pre></td></tr></table></figure></p><h2><span id="执行效果">执行效果</span></h2><p>将这个<code>biaoge.html</code>直接生成到nginx的html文件夹里，在浏览器里打开这个html就看到效果了，如图：<br><img src="/images/pandas2.png" alt="paradin"></p>]]></content>
    
    <summary type="html">
    
      最近各种画图，都快吐了...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="pandas" scheme="http://yoursite.com/tags/pandas/"/>
    
      <category term="大数据分析" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>记录一次nginx出现了502的问题</title>
    <link href="http://yoursite.com/2018/03/26/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1nginx%E5%87%BA%E7%8E%B0%E4%BA%86502%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/03/26/记录一次nginx出现了502的问题/</id>
    <published>2018-03-26T11:01:24.000Z</published>
    <updated>2018-03-26T11:12:29.110Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="背景交待">背景交待</span></h2><p>市场运营在手机APP端推送了一个“家装节，部分商品优惠打折”消息，用户可以通过点击这个消息，在APP进入到商城界面，如果是已经登录的用户将通过免登陆直接跳转，如果是没有登录的用户会登陆到登陆界面。但是刚推送就发现，通过这个推送点击，没有正常登陆到商城界面，而是返回了502。</p><p>nginx 502的错误，一般来说就是<code>php-fpm</code>的问题，我登陆到电商服务器发现，<code>php-fpm</code>运行正常而且<code>php-fpm</code>的进程数也很正常。但是查看到mysql，发现mysql的CPU飙升，如图：<br><img src="/images/nginx5021.png" alt="paradin"></p><p>于是登陆到数据库里，使用<code>show processlist</code>一看，数据库里有大量的语句处于<code>sending data</code>状态，而且执行时间令人发指（<code>command</code>项处于<code>Sleep</code>状态的进程表示其正在等待接受查询，因此它并没有消耗任何资源，是无害的）：<br><img src="/images/nginx5022.png" alt="paradin"></p><p>先赶快通知运营先把推送的消息界面停用掉，不要让更多的用户登陆失败。然后写了一个脚本批量的kill掉这些进程，看看能不能让数据库恢复正常，过程如下。</p><p>首先先得到<code>show processlist</code>展现的所有的情况:<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p密码 -h数据库地址 -e <span class="string">"show processlist"</span> | grep -i <span class="string">'Locked'</span> &gt; locked_log.txt</span><br></pre></td></tr></table></figure></p><p>然后获得前面的进程号，并且加上kill的指令:<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#/bin/bash</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="string">`cat locked_log.txt | awk '&#123;print $1&#125;'`</span></span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">   echo <span class="string">"kill $line;"</span> &gt;&gt; kill_thread_id.sql</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><p>在登陆到数据库，然后执行上面生成的<code>kill_thread_id.sql</code>：:<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;source kill_thread_id.sql</span><br></pre></td></tr></table></figure></p><p>但是发现，kill掉一批之后，又有了新的慢sql出现，CPU依旧高居不下，于是只能跟产品经理说明情况，在征得了产品经理无奈的同意之后，重启了数据库，幸好时间没有很长，就耽误二三分钟而已。重启了之后，CPU就降下去了。赶快叫开发童鞋在线补充一个索引给用户登录的表来解决这个慢sql问题，没有了慢sql就没有了502。</p><h2><span id="补充nginx499">补充nginx499</span></h2><p>nginx如果爆错499的话，代表<code>客户端主动关闭连接</code>，原因就是后端脚本执行的时间太长了or数据库有慢mysql，调用方超出了<code>timeout</code>的时间，关闭了连接。</p><p>这个时候需要更改一下<code>nginx.conf</code>:<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">proxy_read_timeout <span class="number">10</span>s;</span><br><span class="line">proxy_send_timeout <span class="number">10</span>s;</span><br></pre></td></tr></table></figure></p><p>把上面两个值适度调大然后重启nginx即可。或者就是<code>proxy_ignore_client_abort  on;</code>，这话就是让代理服务端不要主动关闭客户端的连接。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://blog.csdn.net/zhuxineli/article/details/14455029" target="_blank" rel="noopener">https://blog.csdn.net/zhuxineli/article/details/14455029</a><br><a href="https://segmentfault.com/a/1190000012326158" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012326158</a></p>]]></content>
    
    <summary type="html">
    
      据说php可以改变数据表结构？？？
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
  </entry>
  
</feed>
