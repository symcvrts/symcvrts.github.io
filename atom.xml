<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chris Chan&#39;s BLOG</title>
  
  <subtitle>那些在阳光下挥洒青春的日子啊！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-19T03:35:49.323Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Chris Chan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RabbitMQ的安装、配置与启动</title>
    <link href="http://yoursite.com/2018/03/19/RabbitMQ%E7%9A%84%E5%AE%89%E8%A3%85%E3%80%81%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%90%AF%E5%8A%A8/"/>
    <id>http://yoursite.com/2018/03/19/RabbitMQ的安装、配置与启动/</id>
    <published>2018-03-19T01:59:05.000Z</published>
    <updated>2018-03-19T03:35:49.323Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="前言">前言</span></h2><p>环境介绍：<code>Centos 7</code> + <code>RabbitMQ：3.6.12</code> + <code>Erlang：20.0</code></p><h2><span id="安装erlang">安装erlang</span></h2><p>由于RabbitMQ使用erlang语言编写的，所以要先安装erlang语言环境。但是yum源里的erlang版本太老了，于是这里选择手动安装，使用Erlang官方推荐的<code>Erlang Solutions</code>安装方法如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum install gcc gcc-c++ glibc-devel make ncurses-devel openssl-devel autoconf java-1.8.0-openjdk-devel git wget wxBase.x86_64#先把其他模块准备好</span><br><span class="line">wget https:<span class="comment">//packages.erlang-solutions.com/erlang-solutions-1.0-1.noarch.rpm</span></span><br><span class="line">rpm -Uvh erlang-solutions<span class="number">-1.0</span><span class="number">-1.</span>noarch.rpm</span><br><span class="line">rpm --<span class="keyword">import</span> https:<span class="comment">//packages.erlang-solutions.com/rpm/erlang_solutions.asc</span></span><br></pre></td></tr></table></figure></p><p>此时，查看<code>/etc/yum.repos.d/erlang_solutions.repo</code>，应该是这个样子：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[erlang-solutions]</span><br><span class="line">name=CentOS $releasever - $basearch - Erlang Solutions</span><br><span class="line">baseurl=https:<span class="comment">//packages.erlang-solutions.com/rpm/centos/$releasever/$basearch</span></span><br><span class="line">gpgcheck=<span class="number">1</span></span><br><span class="line">gpgkey=https:<span class="comment">//packages.erlang-solutions.com/rpm/erlang_solutions.asc</span></span><br><span class="line">enabled=<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>这个时候可以yum安装了：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y esl-erlang</span><br></pre></td></tr></table></figure></p><p>此时得到的erlang就是20.0版本的了，如图：<br><img src="/images/rabbitmq1.png" alt="paradin"></p><p>如果不想使用这个办法，可以使用源码安装的方式，<a href="https://packages.erlang-solutions.com/erlang/" target="_blank" rel="noopener">https://packages.erlang-solutions.com/erlang/</a> 这里面有Erlang官方的下载包，拆包解压缩然后<code>make &amp;&amp; make install</code>即可。</p><h2><span id="安装rabbitmq">安装RabbitMQ</span></h2><p>安装RabbitMQ跟其他普通软件差不多，先去官网下载目前较稳定的rpm包，然后安装，步骤如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https:<span class="comment">//dl.bintray.com/rabbitmq/all/rabbitmq-server/3.7.4/rabbitmq-server-3.7.4-1.el7.noarch.rpm</span></span><br><span class="line">yum install -y rabbitmq-server<span class="number">-3.7</span><span class="number">.4</span><span class="number">-1.</span>el7.noarch.rpm</span><br></pre></td></tr></table></figure></p><p>如果出现了<code>Transaction Check Error</code>的错误：<br><img src="/images/rabbitmq2.png" alt="paradin"></p><p>可见是要安装的包与已有的包相冲突，此时需要<code>yum list|grep erlang</code>，如图：</p><p><img src="/images/rabbitmq3.png" alt="paradin"><br>再<code>yum remove esl-erlang.x86_64</code>，然后重新执行yum install那一步即可。</p><p>如果出现<code>Requires: socat</code>的错误，如图：<br><img src="/images/rabbitmq6.png" alt="paradin"></p><p>此时需要执行如下命令即可：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y install epel-release</span><br><span class="line">yum -y install socat</span><br></pre></td></tr></table></figure></p><h2><span id="配置rabbitmq">配置RabbitMQ</span></h2><p>RabbitMQ安装完毕，先<code>chkconfig rabbitmq-server on</code>设置开机启动。然后，配置一下用户名。我这个机器的用户名不规范，需要把hostname里的中文去掉，比如改成：<code>3-dvl-hlsproxy-001</code>，那么就要在/etc/hosts里添加一句：</p><pre><code>内网IP地址 3-dvl-hlsproxy-001</code></pre><p>然后执行<code>rabbitmq-plugins enable rabbitmq_management</code>来安装WEB图形界面，然后拷贝<code>rabbitmq.config.example</code>到<code>/etc/rabbitmq/</code>里，并且改名叫<code>rabbitmq.config</code>，命令如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/share/doc/rabbitmq-server<span class="number">-3.7</span><span class="number">.4</span>/rabbitmq.config.example /etc/rabbitmq/</span><br><span class="line">cd /etc/rabbitmq/</span><br><span class="line">mv rabbitmq.config.example rabbitmq.config</span><br></pre></td></tr></table></figure></p><p>编辑<code>rabbitmq.config</code>这个文件，把<code>%%{loopback_users, []}.</code>改成<code>{loopback_users, []}</code>，保存之后，执行<code>service rabbitmq-server restart</code>来启动RabbitMQ。</p><p>如果启动之后，执行<code>rabbitmqctl status</code>不断的刷<code>Error when reading /var/lib/rabbitmq/.erlang.cookie: eacces</code>的错误的话，执行<code>chown rabbitmq:rabbitmq /var/lib/rabbitmq/.erlang.cookie</code>。</p><p>在浏览器里登录<code>外网IP:15672</code>就会看到RabbitMQ的WEB配置界面了，<br><img src="/images/rabbitmq4.png" alt="paradin"></p><p>账号和密码都是guest，输入之后就会看到如下的界面，可以在界面里看到<code>3-dvl-hlsproxy-001</code>的情况了，如图：<br><img src="/images/rabbitmq5.png" alt="paradin"></p><p>RabbitMQ 3.0以后版本的WEB端口是<code>15672</code>,服务的端口是<code>5672</code>,这俩都可以在配置文件里面更改。至此RabbitMQ的安装与配置结束了，但是这个仅仅是最简单的配置，RabbitMQ自身有一套很详细的用户管理规则以及它支持Python等很多语言的管理，这些内容以后再详细说明。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://packages.erlang-solutions.com/erlang/" target="_blank" rel="noopener">https://packages.erlang-solutions.com/erlang/</a><br><a href="https://laucyun.com/9849587ce75f31d534d52f906c94368f.html" target="_blank" rel="noopener">https://laucyun.com/9849587ce75f31d534d52f906c94368f.html</a><br><a href="https://www.rabbitmq.com/access-control.html" target="_blank" rel="noopener">https://www.rabbitmq.com/access-control.html</a></p><p><img src="/images/salahe.gif" alt="paradin" title="大四喜的萨拉赫"></p>]]></content>
    
    <summary type="html">
    
      这个MQ是给activemq当备胎的
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="消息队列" scheme="http://yoursite.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="RabbitMQ" scheme="http://yoursite.com/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>使用nginx开启http2协议</title>
    <link href="http://yoursite.com/2018/03/16/%E4%BD%BF%E7%94%A8nginx%E5%BC%80%E5%90%AFhttp2%E5%8D%8F%E8%AE%AE/"/>
    <id>http://yoursite.com/2018/03/16/使用nginx开启http2协议/</id>
    <published>2018-03-16T14:34:44.000Z</published>
    <updated>2018-03-16T16:24:29.939Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="部署过程">部署过程</span></h2><p><code>HTTP/2</code>是建立在TLS的基础上的，那么先要查看nginx的版本和openssl的版本，如果<code>nginx</code>版本在<code>1.10.0</code>以上且需要<code>openssl</code>版本在<code>1.0.2</code>以上那么就可以进行下一步了：<br><img src="/images/http2-10.png" alt="paradin"></p><p>如果版本并不符合要求，可以按照<a href="https://rorschachchan.github.io/2018/01/03/Nginx动态编译新的模块/" target="_blank" rel="noopener">https://rorschachchan.github.io/2018/01/03/Nginx动态编译新的模块/</a> 里的方法升级对应的模块版本。</p><p>先编辑https（443端口）对应的<code>conf</code>文件：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 443 ssl http2;    #这里多加一句http2</span><br><span class="line">        server_name  cuntao.lechange.com *.lechange.com;    #这里填写实际的域名，我这里以cuntao.lechange.com为例</span><br><span class="line"></span><br><span class="line">        ssl_certificate /实际路径/server-com.crt;        </span><br><span class="line">        ssl_certificate_key /实际路径/server-com.key;</span><br><span class="line"></span><br><span class="line">        ssl_session_timeout  30m;        #客户端会话缓存时间</span><br><span class="line">        ssl_protocols  TLSv1 TLSv1.1 TLSv1.2;    #允许的协议</span><br><span class="line">        ssl_ciphers  EECDH+CHACHA20:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5;    #加密算法(CloudFlare 推荐的加密套件组)</span><br><span class="line">        ssl_prefer_server_ciphers   on;        #优化 SSL 加密套件</span><br><span class="line">        ssl_session_cache builtin:1000 shared:SSL:10m;        #SSL会话缓存类型和大小</span><br><span class="line">        ssl_buffer_size 1400;        #每个MTU大小1400b</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page  <span class="number">404</span>              /<span class="number">404.</span>html;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>保存之后再编辑http（80端口）对应的<code>conf</code>文件：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen <span class="number">80</span> <span class="keyword">default</span>;</span><br><span class="line">    add_header Strict-Transport-Security max-age=<span class="number">15768000</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">301</span> https:<span class="comment">//$host$request_uri;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后使用<code>nginx -t</code>检查一下是否文件有错误，如果是OK的话，那么就<code>nginx -s reload</code>平滑重启一下nginx即可。</p><p>验证<code>HTTP/2</code>协议是否开启很简单，有两个方法：<br>1）登陆<code>https://tools.keycdn.com/http2-test</code>，将你的域名填写进去，查看一下配置成功：<br><img src="/images/http2-11.png" alt="paradin"></p><p>2)在Chrome浏览器上可以通过安装<code>HTTP/2 and SPDY indicator</code>插件来检验，网址是<a href="https://chrome.google.com/webstore/detail/http2-and-spdy-indicator/mpbpobfflnpcgagjijhmgnchggcjblin" target="_blank" rel="noopener">https://chrome.google.com/webstore/detail/http2-and-spdy-indicator/mpbpobfflnpcgagjijhmgnchggcjblin</a>  ，如果地址栏出现蓝色的闪电就是该网站开启了<code>HTTP/2</code>协议，灰色的话就是<code>HTTP/2</code>协议没开启。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://www.nginx.com/blog/nginx-1-9-5/" target="_blank" rel="noopener">https://www.nginx.com/blog/nginx-1-9-5/</a><br><a href="https://blog.fazero.me/2017/01/06/upgrate-nginx-and-use-http2/" target="_blank" rel="noopener">https://blog.fazero.me/2017/01/06/upgrate-nginx-and-use-http2/</a><br><a href="https://iyaozhen.com/nginx-http2-conf.html" target="_blank" rel="noopener">https://iyaozhen.com/nginx-http2-conf.html</a></p>]]></content>
    
    <summary type="html">
    
      普通的HTTPS网站浏览会比HTTP网站稍微慢一些，因为需要处理加密任务，而配置了HTTP/2的HTTPS，在低延时的情况下速度会比HTTP更快更稳定！
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
      <category term="http协议" scheme="http://yoursite.com/tags/http%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>关于HTTP 2.0应该知道的事</title>
    <link href="http://yoursite.com/2018/03/16/%E5%85%B3%E4%BA%8EHTTP-2%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8B/"/>
    <id>http://yoursite.com/2018/03/16/关于HTTP-2应该知道的事/</id>
    <published>2018-03-16T13:44:45.000Z</published>
    <updated>2018-03-16T16:28:45.398Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="http-20的优势">HTTP 2.0的优势</span></h2><p>相比<code>HTTP/1.x</code>，<code>HTTP/2</code>在底层传输做了很大的改动和优化：<br>1.每个服务器只用一个连接：<code>HTTP/2</code>对每个服务器只使用一个连接，而不是每个文件一个连接。这样，就省掉了多次建立连接的时间，这个时间对TLS尤其明显，因为TLS连接费时间;<br>2.加速TLS交付：<code>HTTP/2</code>只需一次耗时的TLS握手，并且通过一个连接上的多路利用实现最佳性能。<code>HTTP/2</code>还会压缩首部数据，省掉<code>HTTP/1.x</code>时代所需的一些优化工作，比如拼接文件，从而提高缓存利用率;<br>3.简化Web应用：使用<code>HTTP/2</code>可以让Web开发者省很多事，因为不用再做那些针对<code>HTTP/1.x</code>的优化工作了;<br>4.适合内容混杂的页面：<code>HTTP/2</code>特别适合混合了HTML、CSS、JavaScript、图片和有限多媒体的传统页面。浏览器可以优先安排那些重要的文件请求，让页面的关键部分先出现、快出现，而且根本不会发生“浏览器明明在等关键的CSS和JS，而服务器还在发送黄图”的尴尬局面;<br>5.更安全：通过减少TLS的性能损失，可以让更多应用使用TLS，从而让用户信息更安全。</p><h2><span id="http-20性能增强之二进制分帧">HTTP 2.0性能增强之二进制分帧</span></h2><p>HTTP的定义大家都知道，叫<code>超文本协议</code>，也就是说<code>http1.x</code>的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多。但是在<code>HTTP/2</code>里这里做了比较重大的改动—<code>二进制分帧</code>，<code>HTTP/2</code>在应用层(HTTP)和传输层(TCP or UDP)之间增加一个二进制分帧层。在这个新增的二进制分帧层里<code>HTTP/2</code>会将所有传输的信息分割为更小的消息和帧,并对它们采用二进制格式的编码 ，其中<code>HTTP1.x</code>的首部信息会被封装到<code>Headers</code>帧，而我们的<code>request body</code>则封装到<code>Data</code>帧里面。二进制与之前的文本不同，二进制只认0和1的组合。基于这种考虑<code>http2.0</code>的协议解析决定采用二进制格式，实现方便且健壮。<br><img src="/images/http2-1.png" alt="paradin" title="对比一下http1.x和http2的报文格式"></p><p><code>HTTP/2</code>的格式定义十分高效且精简。<code>length</code>定义了整个<code>frame</code>的大小，<code>type</code>定义<code>frame</code>的类型（一共10种），<code>flags</code>用<code>bit</code>位定义一些重要的参数，<code>stream id</code>用作流控制，<code>payload</code>就是<code>request</code>的正文，如下图：<br><img src="/images/http2-2.png" alt="paradin" title="二进制层是夹在回话层和应用层之间的"></p><h2><span id="http-20性能增强之首部压缩">HTTP 2.0性能增强之首部压缩</span></h2><p>虽然<code>HTTP/2</code>引入了二进制分帧的概念，但是试想如果所有的二进制帧都会带上<code>Headers</code>帧，这是多大的数据冗余传送啊。于是<code>HTTP/2</code>针对这个需求又搞出来一个东东—“首部表”。</p><p>“首部表”来跟踪和存储之前发送的<code>键-值</code>对，对于相同的数据，不再通过每次请求和响应发送；通信期间几乎不会改变的通用<code>键-值</code>对(用户代理、可接受的媒体类型等等)只需发送一次。事实上,如果请求中不包含首部(例如对同一资源的轮询请求)，那么首部开销就是零字节。此时所有首部都自动使用之前请求发送的首部。如果首部发生变化了，那么只需要发送变化了数据在<code>Headers</code>帧里面，新增或修改的首部帧会被追加到“首部表”。首部表在<code>HTTP/2</code>的连接存续期内始终存在,由客户端和服务器共同渐进地更新。</p><h2><span id="http-20性能增强之tcp请求集中">HTTP 2.0性能增强之TCP请求集中</span></h2><p>TCP的优势是很直白的：面向连接、提供可靠的数据传输服务、流量控制。那么有效地使用TCP连接的方法就是<strong>长时间连接传输大块数据</strong>。于是<code>HTTP/2</code>就尽大化的把这一特点发扬：所有<code>HTTP/2</code>通信都是在一个TCP连接上完成。前面说过，HTTP/2把HTTP协议通信的基本单位缩小为一个一个的帧，这些帧对应着逻辑流中的消息，并行地在同一个TCP连接上双向交换消息(注意这个“双向交换消息”)。举个例子，请求一个页面<code>https://www.google.com</code>，页面上所有的资源请求都是客户端与服务器上的一条TCP上请求和响应的！</p><p>这样“单链接多资源”的方式，使到至上而下的层面都得到了好处：<br>    1.可以减少服务链接压力,内存占用少了,连接吞吐量大了；<br>    2.由于TCP连接减少而使网络拥塞状况得以改观;<br>    3.慢启动时间减少,拥塞和丢包恢复速度更快。</p><p>综上所述，“资源合并减少请求”对于<code>HTTP/2</code>是无用的优化手段。</p><p>上面的文字说了要注意“双向交换消息”，那么啥是“双向交换消息”？</p><p>就是把HTTP消息分解为独立的帧,交错发送,然后在另一端重新组装。专业一点说就是“一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的id将request再归属到各自不同的服务端请求里面”。这是<code>HTTP/2</code>重要的一项增强。事实上,这个机制会在整个Web技术栈中引发一系列连锁反应, 从而带来巨大的性能提升,因为：</p><pre><code>可以并行交错地发送请求,请求之间互不影响;可以并行交错地发送响应,响应之间互不干扰;只使用一个连接即可并行发送多个请求和响应;消除不必要的延迟,从而减少页面加载的时间;</code></pre><p><img src="/images/http2-3.png" alt="paradin" title="“域名分区”这种优化手段对于HTTP2.0是无用的，因为资源都是并行交错发送，且没有限制，不需要额外的多域名并行下载"></p><h2><span id="keep-alive与http2集中tcp的区别">Keep Alive与HTTP/2集中TCP的区别</span></h2><p><code>HTTP1.1</code>的<code>keep-alive</code>是为了尽可能使用持久链接，以消除TCP握手和慢启动。但是<code>keep-alive</code>使用多了同样会给服务端带来大量的性能压力，并且对于单个文件被不断请求的服务(例如图片存放网站)，<code>keep-alive</code>可能会极大的影响性能，因为它在文件被请求之后还保持了不必要的连接很长时间。</p><p>举个例子：下载<code>a.js</code>创建一个TCP链接，就会需要TCP握手和慢启动而产生了约300ms下载延迟。当<code>a.js</code>下载完成后这时候<code>b.js</code>也要下载，如果<code>a.js</code>创建TCP链接是<code>keep-alive</code>的，<code>b.js</code>就可以复用其TCP而不需要重新TCP握手和慢启动（没有了那300ms）。</p><p>而<code>HTTP/2</code>是使用一个TCP链接的，其慢启动和握手只在第一次链接的时候产生一次，其后面链接都是持久化的。并且一个TCP下载多个资源，可以将TCP吞吐量最大化来提升性能，这方面可以参考一下TCP的拥塞预防及控制。<br><img src="/images/http2-4.png" alt="paradin"></p><p><img src="/images/http2-5.png" alt="paradin"></p><h2><span id="nginx上如何配制http2">NGINX上如何配制HTTP/2</span></h2><p>上面说了这么多HTTP/2这个好那个好，是未来的趋势blablabla，但是要实现<code>HTTP/2</code>，还是需要“客户端和服务器都开启了HTTP/2”这一个首要条件。不过现在客户端（浏览器）大多数都已经支持<code>HTTP/2</code>，那么主要就是在服务器端如何开启<code>HTTP/2</code>，nginx的配置方法请见：<a href="https://rorschachchan.github.io/2018/03/16/使用nginx开启http2协议/" target="_blank" rel="noopener">https://rorschachchan.github.io/2018/03/16/使用nginx开启http2协议/</a> 。</p><p>按照这样的操作下来，服务器就开了<code>HTTP/2</code>协议，那些支持<code>HTTP/2</code>的浏览器在请求页面的时候就会走<code>HTTP/2</code>模式，而不支持HTTP/2的浏览器会议就按照<code>HTTP/1.X</code>的方式发送请求，如图：<br><img src="/images/http2-7.png" alt="paradin"></p><p><img src="/images/http2-8.png" alt="paradin" title="如果nginx是一个代理服务器的话，就是这图的传输方式"></p><p>支持<code>HTTP/2</code>的Web Server基本都支持<code>HTTP/1.1</code>。这样，即使浏览器不支持<code>HTTP/2</code>，双方也可以协商出可用的<code>HTTP</code>版本，没有兼容性问题。<br><img src="/images/http2-6.png" alt="paradin" title="使用HTTP/2其实还是服务器说的算"></p><h2><span id="参考资料">参考资料</span></h2><p><a href="http://www.alloyteam.com/2015/03/http2-0-di-qi-miao-ri-chang/comment-page-1/#comments" target="_blank" rel="noopener">http://www.alloyteam.com/2015/03/http2-0-di-qi-miao-ri-chang/comment-page-1/#comments</a><br><a href="https://segmentfault.com/a/1190000007637735" target="_blank" rel="noopener">https://segmentfault.com/a/1190000007637735</a><br><a href="https://github.com/creeperyang/blog/issues/23" target="_blank" rel="noopener">https://github.com/creeperyang/blog/issues/23</a><br><a href="https://www.nginx.com/blog/nginx-1-9-5/" target="_blank" rel="noopener">https://www.nginx.com/blog/nginx-1-9-5/</a><br><a href="https://ye11ow.gitbooks.io/http2-explained/content/part6.html" target="_blank" rel="noopener">https://ye11ow.gitbooks.io/http2-explained/content/part6.html</a></p>]]></content>
    
    <summary type="html">
    
      如果说有一个黑科技不用开发改代码、不用额外买服务，就能直接提升网络开启速度，这是什么呢？
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="大牛之路" scheme="http://yoursite.com/tags/%E5%A4%A7%E7%89%9B%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="http协议" scheme="http://yoursite.com/tags/http%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>centos 7里安装zsh来提升shell的高逼格</title>
    <link href="http://yoursite.com/2018/03/15/centos-7%E9%87%8C%E5%AE%89%E8%A3%85zsh%E6%9D%A5%E6%8F%90%E5%8D%87shell%E7%9A%84%E9%AB%98%E9%80%BC%E6%A0%BC/"/>
    <id>http://yoursite.com/2018/03/15/centos-7里安装zsh来提升shell的高逼格/</id>
    <published>2018-03-15T13:52:13.000Z</published>
    <updated>2018-03-16T16:14:04.871Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="zsh本体的安装">zsh本体的安装</span></h2><p>先用<code>chsh -l</code>查看当前的bash情况，如下：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   [root@zabbix ~]# chsh -l</span><br><span class="line">/bin/sh</span><br><span class="line">/bin/bash</span><br><span class="line">/sbin/nologin</span><br><span class="line">/bin/dash</span><br><span class="line">/bin/tcsh</span><br><span class="line">/bin/csh</span><br><span class="line">/usr/bin/tmux</span><br><span class="line">[root@zabbix ~]#</span><br></pre></td></tr></table></figure></p><p>如果是centos的话，使用<code>yum install -y zsh</code>来安装zsh，装完了zsh然后就是装<code>oh my zsh</code>，使用<code>wget</code>方法安装：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https:<span class="comment">//github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh</span></span><br></pre></td></tr></table></figure></p><p>再使用<code>which zsh</code>查看安装的zsh在<code>/usr/bin/zsh</code>，这个时候使用<code>chsh -s /usr/bin/zsh</code>，出现了<code>Shell changed.</code>这样就切换到了zsh界面，需要logout退出连接重进。</p><p>重新连接就会发现bash界面就变了，原本是路径的地方变成了一个小图标。界面主题是可以变化的，比如我个人比较喜欢<code>af-magic</code>这个模板，于是乎就把/root/.zshrc里的<code>ZSH_THEME=&quot;robbyrussell&quot;</code>改成<code>ZSH_THEME=&quot;af-magic&quot;</code>，保存文件，再一次退出连接重新进入就能看见模板变化了。</p><p>如果在使用vim的时候发现了tab键的补全爆错_arguments:451: _vim_files: function definition file not found，如下图：<br><img src="/images/zsh2.png" alt="paradin"></p><p>这个时候需要把/root/.zcompdump改一个名字，比如叫.zcompdump-bak，然后重新ssh连接即可。</p><h2><span id="autojump插件安装">autojump插件安装</span></h2><p>autojump这个插件安装之后，zsh会自动记录你访问过的目录，通过<code>j + 目录名</code>可以直接进行目录跳转，而且目录名支持模糊匹配和自动补全，例如你访问过<code>hadoop-1.0.0</code>目录，输入<code>j hado</code>即可正确跳转。<code>j –s</code>可以看你的历史路径库，安装方法如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git:<span class="comment">//github.com/joelthelion/autojump.git</span></span><br></pre></td></tr></table></figure></p><p>然后在autojump目录里执行<code>./install.sh</code>，此时屏幕会出现如下的显示：<br><img src="/images/zshautojump.png" alt="paradin"></p><p>把上面那个<code>[[ -s /root/.autojump/etc/profile.d/autojump.sh ]] &amp;&amp; source /root/.autojump/etc/profile.d/autojump.sh autoload -U compinit &amp;&amp; compinit -u复</code>制到<code>/root/.zshrc</code>的文件里，最好复制在<code>source $ZSH/oh-my-zsh.sh</code>这句话上面，保存之后<code>source ~/.zshrc</code>即可。</p><h2><span id="zsh-syntax-highlighting插件安装">zsh-syntax-highlighting插件安装</span></h2><p>这个插件安装之后主要效果就是命令高亮，如果是错误的命令，颜色是红色，正确的命令是绿色的，安装方法如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd .oh-my-zsh/plugins</span><br><span class="line">yum install -y git  #如果已经安装了git就不用执行的</span><br><span class="line">git clone git:<span class="comment">//github.com/zsh-users/zsh-syntax-highlighting.git</span></span><br><span class="line">source /root/.oh-my-zsh/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh添加到 .zshrc 的最后面</span><br><span class="line">source ~<span class="regexp">/.zshrc</span></span><br></pre></td></tr></table></figure></p><p>效果立竿见影。</p><h2><span id="尾声">尾声</span></h2><p>至此，你现在的zsh应该具备如下几个特性：<br>1、各种补全：路径补全、命令补全，命令参数补全，插件内容补全等等。触发补全只需要按一下或两下tab键，补全项可以使用ctrl+n/p/f/b上下左右切换。比如你想杀掉java的进程，只需要输入kill java + tab键，如果只有一个java进程，zsh会自动替换为进程的pid，如果有多个则会出现选择项供你选择。ssh + 空格 + 两个tab键，zsh会列出所有访问过的主机和用户名进行补全；<br>2、即使你没有安装autojump，只要输入d，就会列出你在这个回话中访问的目录，输入前面的序号，就可以直接跳转；<br>3、可以忽略cd命令, 输入..或者…和当前目录名都可以跳转；<br>当然，除了上面几点，zsh还有很多丰富的插件可以使用，这就需要继续的探索了…</p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="noopener">https://github.com/robbyrussell/oh-my-zsh</a><br><a href="http://macshuo.com/?p=676" target="_blank" rel="noopener">http://macshuo.com/?p=676</a></p>]]></content>
    
    <summary type="html">
    
      生命在于折腾...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="运维技术" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4%E6%8A%80%E6%9C%AF/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>安装vim8.0的过程</title>
    <link href="http://yoursite.com/2018/03/14/%E5%AE%89%E8%A3%85vim8-0%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/03/14/安装vim8-0的过程/</id>
    <published>2018-03-14T13:44:45.000Z</published>
    <updated>2018-03-14T14:47:20.609Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>1.先卸载老的vim<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove vim-* -y</span><br></pre></td></tr></table></figure></p><p>2.下载第三方yum源<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -P /etc/yum.repos.d/  https:<span class="comment">//copr.fedorainfracloud.org/coprs/mcepl/vim8/repo/epel-7/mcepl-vim8-epel-7.repo</span></span><br></pre></td></tr></table></figure></p><p>3.安装vim<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install vim-enhanced</span><br></pre></td></tr></table></figure></p><p>4.验证vim版本<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa |grep vim</span><br><span class="line">vim-enhanced<span class="number">-8.0</span><span class="number">.0704</span><span class="number">-1.1</span><span class="number">.26</span>.el7.centos.x86_64</span><br><span class="line">vim-common<span class="number">-8.0</span><span class="number">.0704</span><span class="number">-1.1</span><span class="number">.26</span>.el7.centos.x86_64</span><br><span class="line">vim-minimal<span class="number">-8.0</span><span class="number">.0704</span><span class="number">-1.1</span><span class="number">.26</span>.el7.centos.x86_64</span><br><span class="line">vim-filesystem<span class="number">-8.0</span><span class="number">.0704</span><span class="number">-1.1</span><span class="number">.26</span>.el7.centos.x86_64</span><br></pre></td></tr></table></figure></p><p><img src="/images/huojin.png" alt="paradin" title="霍金与长者"></p>]]></content>
    
    <summary type="html">
    
      不知道发生了啥就把vim搞坏了，只能重装...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="运维技术" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4%E6%8A%80%E6%9C%AF/"/>
    
      <category term="编辑器" scheme="http://yoursite.com/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>使用expect来实现远程登录ssh</title>
    <link href="http://yoursite.com/2018/03/14/%E4%BD%BF%E7%94%A8expect%E6%9D%A5%E5%AE%9E%E7%8E%B0%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95ssh/"/>
    <id>http://yoursite.com/2018/03/14/使用expect来实现远程登录ssh/</id>
    <published>2018-03-14T13:39:49.000Z</published>
    <updated>2018-03-14T20:20:09.572Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="先说说shebang">先说说shebang</span></h2><p>我们在写一个<code>shell</code>脚本时，总是习惯在最前面加上一行<code>#!/bin/bash</code>,这个就是脚本的<code>shebang</code>,可以把它理解成是一种解释器。至于为什么叫这么个奇怪的名字，C语言和Unix的开发者Dennis Ritchie称它为可能是类似于“hash-bang”的英国风描述性文字；</p><p>贴一段wiki上的解释:</p><blockquote><p>在计算机科学中，shebang是一个由井号和叹号构成的字符串行，其出现在文本文件的第一行的前两个字符。 在文件中存在shebang的情况下，类unix操作系统的程序载入器会分析shebang后的内容，将这些内容作为解释器指令，并调用该指令，并将载有shebang的文件路径作为该解释器的参数。</p></blockquote><p>简单的说，它指示了此脚本运行时的解释器，所以，使用文件名直接执行shell脚本时，必须带上这个<code>shebang</code>; 此外，我们还可以在<code>shebang</code>后面直接附加选项，执行时默认使用选项执行；</p><p>比如<code>test.sh</code>的<code>shebang</code>为<code>#!/bin/sh -x</code>，那我们执行脚本时:<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./test.sh hello</span><br></pre></td></tr></table></figure></p><p>相当于：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/sh -x ./test.sh hello;</span><br></pre></td></tr></table></figure></p><p>而expect编写的脚本，需要用到的shebang为<code>/usr/bin/expect</code>;</p><p>需要注意的是：在指定脚本解释器来执行脚本时，<code>shebang</code>会被指定的脚本解释器覆盖，即优先使用指定的脚本解释器来执行脚本（习惯性地用<code>sh ./test.sh</code>却提示<code>command not found</code>）</p><h2><span id="实例脚本">实例脚本</span></h2><p>expect的具体语法我这里就不说了，看一下下面的参考资料就好了。其实说来说去，就是根据命令栏上的反馈来输入对应的内容，举一个ssh登陆的例子。如图:<br><img src="/images/expectssh.png" alt="paradin"></p><p>从这个我们非常熟悉的ssh登陆的过程就看到，在登陆的时候，页面会返回几个交互的问题，而我们就可以针对这几个问题的关键字来输入答案。最后也根据“Welcome”这个关键字认为我们已经登陆成功了，这样就直接在连接的服务器里操作命令。</p><p>于是根据这个思路，来写一个远程ssh到A机器上的脚本：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/expect -f</span></span><br><span class="line"></span><br><span class="line">set timeout 30        #设定超时时间是30秒，如果是-1那就是永不超时</span><br><span class="line">spawn ssh root@A服务器IP地址        #这里开始ssh连接到目标服务器上</span><br><span class="line"></span><br><span class="line">expect &#123;</span><br><span class="line">  "*(yes/no)?" &#123;    #如果是第一次连接，那么命令栏里就会出现(yes/no)的字样</span><br><span class="line">     send "yes\r"    #此时匹配yes</span><br><span class="line">     expect "*password:" &#123;send "服务器密码\r"&#125;    #如果命令栏出现了password的字样，直接填写密码</span><br><span class="line">   &#125;</span><br><span class="line">      "*password:" &#123;send "服务器密码\r"&#125;        #如果不是第一次连接，那么就会直接出现password，所以可以直接填写密码</span><br><span class="line">&#125;</span><br><span class="line">expect "*Welcome*"    #连接成功就会出现welcome的字样</span><br><span class="line">send "echo '我就是你的爹地' &gt;&gt; /tmp/123321.txt\r"        #此时执行第一个命令</span><br><span class="line">send "df -h\r"        #执行第二个命令</span><br><span class="line">send "cp /tmp/123321.txt /tmp/123123.txt\r"        #执行第三个命令</span><br><span class="line">interact     #脚本fork的子进程会将操作权交给用户，允许用户与当前A服务器的shell进行交互</span><br></pre></td></tr></table></figure></p><h2><span id="参考资料">参考资料</span></h2><p><a href="http://blog.sctux.com/?p=343" target="_blank" rel="noopener">http://blog.sctux.com/?p=343</a><br><a href="http://www.zyy1217.com/2017/07/02/linux%20expect%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener">http://www.zyy1217.com/2017/07/02/linux%20expect%E8%AF%A6%E8%A7%A3/</a><br><a href="https://github.com/jiangxianli/SSHAutoLogin" target="_blank" rel="noopener">https://github.com/jiangxianli/SSHAutoLogin</a><br><a href="https://peiqiang.net/2014/05/10/ssh-auto-login.html" target="_blank" rel="noopener">https://peiqiang.net/2014/05/10/ssh-auto-login.html</a><br><a href="https://www.jianshu.com/p/9bee08dc3dca" target="_blank" rel="noopener">https://www.jianshu.com/p/9bee08dc3dca</a></p>]]></content>
    
    <summary type="html">
    
      题外话一下，加权最少连接，算法为：（活动连接数*256+非活动连接数）÷权重，计算出来的值小的服务器优先被选择。
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="运维技术" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4%E6%8A%80%E6%9C%AF/"/>
    
      <category term="expect" scheme="http://yoursite.com/tags/expect/"/>
    
  </entry>
  
  <entry>
    <title>使用python去做一个生成随机码的页面</title>
    <link href="http://yoursite.com/2018/03/13/%E4%BD%BF%E7%94%A8python%E5%8E%BB%E5%81%9A%E4%B8%80%E4%B8%AA%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E7%A0%81%E7%9A%84%E9%A1%B5%E9%9D%A2/"/>
    <id>http://yoursite.com/2018/03/13/使用python去做一个生成随机码的页面/</id>
    <published>2018-03-13T13:41:28.000Z</published>
    <updated>2018-03-13T13:43:55.500Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="先说一下mkpasswd">先说一下mkpasswd</span></h2><p>linux里是自带生成密码的命令的，比较出名的一个是<code>mkpasswd</code>，另一个是<code>passwdgen</code>。</p><p><code>mkpasswd</code>命令是附属在<code>expect</code>模块里的，如图<br><img src="/images/mkpasswd.png" alt="paradin" title="使用yum whatprovides */mkpasswd去查找依附yum包"></p><p><code>passwdgen</code>的话也要手动执行一下<code>yum install -y passwdgen</code>来安装命令。</p><p>这里主要说说<code>mkpasswd</code>，它支持如下几个参数：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-l       (length <span class="keyword">of</span> password, <span class="keyword">default</span> = <span class="number">7</span>)        指定密码的长度，默认是<span class="number">7</span>位数</span><br><span class="line">-d       (min # of digits, default = 2)           指定密码中数字最少位数，默认是2位</span><br><span class="line">-c       (min # of lowercase chars, default = 2)  指定密码中小写字母最少位数，默认是2位</span><br><span class="line">-C       (min # of uppercase chars, default = 2)  指定密码中大写字母最少位数，默认是2位</span><br><span class="line">-s       (min # of special chars, default = 1)    指定密码中特殊字符最少位数，默认是1位</span><br></pre></td></tr></table></figure></p><p>比如现在要生成一个含有“六位数字而且5位特殊字符的总共16位”的密码，那么命令就是：<code>mkpasswd -l 16 -d 5 -s 5</code>，再聚几个其他的例子，感受一下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@zabbix General_LeChange_Chn_IS_V5.8.00.R.20170814]# mkpasswd -l 16 -d 5 -s 5</span><br><span class="line">g]<span class="number">7</span>Hu-L5,t+<span class="number">32</span>%<span class="number">0</span>m</span><br><span class="line">[root@zabbix General_LeChange_Chn_IS_V5.8.00.R.20170814]# mkpasswd -l 16 -C 5</span><br><span class="line">YvjtFWaV5jr8h%Wy</span><br><span class="line">[root@zabbix General_LeChange_Chn_IS_V5.8.00.R.20170814]# mkpasswd -l 16 -s 10</span><br><span class="line">qoB#^V_=/!??*59:</span><br><span class="line">[root@zabbix General_LeChange_Chn_IS_V5.8.00.R.20170814]# mkpasswd -l 16 -c 4 </span><br><span class="line"><span class="number">9</span>mJOqymatvg*n9sl</span><br></pre></td></tr></table></figure></p><h2><span id="脚本在此">脚本在此</span></h2><p>这个生成随机码的算法部分就使用上面那个<code>mkpasswd</code>了，省了我们不少事。</p><p>整个html界面的代码如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">"utf-8"</span>&gt;</span><br><span class="line">&lt;title&gt;随机密码生成器&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form action=<span class="string">"/cgi-bin/dropdown.py"</span> method=<span class="string">"post"</span> target=<span class="string">"_blank"</span>&gt;</span><br><span class="line">&lt;select name=<span class="string">"dropdown"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;h2&gt;密码长度：&lt;<span class="regexp">/h2&gt;&lt;option value="8" selected&gt;8&lt;/</span>option&gt;</span><br><span class="line">&lt;option value=<span class="string">"16"</span>&gt;<span class="number">16</span>&lt;<span class="regexp">/option&gt;</span></span><br><span class="line"><span class="regexp">&lt;option value="20"&gt;20&lt;/</span>option&gt;</span><br><span class="line">&lt;option value=<span class="string">"24"</span>&gt;<span class="number">24</span>&lt;<span class="regexp">/option&gt;</span></span><br><span class="line"><span class="regexp">&lt;option value="48"&gt;48&lt;/</span>option&gt;</span><br><span class="line">&lt;<span class="regexp">/select&gt; &lt;br /</span>&gt;</span><br><span class="line">&lt;input type=<span class="string">"checkbox"</span> name=<span class="string">"runoob"</span> value=<span class="string">"on"</span> /&gt; 包含小写字母 &lt;br /&gt;</span><br><span class="line">&lt;input type=<span class="string">"checkbox"</span> name=<span class="string">"google"</span> value=<span class="string">"on"</span> /&gt; 包含大写字母 &lt;br /&gt;</span><br><span class="line">&lt;input type=<span class="string">"checkbox"</span> name=<span class="string">"runoob"</span> value=<span class="string">"on"</span> /&gt; 包含数字 &lt;br /&gt;</span><br><span class="line">&lt;input type=<span class="string">"checkbox"</span> name=<span class="string">"google"</span> value=<span class="string">"on"</span> /&gt; 包含特殊字母 &lt;br /&gt;</span><br><span class="line">&lt;input type=<span class="string">"submit"</span> value=<span class="string">"提交"</span>/&gt; &lt;br /&gt;</span><br><span class="line">&lt;h2&gt;密码：&lt;/h2&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure></p><h2><span id="补充">补充</span></h2><p>再分享一个python生成密码的代码，但是这个密码不含特殊字符：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line">salt = <span class="string">''</span>.join(random.sample(string.ascii_letters + string.digits, <span class="number">8</span>))</span><br><span class="line">print salt</span><br></pre></td></tr></table></figure></p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://balajiommudali.wordpress.com/2015/11/27/unable-to-install-mkpasswd-on-centos-6-4/" target="_blank" rel="noopener">https://balajiommudali.wordpress.com/2015/11/27/unable-to-install-mkpasswd-on-centos-6-4/</a><br><a href="http://www.runoob.com/python/python-cgi.html" target="_blank" rel="noopener">http://www.runoob.com/python/python-cgi.html</a></p>]]></content>
    
    <summary type="html">
    
      明天把这篇文章全部写完
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>记一次mysql无法启动的解决过程</title>
    <link href="http://yoursite.com/2018/03/12/%E8%AE%B0%E4%B8%80%E6%AC%A1mysql%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%E7%9A%84%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/03/12/记一次mysql无法启动的解决过程/</id>
    <published>2018-03-12T13:35:15.000Z</published>
    <updated>2018-03-12T13:45:39.226Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="正文">正文</span></h2><p>今天开发人员反馈一个问题，就是某一台开发环境机器的mysql无法启动了，但是如果这台服务器重启的话，mysql就好使，而第二天就会出现mysql死掉然后无法启动的情况。我使用<code>service mysqld restart</code>，命令行反馈如下的内容：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2373j9xivZ data]# service mysqld restart</span><br><span class="line">MySQL server PID file could not be found!                  [FAILED]    </span><br><span class="line">Starting MySQL........The server quit without updating PID file (<span class="regexp">/data/my</span>sql/data/sock/mysql.pid).                                                         [FAILED]</span><br></pre></td></tr></table></figure></p><p>打开错误日志看一下，里面是这么写的：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-10</span> <span class="number">00</span>:<span class="number">26</span>:<span class="number">24</span> <span class="number">25919</span> [Note] InnoDB: Using CPU crc32 instructions</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-10</span> <span class="number">00</span>:<span class="number">26</span>:<span class="number">24</span> <span class="number">25919</span> [Note] InnoDB: Initializing buffer pool, size = <span class="number">4.0</span>G</span><br><span class="line">InnoDB: mmap(<span class="number">549453824</span> bytes) failed; errno <span class="number">12</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-10</span> <span class="number">00</span>:<span class="number">26</span>:<span class="number">24</span> <span class="number">25919</span> [ERROR] InnoDB: Cannot allocate memory <span class="keyword">for</span> the buffer pool</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-10</span> <span class="number">00</span>:<span class="number">26</span>:<span class="number">24</span> <span class="number">25919</span> [ERROR] Plugin <span class="string">'InnoDB'</span> init <span class="function"><span class="keyword">function</span> <span class="title">returned</span> <span class="title">error</span>.</span></span><br><span class="line">2018-03-10 00:26:24 25919 [ERROR] Plugin 'InnoDB' registration as a STORAGE ENGINE failed.</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-10</span> <span class="number">00</span>:<span class="number">26</span>:<span class="number">24</span> <span class="number">25919</span> [ERROR] Unknown/unsupported storage engine: INNODB</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-10</span> <span class="number">00</span>:<span class="number">26</span>:<span class="number">24</span> <span class="number">25919</span> [ERROR] Aborting</span><br></pre></td></tr></table></figure></p><p>爆<code>InnoDB: mmap(549453824 bytes) failed; errno 12</code>，然后我就<code>free -m</code>查看一下，当前服务器的内存已经不够用了。<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2373j9xivZ sock]# free -m</span><br><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line">Mem:          <span class="number">7869</span>       <span class="number">7747</span>        <span class="number">121</span>          <span class="number">0</span>         <span class="number">16</span>         <span class="number">15</span></span><br><span class="line">-<span class="regexp">/+ buffers/</span>cache:       <span class="number">7716</span>        <span class="number">152</span></span><br><span class="line">Swap:            <span class="number">0</span>          <span class="number">0</span>          <span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>那么是什么在占用这台服务器的内存？使用<code>ps aux | sort -k4nr |head -5</code> 这个命令查找当前占用内存最大的五个进程一看，全是<code>php-fpm</code>，同时也发现服务器里面运行大量的<code>php-fpm</code>，在征得开发人员的同意之后，重启<code>php-fpm</code>进程，内存空出来很多。</p><p>此时再次<code>service mysqld restart</code>，发现mysql的错误日志改成如下的样子了：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-12</span> <span class="number">10</span>:<span class="number">53</span>:<span class="number">42</span> <span class="number">28238</span> [Note] InnoDB: Highest supported file format is Barracuda.</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-12</span> <span class="number">10</span>:<span class="number">53</span>:<span class="number">42</span> <span class="number">28238</span> [Note] InnoDB: The log sequence numbers <span class="number">16939991440</span> and <span class="number">16939991440</span> <span class="keyword">in</span> ibdata files <span class="keyword">do</span> not match the log sequence number <span class="number">16940121908</span> <span class="keyword">in</span> the ib_logfiles!</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-12</span> <span class="number">10</span>:<span class="number">53</span>:<span class="number">42</span> <span class="number">28238</span> [Note] InnoDB: Database was not shutdown normally!</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-12</span> <span class="number">10</span>:<span class="number">53</span>:<span class="number">42</span> <span class="number">28238</span> [Note] InnoDB: Starting crash recovery.</span><br></pre></td></tr></table></figure></p><p>这次变成了<code>The log sequence numbers 16939991440 and 16939991440 in ibdata files do not match the log sequence number 16940121908 in the ib_logfiles!</code>，我打开<code>my.cnf</code>，适当的调小了<code>max_connections</code>和<code>innodb_buffer_pool_size</code>，然后<code>service mysqld restart</code>的时候发现错误又变了：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-12</span> <span class="number">11</span>:<span class="number">03</span>:<span class="number">57</span> <span class="number">29190</span> [Note] InnoDB: <span class="number">5.6</span><span class="number">.27</span> started; log sequence number <span class="number">16940121918</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-12</span> <span class="number">11</span>:<span class="number">03</span>:<span class="number">57</span> <span class="number">29190</span> [Note] Server hostname (bind-address): <span class="string">'*'</span>; port: <span class="number">3306</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-12</span> <span class="number">11</span>:<span class="number">03</span>:<span class="number">57</span> <span class="number">29190</span> [Note] IPv6 is not available.</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-12</span> <span class="number">11</span>:<span class="number">03</span>:<span class="number">57</span> <span class="number">29190</span> [Note]   - <span class="string">'0.0.0.0'</span> resolves to <span class="string">'0.0.0.0'</span>;</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-12</span> <span class="number">11</span>:<span class="number">03</span>:<span class="number">57</span> <span class="number">29190</span> [Note] Server socket created on IP: <span class="string">'0.0.0.0'</span>.</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-12</span> <span class="number">11</span>:<span class="number">03</span>:<span class="number">57</span> <span class="number">29190</span> [ERROR] Can<span class="string">'t start server : Bind on unix socket: Permission denied    </span></span><br><span class="line"><span class="string">2018-03-12 11:03:57 29190 [ERROR] Do you already have another mysqld server running on socket: /data/mysql/data/sock/mysql.sock ?</span></span><br><span class="line"><span class="string">2018-03-12 11:03:57 29190 [ERROR] Aborting</span></span><br></pre></td></tr></table></figure></p><p>这就是文件权限问题了，我再次打开<code>my.cnf</code>发现里面的<code>user</code>填写的是<code>mysql</code>，那么把<code>/data/mysql/data/sock/mysql.sock</code>这一系列的文件的所属人都改成了<code>mysql</code>用户，这一次重启mysql就OK了。</p><p>为什么这个<code>mysql</code>会好好的突然自动死掉呢？我发现日志里面有这样的字样：<code>InnoDB: Database was not shutdown normally!</code>，于是我猜想很有可能是<code>php-fpm</code>这进程不断地增长，占用的内存太大，导致<code>mysql</code>被<code>linux</code>的内核杀死了。于是查看<code>/var/log/message</code>的文件，结合mysql的错误日志时间找到了如下的字样：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Mar <span class="number">10</span> <span class="number">00</span>:<span class="number">26</span>:<span class="number">22</span> iZ2373j9xivZ kernel: Out <span class="keyword">of</span> memory: Kill process <span class="number">1883</span> (mysqld) score <span class="number">53</span> or sacrifice child</span><br><span class="line">Mar <span class="number">10</span> <span class="number">00</span>:<span class="number">26</span>:<span class="number">22</span> iZ2373j9xivZ kernel: Killed process <span class="number">1883</span>, UID <span class="number">501</span>, (mysqld) total-vm:<span class="number">6849508</span>kB, anon-rss:<span class="number">429368</span>kB, file-rss:<span class="number">176</span>kB</span><br><span class="line">Mar <span class="number">10</span> <span class="number">04</span>:<span class="number">11</span>:<span class="number">38</span> iZ2373j9xivZ kernel: php-fpm invoked oom-killer: gfp_mask=<span class="number">0x201da</span>, order=<span class="number">0</span>, oom_adj=<span class="number">0</span>, oom_score_adj=<span class="number">0</span></span><br><span class="line">Mar <span class="number">10</span> <span class="number">04</span>:<span class="number">11</span>:<span class="number">38</span> iZ2373j9xivZ kernel: php-fpm cpuset=<span class="regexp">/ mems_allowed=0</span></span><br><span class="line"><span class="regexp">Mar 10 04:11:38 iZ2373j9xivZ kernel: Pid: 4375, comm: php-fpm Not tainted 2.6.32-431.23.3.el6.x86_64 #1</span></span><br></pre></td></tr></table></figure></p><p>证据确凿，<code>php-fpm</code>的无休止增长导致服务器的可用内存变小，最后内核把<code>mysql</code>杀死，修改<code>php-fpm</code>的文件之后，暂时好了点…</p><h2><span id="参考资料">参考资料</span></h2><p><a href="http://robinchen.me/tech/2016/03/14/tech-aliyun-centos-mysql-shutdown-itself-irregularly.html" target="_blank" rel="noopener">http://robinchen.me/tech/2016/03/14/tech-aliyun-centos-mysql-shutdown-itself-irregularly.html</a></p>]]></content>
    
    <summary type="html">
    
      一次启动，三个问题
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="运维技术" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4%E6%8A%80%E6%9C%AF/"/>
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>关于HTTP-Alive应该知道的事</title>
    <link href="http://yoursite.com/2018/03/11/%E5%85%B3%E4%BA%8EHTTP-Alive%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8B/"/>
    <id>http://yoursite.com/2018/03/11/关于HTTP-Alive应该知道的事/</id>
    <published>2018-03-11T03:23:08.000Z</published>
    <updated>2018-03-12T14:44:15.387Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="总体概述">总体概述</span></h2><p>七层协议是一个广为人知的协议，<code>tcp</code>协议是在传输层，<code>http</code>协议是在应用层，也就是说客户端与服务器端先建立<code>tcp</code>连接，然后在<code>tcp</code>连接的基础上传送<code>http</code>报文。</p><p><code>http</code>协议是一个<code>请求-应答</code>的模式，也就是当没有启动<code>keep-alive</code>的时候，每一次建立<code>http</code>连接都是<code>现用现建立，用完就断开</code>的工作样式。而如果开启了<code>keep-alive</code>模式的话，客户端和服务器之间<code>http</code>连接就会被保持，不会断开（超过<code>Keep-Alive</code>规定的时间，意外断电等情况除外），当客户端发送另外一个请求时，就使用这条已经建立的连接。</p><p><code>Keep-Alive</code>的规定时间在客户端（浏览器里）是如何确定的呢？例如<code>Keep-Alive: timeout=5, max=100</code>，表示这个<code>TCP</code>通道可以保持5秒，<code>max=100</code>表示这个长连接最多接收100次请求就断开。</p><p><code>Keep-alive</code>在<code>http 1.1</code>版本里是默认开启的，只有加入<code>Connection: close</code>才会关闭，现在大部分浏览器都是使用<code>http 1.1</code>协议，所以说在客户端已经是默认发起<code>keep-alive</code>的连接请求。但是能否会完成一个完整的<code>keep-alive</code>还要看服务器端的具体配置情况。</p><p>在<code>nginx</code>里就直接支持<code>keepalive_timeout</code>指令，其使用0值来停用<code>keep-alive</code>，举例配置如下:<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location /XXX/ &#123;   </span><br><span class="line">   alias /url/<span class="keyword">var</span>/www/html/;   </span><br><span class="line">   keepalive_timeout  <span class="number">75</span>;  </span><br><span class="line">   expires <span class="number">5</span>m;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用长连接之后，客户端和服务端怎么知道本次传输结束呢？两部分：1. 判断传输数据是否达到了<code>Content-Length</code>指示的大小，这个是最简单的最傻瓜的，普遍应用于静态的图片或者页面；2. 往往动态生成的文件没有<code>Content-Length</code>，它是分块传输<code>（chunked）</code>，这时候怎么办呢？就要根据<code>chunked</code>编码来判断，<code>chunked</code>编码的数据在最后有一个空<code>chunked</code>块，表明本次传输数据结束，这种情况更多应用于动态的页面。</p><h2><span id="进一步的说chunked">进一步的说chunked</span></h2><p>HTTP请求报文的格式是这样的：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;method&gt; &lt;request-URL&gt; &lt;version&gt;</span><br><span class="line">&lt;headers&gt;</span><br><span class="line"></span><br><span class="line">&lt;entity-body&gt;</span><br></pre></td></tr></table></figure></p><p>其中在请求头的地方有一个叫<code>Content-Length</code>的字段，如果没有这个字段那么就会有叫<code>Transfer-encoding</code>的字段，它用来表示<code>http</code>报文的传输格式，这个字段的取值有很多，但是真正有意义的只有一个—<code>chunked</code>。</p><p>如果一个<code>HTTP</code>消息（请求消息或应答消息）的<code>Transfer-Encoding</code>消息头的值为<code>chunked</code>，那么，消息体由数量未定的块组成，并以最后一个大小为0的块为结束。</p><p>每一个非空的块都以该块包含数据的字节数（字节数以十六进制表示）开始，跟随一个<code>CRLF</code>（回车及换行），然后是数据本身，最后块<code>CRLF</code>结束。在一些实现中，块大小和<code>CRLF</code>之间填充有白空格（0x20）。</p><p>最后一块是单行，由块大小（0）、一些可选的填充白空格、以及<code>CRLF</code>组成。最后一块不再包含任何数据，但是可以发送可选的尾部，包括消息头字段。消息最后以<code>CRLF</code>结尾。</p><p>注意1.<code>chunked</code>和<code>multipart</code>两个名词在意义上有类似的地方，不过在<code>HTTP</code>协议当中这两个概念则不是一个类别的。<code>multipart</code>是一种<code>Content-Type</code>，标示<code>HTTP</code>报文内容的类型，而<code>chunked</code>是一种传输格式，标示报头将以何种方式进行传输；</p><p>注意2.<code>chunked</code>传输不能事先知道内容的长度，只能靠最后的空<code>chunk</code>块来判断，因此对于下载请求来说，是没有办法实现进度的。在浏览器和下载工具中，偶尔我们也会看到有些文件是看不到下载进度的，即采用<code>chunked</code>方式进行下载；</p><p>注意3.<code>chunked</code>的优势在于，服务器端可以边生成内容边发送，无需事先生成全部的内容。<code>HTTP/2</code>不支持<code>Transfer-Encoding: chunked</code>，因为<code>HTTP/2</code>有自己的<code>streaming</code>传输方式。</p><h2><span id="http-keep-alive与tcp-keep-alive">http keep-alive与tcp keep-alive</span></h2><p>http的<code>keep-alive</code>与tcp的<code>keep-alive</code>可不是同一回事，意图也不一样。http的<code>keep-alive</code>是为了让tcp活得更久一点，以便在同一个连接上传送多个http，提高<code>socket</code>的效率。而tcp的<code>keep-alive</code>是tcp的一种检测tcp连接状况的保鲜机制。tcp的<code>keep-alive</code>是一个保鲜定时器，支持三个系统内核配置参数：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="number">1800</span> &gt; <span class="regexp">/proc/</span>sys/net/ipv4/tcp_keepalive_time</span><br><span class="line">echo <span class="number">15</span> &gt; <span class="regexp">/proc/</span>sys/net/ipv4/tcp_keepalive_intvl</span><br><span class="line">echo <span class="number">5</span> &gt; <span class="regexp">/proc/</span>sys/net/ipv4/tcp_keepalive_probes</span><br></pre></td></tr></table></figure></p><p><code>keepalive</code>是TCP保鲜定时器，当网络两端建立了tcp连接之后，闲置idle（双方没有任何数据流发送往来）了<code>tcp_keepalive_time</code>后，服务器内核就会尝试向客户端发送侦测包，来判断TCP连接状况(有可能客户端崩溃、强制关闭了应用、主机不可达等等)。如果没有收到对方的回答(ack包)，则会在<code>tcp_keepalive_intvl</code>后再次尝试发送侦测包，直到收到对对方的<code>ack</code>,如果一直没有收到对方的<code>ack</code>,一共会尝试<code>tcp_keepalive_probes</code>次，每次的间隔时间在这里分别是<code>15s、30s、45s、60s、75s</code>。如果尝试<code>tcp_keepalive_probe</code>s,依然没有收到对方的ack包，则会丢弃该TCP连接。TCP连接默认闲置时间是2小时，一般设置为30分钟足够了。</p><p>也就是说，仅当<code>nginx</code>的<code>keepalive_timeout</code>值设置高于<code>tcp_keepalive_time</code>，并且距此tcp连接传输的最后一个<code>http</code>响应，经过了<code>tcp_keepalive_time</code>时间之后，操作系统才会发送侦测包来决定是否要丢弃这个TCP连接。一般不会出现这种情况，除非你需要这样做。</p><h2><span id="keep-alive与time_wait">keep-alive与TIME_WAIT</span></h2><p>使用http的<code>keep-alive</code>，可以减少服务端<code>TIME_WAIT</code>数量(因为由服务端<code>httpd</code>守护进程主动关闭连接)。道理很简单，相较而言，启用<code>keep-alive</code>，建立的<code>tcp</code>连接更少了，自然要被关闭的<code>tcp</code>连接也相应更少了。</p><h2><span id="补充">补充</span></h2><p>建议在服务器提供Web站点服务时(一个页面除了动态内容，还包含非常多的JS、图片、css文件等)开启keep-alive。在“服务器提供的是一个接口服务，除了动态内容，几乎没有引用任何静态内容”这样的场景，不建议开启<code>keep-alive</code>。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="http://www.cnblogs.com/skynet/archive/2010/12/11/1903347.html" target="_blank" rel="noopener">http://www.cnblogs.com/skynet/archive/2010/12/11/1903347.html</a><br><a href="https://hit-alibaba.github.io/interview/basic/network/HTTP.html" target="_blank" rel="noopener">https://hit-alibaba.github.io/interview/basic/network/HTTP.html</a><br><a href="http://51write.github.io/2014/04/09/keepalive/" target="_blank" rel="noopener">http://51write.github.io/2014/04/09/keepalive/</a><br><a href="http://www.nowamagic.net/academy/detail/23350305" target="_blank" rel="noopener">http://www.nowamagic.net/academy/detail/23350305</a></p>]]></content>
    
    <summary type="html">
    
      HTTP是一个无状态协议，这意味着每个请求都是独立的，Keep-Alive 没能改变这个结果。
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="大牛之路" scheme="http://yoursite.com/tags/%E5%A4%A7%E7%89%9B%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="http协议" scheme="http://yoursite.com/tags/http%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>ssh连接port22:Socket error Event:32 Error:10053</title>
    <link href="http://yoursite.com/2018/03/07/ssh%E8%BF%9E%E6%8E%A5port22-Socket-error-Event-32-Error-10053/"/>
    <id>http://yoursite.com/2018/03/07/ssh连接port22-Socket-error-Event-32-Error-10053/</id>
    <published>2018-03-07T10:51:31.000Z</published>
    <updated>2018-03-07T11:41:48.711Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>今天遇到了一个奇怪的现象，据开发人员反馈，有一台阿里云服务器在控制台重启了之后，发现无法登陆了。我先使用阿里云的控制台打算远程登陆到这台机器发现，远程登陆总是显示密码错误。然后我使用xshell登陆对应的外网IP和22端口的时候发现爆出如下的错误：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Connecting to X.X.X.X:<span class="number">22.</span>..</span><br><span class="line">Connection established.</span><br><span class="line">To <span class="built_in">escape</span> to local shell, press <span class="string">'Ctrl+Alt+]'</span>.</span><br><span class="line"></span><br><span class="line">Socket error Event: <span class="number">32</span> <span class="built_in">Error</span>: <span class="number">10053.</span></span><br><span class="line">Connection closing...Socket close.</span><br><span class="line"></span><br><span class="line">Connection closed by foreign host.</span><br></pre></td></tr></table></figure></p><p>这种情况很罕见，google了一下也没有对于我有用的处理办法，于是我就只好给阿里云后台发了一下工单。授权给阿里云让他们登陆一下这台机器看一下里面发生了什么，阿里云的售后人员过了一会打过电话过来说，发现这台机器里面有人操作了<code>chmod -R 777 /</code>，破坏了比如<code>/etc/passwd</code>和<code>/etc/shadow</code>的权限，所以会爆出这样的错误。如图：<br><img src="/images/7771.png" alt="paradin"></p><p>阿里的售后说他们也把几个跟登陆有关的文件暂时恢复权限，这样这个机器就可以成功登陆了，如图：<br><img src="/images/7772.png" alt="paradin"></p>]]></content>
    
    <summary type="html">
    
      刚上的堡垒机，有点磨合是肯定的...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="ssh" scheme="http://yoursite.com/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>孤儿进程和僵尸进程</title>
    <link href="http://yoursite.com/2018/03/07/%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/03/07/孤儿进程和僵尸进程/</id>
    <published>2018-03-07T08:07:35.000Z</published>
    <updated>2018-03-08T14:55:08.182Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="原理与定义">原理与定义</span></h2><p>首先要知道，<code>linux</code>有父进程和子进程这样的说法。那父进程如何创建子进程呢？<code>fork</code>。</p><p>子进程的进行和父进程的进行是异步的，但是父进程就像父母一样对自己的小孩也有一定的控制欲，这个控制欲就表现在如果子进程如果结束了，它释放了之前占用的资源、内存、文件等等，但是它还保留了一点信息：进程号PID、退出状态、运行时间等等。而这些残留信息是父进程通过<code>wait/waitpid</code>来获取，如果父进程一直不获取，那么子进程就会一直保留这些信息直到海枯石烂。</p><p><strong>孤儿进程</strong>：父进程退出，子进程继续进行，那么此时子进程就是孤儿进程。这个时候<code>init</code>进程（进程号为1）来作为子进程的监护人，发出<code>wait/waitpid</code>来完成状态收集工作；<br><img src="/images/jiangshi.png" alt="paradin" title="这个nginx的worker process就成了孤儿进程"></p><p><strong>僵尸进程</strong>：父进程没有退出，但是它迟迟不发出<code>wait/waitpid</code>来回收子进程的资源。就好比儿子死了，当爹的不给收尸，这个儿子就成了孤魂野鬼成了僵尸。</p><h2><span id="影响与危害">影响与危害</span></h2><p>孤儿进程是没有什么大的危害，虽然他虽然没有了亲生父亲，但是也有<code>init</code>进程来通过循环的<code>wait()</code>来处理它的善后工作，所以迟早会把占用的资源释放掉。</p><p>甚至有的用户可以把进程弄成孤儿进程，以使之与用户会话脱钩，并转至后台运行。这一做法常应用于启动需要长时间运行的进程，也即守护进程。另外，<code>nohup</code>命令也可以完成这一操作。</p><p>但是僵尸进程不一样，要是父进程对子进程一直不使用<code>wait/waitpid</code>，那么<code>pid</code>就会不回收，可是系统内的pid总是是有限的，这样久而久之就是对pid的一个霸占，新的进程也无法生成，这就是僵尸进程的危害。</p><h2><span id="如何处理僵尸进程">如何处理僵尸进程</span></h2><p>僵尸进程是杀不死的，怎么办？杀他爹，把父进程杀掉了，那么这些僵尸就成了孤儿进程，然后再由init收养，最后入土为安。</p><p>查看当前服务器僵尸进程的方法：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -A -o stat,ppid,pid,cmd | grep -e <span class="string">'^[Zz]'</span></span><br></pre></td></tr></table></figure></p><p>如果服务器上的僵尸进程不是出自一个父进程之手，那么就用下面这个命令批量解决：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -A -o stat,ppid,pid,cmd | grep -e <span class="string">'^[Zz]'</span> | awk <span class="string">'&#123;print $2&#125;'</span> | xargs kill <span class="number">-9</span></span><br></pre></td></tr></table></figure></p><p>但是如果父进程是init进程，那么这样的僵尸进程怎么办？答案，不用刻意管他，相信<code>init</code>的能力，它迟早会被<code>init</code>回收的，成为僵尸进程也是暂时的。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://zh.wikipedia.org/wiki/%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B</a><br><a href="https://zh.wikipedia.org/wiki/%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B</a><br><a href="http://blog.csdn.net/YuZhiHui_No1/article/details/53011390" target="_blank" rel="noopener">http://blog.csdn.net/YuZhiHui_No1/article/details/53011390</a><br><img src="/images/perfume.jpg" alt="paradin"></p>]]></content>
    
    <summary type="html">
    
      面试的时候，我在回答“僵尸进程和孤儿进程”的时候回答的很不好，于是下午就赶紧拿出来这块的资料来看，认真总结一下。
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>蚂蚁金服运维面试全纪录</title>
    <link href="http://yoursite.com/2018/03/07/%E8%9A%82%E8%9A%81%E9%87%91%E6%9C%8D%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E5%85%A8%E7%BA%AA%E5%BD%95/"/>
    <id>http://yoursite.com/2018/03/07/蚂蚁金服运维面试全纪录/</id>
    <published>2018-03-07T03:33:01.000Z</published>
    <updated>2018-03-19T07:26:00.920Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>早上接到蚂蚁金服的运维面试电话，有点突然袭击，下面是整个的面试记录。</p><p>首先，面试官先向我讲述了一下他们平时运维的工作内容，然后结合我的简历开始提问。</p><p>1）都用过我们的什么产品？<br>这一阶段老老实实、正常回答工作中所用到的阿里云产品和使用情景。</p><p>2）VPC网络有哪些好处？<br>我就答出来更加安全…面试官说其他方面呢，我就不知道了。<br>【事后补充】VPC网路的灵活性更高，可以自由定义网段划分、IP地址和路由网络。</p><p>3)一个vpc的服务器如何与外网交互？<br>我说可以改写路由或者通过<code>iptables</code>转发。</p><p>4）iptables里PREROUTING和POSTROUTING都是啥？<br><code>PREROUTING</code>处理刚到达本机并在路由转发前的数据包；<code>POSTROUTING</code>处理即将离开本机的数据包。</p><p>5）问：RDS在什么操作下会CPU飙升，任举一例？<br>答：在我实际工作中，比较明显的是在数据同步的时候会飙升。</p><p>6）RDS为什么会在DTS的时候有飙升的现象？<br>这个我答的不好，有点东拉西扯…（尴尬）</p><p>7）mysql备份的时候使用过什么参数？<br>答：<code>--skip-opt</code> 防止运行中的MYSQL锁库<br>加速数据备份的参数是什么？<br><code>-q</code> 提高导出性能<br><code>-e</code> 提高导入性能，使用包括几个<code>VALUES</code>列表的多行<code>INSERT</code>语法；<br><code>--max_allowed_packet=XXX</code> 客户端/服务器之间通信的缓存区的最大大小；<br><code>--net_buffer_length=XXX</code> TCP/IP和套接字通信缓冲区大小，创建长度达到<code>net_buffer_length</code>的行；</p><p>注意！<code>max_allowed_packet</code>和<code>net_buffer_length</code>在mysql里有参数值，不能超过参数值！<br>查看方法：<code>show variables like &#39;max_allowed_packet&#39;;</code></p><p>8）cache和buffer有什么区别？<br><code>cache</code>是缓存，弥补高速设备与低速设备的鸿沟引入的中间层，达到数据快取的目的；<br><code>buffer</code>是缓冲区，用户流量整形，把大量的小的io整理一个平稳的大io，减少磁盘响应次数；<br><code>buffer</code>是即将要写入磁盘的，<code>cache</code>是要被从磁盘里读出来的。当然这只是普通用途，<code>buffer</code>用来读、<code>cache</code>用来写也是有可能的。具体问题具体分析。</p><p>9）他俩的调用有什么区别？<br>我问是要说“块读取”什么的么，面试官说是。我就蒙说cache是块读取，buffer我不清楚…（尴尬 again）<br>【事后补充】</p><p>10）谈一谈time_wait和close_wait，各自在什么情况下出现？<br><code>time_wait</code>和<code>close_wait</code>是出现在“四次挥手”的环节里，<code>time_wait</code>是服务器接收到客户端发来的断开TCP连接的请求，并且服务器发送确认断开的包给客户端，此时服务器处于<code>time_wait</code>状态，如果服务器等待两个<code>msl</code>的话，就会默认断开连接，如果想修改<code>msl</code>可以通过修改<code>/etc/systl.conf</code>文件；<br><code>close_wait</code>是客户端已经发送了断开TCP请求，但是服务器端没有接收到，也就是<code>time_wait</code>的上一步，此时这个资源就一直被程序霸占。</p><p>11）为什么time_wait需要等待两个msl?1.99行不行？2.01行不行？<br>我当时说防止上一次连接中的包，迷路后重新出现，影响新连接。面试官好像觉得不是很满意…（尴尬 again）<br>【事后补充】MSL是指一个片段在网络中的最大存活时间，2MSL是一个发送和一个回复所需的最大时间，如果直到2MSL，客户端都没有收到fin包，那么客户端就可以断定他发出去的ack已经被服务端接收，结束TCP连接。</p><p>12）说出一个你使用过的python库。<br>我说我前两天用<code>matpoltlib</code>画图，就谈了谈这个画图的库。</p><p>13）python装饰器了解么？<br>没什么深入的了解，就没敢答，怕被问死。</p><p>14）僵尸进程和孤儿进程，了解么？<br>马蛋，这个让我给说反了…(闹心啊啊啊啊啊啊啊)<br>【事后补充】孤儿进程：父进程退出，而它的一个或者多个子进程还在运行，这些子进程就叫孤儿进程，孤儿进程被init进程收养，由init进程对它们完成状态收集工作；<br>僵尸进程：一个进程用fork创建了子进程，然后这个子进程退出了，而父进程并没有调用wait或者waitpid去获取子进程的状态信息，那么这个子进程的进程描述符还在系统中，这种进程叫僵尸进程；</p><p>孤儿进程不怕，由于孤儿虽然没有父母，但是有民政局（init进程）收养，孤儿进程退出后也有init做一切善后工作；而僵尸进程会一直霸占其PID号，但是系统总共的PID是有限的，这样就会让可用的PID越来越少，所以僵尸进程是要避免的。</p>]]></content>
    
    <summary type="html">
    
      呼~~不晓得会不会有下一轮...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="大牛之路" scheme="http://yoursite.com/tags/%E5%A4%A7%E7%89%9B%E4%B9%8B%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper的选举原理</title>
    <link href="http://yoursite.com/2018/03/05/Zookeeper%E7%9A%84%E9%80%89%E4%B8%BE%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2018/03/05/Zookeeper的选举原理/</id>
    <published>2018-03-05T13:30:10.000Z</published>
    <updated>2018-03-05T16:38:51.584Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="前言">前言</span></h2><p><code>Zookeeper</code>是一款比较常见的式应用程序协调服务软件，如果配置了多台<code>zookeeper</code>自然要选择一个头头，这个头头就是<code>leader</code>，很明显不能所有的<code>zookeeper</code>都是<code>leader</code>，那样就失控了；也不能所有的<code>zookeeper</code>都是<code>follower</code>，那就群龙无首无法协调。</p><p>插播一句，这种<code>一老大N跟班</code>的模式是过去分布式软件里很常见的工作模式，而最近比较火热的区块链不同，它是一种<code>去中心化</code>的工作模式，大家人人都当节点，然后放在一起整合，有点原始社会的意思。所以说，算法有时候来自于人类学，也会在一定程度反过来上影响人类。</p><p>选举<code>leader</code>的方式是一种叫<code>FastLeaderELection</code>的算法，以<code>3.4.6</code>版本为例，它被保存在<code>/usr/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/</code>这个文件夹下。</p><h2><span id="选举的中心思想">选举的中心思想</span></h2><p>实际上<code>FastLeaderELection</code>说的中心思想无外乎以下几个关键点：</p><ol><li><p>全天下我最牛！在我没有发现比我牛的推荐人的情况下，我就一直推举我当<code>leader</code>，第一次投票那必须推举我自己当<code>leader</code>。</p></li><li><p>每当我接收到其它的被推举者，我都要回馈一个信息，表明我还是不是推举我自己。如果被推举者没我大，我就一直推举我当<code>leader</code>，是我是我还是我！</p></li><li><p>我有一个票箱， 和我属于同一轮的投票情况都在这个票箱里面。一人一票重复的或者过期的票，我都不接受。</p></li><li><p>一旦我不再推举我自己了（这时我发现别人推举的人比我推荐的更牛），我就把我的票箱清空，重新发起一轮投票（这时我的票箱一定有两票了，都是选的我认为最牛的人）。</p></li><li><p>一旦我发现收到的推举信息中投票轮要高于我的投票轮，我也要清空我的票箱。并且还是投当初我觉得最牛的那个人（除非当前的人比我最初的推荐牛，我就顺带更新我的推荐）。</p></li><li><p>不断的重复上面的过程，不断的告诉别人“我的投票是第几轮”、“我推举的人是谁”。直到我的票箱中“我推举的最牛的人”收到了不少于<code>N/2 + 1</code>的推举投票。这也回答了为什么<code>zookeeper</code>在少于<code>N/2 + 1</code>的节点处于工作状态的情况下会崩溃了。因为，无论怎么选也没有任何节点能够获得<code>N/2 + 1</code>的票数。</p></li><li><p>这时我就可以决定我是<code>flower</code>还是<code>leader</code>了（如果至始至终都是我最牛，那我就是<code>leader</code>咯，其它情况就是<code>follower</code>咯）。并且不论随后收到谁的投票，都向它直接反馈“我的结果”。</p></li></ol><h2><span id="判断依据">判断依据</span></h2><p>上面第二步里说了，如果接收到其他被推举者的消息，而且判断出这个被推举者比我牛，我就要推举他，那么判断依据是啥呢？答案是依次比较<code>epoch</code>、<code>zxid</code>、<code>serverid</code>。</p><p>先说说啥是<code>epoch</code>、<code>zxid</code>、<code>serverid</code>：</p><ul><li><code>epoch</code>: 表示选举轮数。</li><li><code>zxid</code>: 事务zxid包含了本地数据的最后更新时间相关的信息。</li><li><code>serverid</code>: 当前<code>server</code>的 ID, 通过配置文件指定(<code>echo &#39;1&#39; &gt; myid</code>)。</li></ul><p>具体的判断过程是：接收到的消息中，有<code>epoch</code>比我大的，则选<code>epoch</code>大的消息中确定的<code>server</code>；如果<code>epoch</code>相等，则选<code>zxid</code>最大的<code>server</code>；如果<code>zxid</code>也相等，则选<code>serverid</code>最大的<code>server</code>(有的节点生来就是当<code>leader</code>的）。</p><p>为什么要有<code>epoch</code>呢？这样是为了防止中途有选举者掉线，他们错过了选举，再次连上来的时候，他们发现自己的投票轮已经小于现有的投票轮了，那么他们比如要清空自己的投票箱然后无条件的改为推荐接收到的最新选举中大家推荐的最牛的那个人（如果没有人比我牛，那还是推荐我自己）。由于有最后一条<code>serverid</code>大的最后压阵，而且<code>serverid</code>又不能重复，所以基本上都能最后选出一台作为<code>leader</code>。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="http://blog.csdn.net/yinwenjie/article/details/47613309" target="_blank" rel="noopener">http://blog.csdn.net/yinwenjie/article/details/47613309</a><br><a href="https://mozillazg.com/2017/03/zookeeper-fastleader-elect-leader.html" target="_blank" rel="noopener">https://mozillazg.com/2017/03/zookeeper-fastleader-elect-leader.html</a></p><p><img src="/images/messifreekick.gif" alt="paradin" title="八倍镜狙击模式开启"></p>]]></content>
    
    <summary type="html">
    
      zookeeper的选举是没有“仲裁者”的，就是看投票
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="运维技术" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4%E6%8A%80%E6%9C%AF/"/>
    
      <category term="zookeeper" scheme="http://yoursite.com/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>从韩国民主电影三部曲浅谈我对民主的认识</title>
    <link href="http://yoursite.com/2018/03/04/%E9%9F%A9%E5%9B%BD%E6%B0%91%E4%B8%BB%E7%94%B5%E5%BD%B1%E4%B8%89%E9%83%A8%E6%9B%B2/"/>
    <id>http://yoursite.com/2018/03/04/韩国民主电影三部曲/</id>
    <published>2018-03-04T13:07:08.000Z</published>
    <updated>2018-03-04T15:51:39.772Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>这个周末周五晚上看了《出租车司机》，周六下午看了《1987：黎明到来的那一天》，再加上之前就在B站看过又被下架的《辩护人》，韩国民主运动三部曲都看完了。</p><p>韩国民主运动电影还有一部叫《华丽的假期》，这个片子是2007年公映的，也是讲光州事件，但是这部片从电影角度上不如上面这三者，所以影响力和传播程度相对有限。</p><p>一直以来我对韩国的政治采取一种“黑”的态度，因为他们的总统基本没有好下场，哪怕是我个人比较喜欢的卢武铉总统也是以自杀结束了自己的一生，而且他们的演艺圈和体育圈也是以各种“黑”和“潜规则”出名。但是我不得不佩服韩国正直电影人的精神以及韩国正直记者们的精神，他们坚持了自己的操守而且履行了自己的职责，用骨气和勇气记录了他们能接触到的真相并且在日后拍成电影反思历史。</p><p>论民主化运动，韩国可以说是亚洲里第一档的存在，大型示威的次数加起来比越南、缅甸、柬埔寨加起来还要多，远超于同样是发达国家的日本。韩国民主化运动主要集中在1980-1987年全斗焕执政那一段时间，那时韩国人民虽然经历了初期经济水平腾飞的甜蜜，但是对后期经济调控不力和政府打压言论表示不满和愤怒。暴动的人民反抗意识比较强，不仅有大规模游行，甚至有这几部电影里没有提到的抢劫军火库的行为。而这些抢劫军火的行为日后也成了全斗焕在法庭上力图脱罪的一个辩控点。</p><p>这几部电影虽然被部分人影评“有明显的韩国特色，会导致审美疲劳”，但是并不耽误它们一次又一次的刷新票房记录，可见参与政治追求民主和公平其实是公民的一种本能。但是说实话，截止至今，光州事件虽然被平反但是没有得到彻底的清算。新闻说现任韩国总统文在寅先后观看了《出租车司机》和《1987：黎明到来的那一天》，会不会重审当年的光州罪犯，我们拭目以待。</p><p>民主可能本身不是一个效率很高的政治制度，因为它要坚持“少数服从多数”的原则，在具体条款颁布和施行的时候，由于不同人看待事物的水平和深度有高有低，以及侧重面的不同，那么肯定会有一些不一样的声音。而独裁的“一言堂”则相对效率很快，从历史来看，独裁政府甚至有战争上打败民主政府的先例，而且独裁政府挑头并且通过集权形式搞经济的话，在国家原有经济非常落后的前提下，的确可以快速进步，但是这种进步并不是那种“可持续发展”式的，而且中后期会由于民众监督不力，导致政府腐败的先例数不胜数。所以说集权就是一个春药，服用肯定会上瘾，但是也只会用暂时的爽换来将来的无穷尽的苦。独裁无论是理论还是事实都已经被当今社会唾弃，只有民主化才是迟早的选择，因为它至少可以守得住下限。</p><p>而且我个人认为，民主是一个持续的过程而不是一个简单的结果。绝对意义上的民主和拖沓低效的民主只会害了广大的底层百姓，极力避免的同时，也要最小程度的限制人滥用民主，这些就需要政府工作的透明化和规范化。</p><p>不过韩国的民主也有它的独特性，主要就是它有特殊的外界因素—-既不能得罪美国人，又不能惹毛了朝鲜（这一点跟台湾很像），所以无论是强权政府还是抗议民众都没有把事情搞得太过火。其次还有韩国中产阶级在抗议中也扮演了“理性和保守的一面”：他们是经济发展的受益者，对秩序有相当的敏感性，一旦社会民主斗争极端化，中产阶级便会退出民主运动，这是其保守性的表现。除此之外，还有比如基督教的传播代替了原有的儒家思想更追求自由等等因素，我这里水平有限，就不展开了。</p><p>最后补充一句，各位都知道《辩护人》里宋康昊的原型是卢武铉总统，据说片里宋康昊parter的原型就是韩国现在的总统—文在寅。</p><p><img src="/images/koreaD.png" alt="paradin"></p>]]></content>
    
    <summary type="html">
    
      我们生而为人，对自由与光明的向往，都如出一辙。
    
    </summary>
    
      <category term="坠乱花天" scheme="http://yoursite.com/categories/%E5%9D%A0%E4%B9%B1%E8%8A%B1%E5%A4%A9/"/>
    
    
      <category term="政治" scheme="http://yoursite.com/tags/%E6%94%BF%E6%B2%BB/"/>
    
      <category term="亚洲民主" scheme="http://yoursite.com/tags/%E4%BA%9A%E6%B4%B2%E6%B0%91%E4%B8%BB/"/>
    
      <category term="影评" scheme="http://yoursite.com/tags/%E5%BD%B1%E8%AF%84/"/>
    
  </entry>
  
  <entry>
    <title>动手做一个网络简历并且保存成PDF</title>
    <link href="http://yoursite.com/2018/03/02/%E5%8A%A8%E6%89%8B%E5%81%9A%E4%B8%80%E4%B8%AA%E7%BD%91%E7%BB%9C%E7%AE%80%E5%8E%86%E5%B9%B6%E4%B8%94%E4%BF%9D%E5%AD%98%E6%88%90PDF/"/>
    <id>http://yoursite.com/2018/03/02/动手做一个网络简历并且保存成PDF/</id>
    <published>2018-03-02T05:36:51.000Z</published>
    <updated>2018-03-02T17:43:57.745Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="环境说明">环境说明</span></h2><p>服务器:<code>nginx</code><br>浏览器:<code>firefox</code></p><h2><span id="制作网页简历过程">制作网页简历过程</span></h2><p>首先先下载简历的模板文件，过程如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget http:<span class="comment">//labfile.oss.aliyuncs.com/courses/624/cv-template.zip</span></span><br><span class="line">unzip cv-template</span><br><span class="line">mv cv-template<span class="comment">/* .</span></span><br><span class="line"><span class="comment">rm -rf cv-template* __MACOSX*</span></span><br></pre></td></tr></table></figure></p><p>然后在浏览器里的地址栏里输入<code>服务器外网IP</code>，就可看到下面的界面，如图：<br><img src="/images/jianli.png" alt="paradin"></p><p>我们发现这个界面是可以编辑的，于是就在前人的基础上修改即可，这里感谢前人栽树！！！</p><p>但是修改了并不是就保存了，如果你刷新这个界面发现又变成了初始的界面。所以这个时候我们要把修改过的网页的前端代码拷贝下来。</p><p>在firefox浏览器的<code>配置</code>里选择<code>WEB开发者</code>，如图：<br><img src="/images/jianli5.png" alt="paradin"></p><p>然后选择<code>查看器</code>：<br><img src="/images/jianli1.png" alt="paradin"></p><p>这个时候在页面就出现了整个网页的代码，选择<code>复制</code>—<code>HTML外面</code>：<br><img src="/images/jianli2.png" alt="paradin"></p><p>然后把这个html代码拷贝到nginx服务器里的<code>index.html</code>里覆盖原有的内容，再重新刷新浏览器，就会成为已经保存过的界面了！<br><img src="/images/jianli6.png" alt="paradin"></p><h2><span id="将网页保存成pdf">将网页保存成PDF</span></h2><p>在浏览器里的<code>配置</code>里选择<code>打印</code>，然后现在<code>页面设置</code>里的勾选<code>打印背景（颜色和图片）</code>再修改一下<code>页眉和页脚</code>。再点击打印，默认情况就会保存成<code>PDF</code>文件了。<br><img src="/images/jianli4.png" alt="paradin"><br><img src="/images/jianli3.png" alt="paradin"></p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://segmentfault.com/a/1190000006820290" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006820290</a></p><p><img src="/images/guangmei1.gif" alt="paradin"></p>]]></content>
    
    <summary type="html">
    
      跳槽的高峰期，你需要一个帅气时尚的简历！
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>Linux运维工程师笔试题第十五套</title>
    <link href="http://yoursite.com/2018/03/01/Linux%E8%BF%90%E7%BB%B4%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%AC%94%E8%AF%95%E9%A2%98%E7%AC%AC%E5%8D%81%E4%BA%94%E5%A5%97/"/>
    <id>http://yoursite.com/2018/03/01/Linux运维工程师笔试题第十五套/</id>
    <published>2018-03-01T05:50:16.000Z</published>
    <updated>2018-03-18T11:09:00.694Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="正文">正文</span></h2><p>1.粘包是什么意思？<code>TCP</code>和<code>UDP</code>是否会出现粘包？出现了粘包如何处理？<br>[我的答案]粘包就是当客户端连续不断的往服务端发送数据包的时候，服务端接收的数据会出现两个数据包粘在一起的情况；UDP（非面向连接）是不会出现粘包的，因为UDP协议是基于报文的，UDP首部采用了16bit来指示UDP数据报文的长度，因此在应用层能很好的将不同的数据报文区分开，从而避免粘包和拆包的问题。而TCP（面向连接）是基于字节流的，它无法识别包的长度，所以会出现粘包的现象。</p><p>解决办法主要有以下三种：<br>1）发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了，有较高的效率而且少冗余，但是编程较复杂；<br>2）发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来，编程简单但是效率一般甚至很低；<br>3）可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开；</p><p>2.<code>time_wait</code>是什么情况？如果出现了过多的<code>close_wait</code>可能是什么原因？<br>[我的答案]<code>TIME_WAIT</code>是主动关闭连接的一方保持的状态，在保持这个状态2MSL<code>max segment lifetime</code>时间之后，彻底关闭回收资源。遇到<code>TIME_WAIT</code>数过大导致的服务器异常，很容易解决，修改下<code>/etc/sysctl.conf</code>就ok了。</p><p>如果一直保持在<code>CLOSE_WAIT</code>状态，那么只有一种情况，就是在对方关闭连接之后服务器程序自己没有进一步发出<code>ack</code>信号。换句话说，就是在对方连接关闭之后，程序里没有检测到，或者程序压根就忘记了这个时候需要关闭连接，于是这个资源就一直被程序占着。这个情况多半是代码的问题，在服务器端是无能为力的，要检查代码。</p><p>3.<code>epoll</code>和<code>select</code>的区别？边缘触发和水平触发的区别？<br>[我的答案]<code>select</code>查询速度较慢，因为他每次产生<code>fd</code>时候会有整体<code>fdset</code>的拷贝，而且每次有回送，<code>select</code>要查询整个<code>fdset</code>；<code>epoll</code>查询速度较快，因为他为每个<code>fd</code>都<code>regist</code>了一个单独的回调函数。</p><p>水平触发(LT)：当<code>epoll</code>检测到其上有事件发生并通知应用程序时，应用程序可以不立即处理，这样当应用程序再次调用<code>epoll</code>中调用函数时，<code>epoll</code>会再次通知应用程序此事件,直到被处理。</p><p>边沿触发(ET)：当<code>epoll</code>检测到其上有事件发生并通知应用程序时，应用程序必须立即处理，并且下一次的<code>epoll</code>调用，不会再向应用程序通知此事件。</p><p>所以<code>ET</code>模式大大得降低了同一个<code>epoll</code>事件被重复触发的次数，因此<code>ET</code>模式工作效率比<code>LT</code>模式更高。<code>select</code>、<code>poll</code>、<code>epoll</code>的默认工作模式都是水平触发(<code>LT</code>)模式，但是epoll是支持边沿触发(<code>ET</code>)模式的。 </p><p>4.<code>varchar</code>和<code>char</code>的区别是什么？utf8字符集下<code>varchar</code>最多存多少个字符？<br>[我的答案]前面那个问题去看<a href="http://blog.51cto.com/chenx1242/1742467，这里说后面那个。" target="_blank" rel="noopener">http://blog.51cto.com/chenx1242/1742467，这里说后面那个。</a><br>在<code>utf-8</code>状态下的<code>varchar</code>，最大只能到 <code>(65535 - 2) / 3 = 21844 余 1</code>。<br>在<code>gbk</code>状态下的<code>varchar</code>, 最大只能到 <code>(65535 - 2) / 2 = 32766 余 1</code>。</p><p>5.<code>primary key</code>和<code>unique</code>的区别？<br>[我的答案]首先先说明<code>primary key = unique +  not null</code>，其次<code>Unique Key</code>可以是空，可以在一个表里的一个或多个字段定义，也就是爱有几个有几个，同时存在也可以；但是<code>Primary Key</code>不能为空不能重复，而其一个表里只能有一个<code>Primary Key</code>。</p><p>6.乐观锁是啥，悲观锁是啥？<br>[我的答案]悲观锁<code>Pessimistic Lock</code>, 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会<code>block</code>直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</p><p>乐观锁<code>Optimistic Lock</code>, 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于<code>write_condition</code>机制的其实都是提供的乐观锁。</p><p>两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适。</p><p>7.如何在python的三引号里添加变量？<br>[我的答案]<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">~$ python</span><br><span class="line">Python <span class="number">2.7</span><span class="number">.3</span> (<span class="keyword">default</span>, Jan  <span class="number">2</span> <span class="number">2013</span>, <span class="number">16</span>:<span class="number">53</span>:<span class="number">07</span>) </span><br><span class="line">[GCC <span class="number">4.7</span><span class="number">.2</span>] on linux2</span><br><span class="line">Type <span class="string">"help"</span>, <span class="string">"copyright"</span>, <span class="string">"credits"</span> or <span class="string">"license"</span> <span class="keyword">for</span> more information.</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; context = <span class="string">""</span><span class="string">"Here is an example block template:</span></span><br><span class="line"><span class="string">...     name: %(name)s</span></span><br><span class="line"><span class="string">...     age: %(age)d</span></span><br><span class="line"><span class="string">...     job: %(job)s</span></span><br><span class="line"><span class="string">... "</span><span class="string">""</span></span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; print context % dict(name=<span class="string">"Tim Wang"</span>, age=<span class="number">45</span>, job=<span class="string">"Coder"</span>)</span><br><span class="line">Here is an example block template:</span><br><span class="line">    name: Tim Wang</span><br><span class="line">    age: <span class="number">45</span></span><br><span class="line">    job: Coder</span><br><span class="line"> &gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p><p>8.<code>redis</code>满了会怎么样？<br>[我的答案]默认情况下<code>redis</code>满了就不会存储新的数据了，不过这个可以调整，<code>redis</code>在达到指定内存的时候可以通过设定的策略来做不同的动作，常见策略如下：<br>1）<code>noeviction</code>:返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但DEL和几个例外）<br>2）<code>allkeys-lru</code>: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。<br>3）<code>volatile-lru</code>: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。<br>4）<code>allkeys-random</code>: 回收随机的键使得新添加的数据有空间存放。<br>5）<code>volatile-random</code>: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。<br>6）<code>volatile-ttl</code>: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。</p><p>9.啥是“脏读”、“不可重复读”、“幻读”？<br>[我的答案]<code>脏读</code>又称无效数据的读出，是指在数据库访问中，事务T1将某一值修改，然后事务T2读取该值，此后T1因为某种原因撤销对该值的修改，这就导致了T2所读取到的数据是无效的。</p><p><code>不可重复读</code>是指在数据库访问中，一个事务范围内两个相同的查询却返回了不同数据。这是由于查询时系统中其他事务修改的提交而引起的。比如事务T1读取某一数据，事务T2读取并修改了该数据，T1为了对读取值进行检验而再次读取该数据，便得到了不同的结果。</p><p><code>幻读</code>是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的“全部数据行”。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入“一行新数据”。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。</p><p>10.ext2、ext3、ext4的区别是啥？<br>[我的答案]<code>ext3</code>和<code>ext2</code>的主要区别在于，<code>ext3</code>引入<code>Journal</code>。<br><code>ext2</code>和<code>ext3</code>的格式完全相同，只是在<code>ext3</code>硬盘最后面有一部分空间用来存放<code>Journal</code>（日志）的记录；<br>在<code>ext2</code>中，写资料到硬盘中时，先将资料写入缓存中，当缓存写满时才会写入硬盘中；<br>在<code>ext3</code>中，写资料到硬盘中时，先将资料写入缓存中，待缓存写满时系统先通知<code>Journal</code>，再将资料写入硬盘，完成后再通知<code>Journal</code>，资料已完成写入工作；<br>在<code>ext3</code>中，也就是有<code>Journal</code>机制里，系统开机时检查<code>Journal</code>的资料，来查看是否有错误产生，这样就快了很多；</p><p><code>ext4</code>和<code>ext3</code>的主要区别在于:首先<code>ext4</code>与<code>ext3</code>兼容,<code>ext3</code>只支持32,000个子目录，而额<code>ext4</code>支持无限数量的子目录;<code>ext3</code>所支持的16TB文件系统和最大的2TB的文件，而<code>ext4</code>分别支持1EB（1,048,576TB，1EB=1024PB，1PB=1024TB）的文件系统，以及16TB的文件;<code>ext3</code>的数据块分配策略是尽快分配，而<code>ext4</code>是尽可能地延迟分配，直到文件在<code>cache</code>中写完才开始分配数据块并写入磁盘;<code>ext4</code>允许关闭日志，以便某些有特殊需求的用户可以借此进一步提升性能等等等等。</p><p>11.简述一下A记录与NS记录的区别<br>1.A记录是名称解析的重要记录，它用于将特定的主机名映射到对应主机的IP地址上。你可以在DNS服务器中手动创建或通过DNS客户端动态更新来创建。<br>2.NS记录此记录指定负责此DNS区域的权威名称服务器。<br>3.A记录和NS记录的区别是，A记录直接给出目的IP，NS记录将DNS解析任务交给特定的服务器，NS记录中记录的IP即为该特定服务器的IP地址。<br>4.NS记录优先于A记录，A记录优先于CNAME记录 </p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://blog.insanecoder.top/tcp-packet-splice-and-split-issue/" target="_blank" rel="noopener">https://blog.insanecoder.top/tcp-packet-splice-and-split-issue/</a><br><a href="http://blog.csdn.net/tiandijun/article/details/41961785" target="_blank" rel="noopener">http://blog.csdn.net/tiandijun/article/details/41961785</a><br><a href="http://www.redis.cn/topics/lru-cache.html" target="_blank" rel="noopener">http://www.redis.cn/topics/lru-cache.html</a><br><a href="http://blog.csdn.net/d_guco/article/details/53166722" target="_blank" rel="noopener">http://blog.csdn.net/d_guco/article/details/53166722</a><br><a href="http://www.hollischuang.com/archives/934" target="_blank" rel="noopener">http://www.hollischuang.com/archives/934</a><br><a href="http://zhaodedong.leanote.com/post/Linux%EF%BC%9AExt2-Ext3-Ext4%E7%9A%84%E5%8C%BA%E5%88%AB" target="_blank" rel="noopener">http://zhaodedong.leanote.com/post/Linux%EF%BC%9AExt2-Ext3-Ext4%E7%9A%84%E5%8C%BA%E5%88%AB</a></p>]]></content>
    
    <summary type="html">
    
      大牛之路，如此辛苦
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="面试经验" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/"/>
    
      <category term="大牛之路" scheme="http://yoursite.com/tags/%E5%A4%A7%E7%89%9B%E4%B9%8B%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>调用阿里云api获取阿里云数据同步服务（DTS）并且作图发送邮件的整个流程</title>
    <link href="http://yoursite.com/2018/02/28/%E8%B0%83%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91api%E8%8E%B7%E5%8F%96%E9%98%BF%E9%87%8C%E4%BA%91%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E6%9C%8D%E5%8A%A1%EF%BC%88DTS%EF%BC%89%E5%B9%B6%E4%B8%94%E4%BD%9C%E5%9B%BE%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E7%9A%84%E6%95%B4%E4%B8%AA%E6%B5%81%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/02/28/调用阿里云api获取阿里云数据同步服务（DTS）并且作图发送邮件的整个流程/</id>
    <published>2018-02-28T15:00:20.000Z</published>
    <updated>2018-02-28T15:27:54.743Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="前言">前言</span></h2><p>在<a href="https://rorschachchan.github.io/2018/02/24/阿里云获取DTS服务延迟的脚本/" target="_blank" rel="noopener">https://rorschachchan.github.io/2018/02/24/阿里云获取DTS服务延迟的脚本/</a> 文章里已经说了“领导要求每天查看阿里云dts同步的延迟情况和同步速率情况”，并且在<a href="https://rorschachchan.github.io/2018/02/27/使用matplotlib画图的一个脚本/" target="_blank" rel="noopener">https://rorschachchan.github.io/2018/02/27/使用matplotlib画图的一个脚本/</a> 里面也放了一个使用<code>python matplotlib</code>画图的demo，这篇文章的目的就是把整个过程实现，并且把dts图形以每日邮件的形式发送给领导的效果！</p><h2><span id="实现需求的思路">实现需求的思路</span></h2><p>本次需求有四个动作，分别是<code>获取一天以内的DTS延迟和同步速率</code>、<code>将获取到的DTS值做成PNG图像</code>、<code>将生成的PNG图像上传到阿里云云存储OSS</code>、<code>把图片展示到邮件里并发送给相关领导</code>。由于第一步<code>获取一天以内的DTS延迟和同步速率</code>需要将这个脚本每小时执行一次，执行24次，才可以执行<code>生成png图像</code>这一步，所以后三个其实可以写成一个大脚本。不过在本文为了表述的清楚，就把各自不同用途写成了不同的脚本。</p><h2><span id="获取阿里云dts延迟和同步速率的脚本">获取阿里云DTS延迟和同步速率的脚本</span></h2><p>这个脚本之前写过了，这里再拿出来晒一遍：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line">#coding=utf-8</span><br><span class="line">#这个脚本是用来获取dts延迟数字的</span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore <span class="keyword">import</span> client</span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore.acs_exception.exceptions <span class="keyword">import</span> ClientException</span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore.acs_exception.exceptions <span class="keyword">import</span> ServerException</span><br><span class="line"><span class="keyword">import</span> time,json,sys</span><br><span class="line">sys.path.append('/解压缩路径/aliyunsdkdts/request/v20160801/')#这里看不懂去看https://rorschachchan.github.io/2018/02/24/阿里云获取DTS服务延迟的脚本/</span><br><span class="line"><span class="keyword">import</span> DescribeSynchronizationJobStatusRequest</span><br><span class="line"></span><br><span class="line"># 创建 Client 实例</span><br><span class="line">clt = client.AcsClient(<span class="string">'这里填写ak'</span>,<span class="string">'这里填写sk'</span>,<span class="string">'cn-shenzhen'</span>)</span><br><span class="line"></span><br><span class="line"># 创建 request，并设置参数</span><br><span class="line">request = DescribeSynchronizationJobStatusRequest.DescribeSynchronizationJobStatusRequest()</span><br><span class="line">request.set_SynchronizationJobId(<span class="string">"这里填写DTS的ID号"</span>)</span><br><span class="line"></span><br><span class="line">response = clt.do_action_with_exception(request)</span><br><span class="line"></span><br><span class="line">delay = json.loads(response)</span><br><span class="line">rate = str(delay["Performance"]["FLOW"])[0:4]#由于同步速率默认是带单位的，这里就取前四位</span><br><span class="line"></span><br><span class="line">#用A.txt来存储延迟时长</span><br><span class="line">fd = open(<span class="string">"/存储路径/A.txt"</span>,<span class="string">"a"</span>)</span><br><span class="line">fd.write(str(delay[<span class="string">"DataSynchronizationStatus"</span>][<span class="string">"Delay"</span>]))</span><br><span class="line">fd.write(<span class="string">'\n'</span>)</span><br><span class="line">fd.close()</span><br><span class="line"></span><br><span class="line">#用B.txt来存储同步速率</span><br><span class="line">fr = open(<span class="string">"/存储路径/rate.txt"</span>,<span class="string">"a"</span>)</span><br><span class="line">fr.write(rate)</span><br><span class="line">fr.write(<span class="string">'\n'</span>)</span><br><span class="line">fr.close()</span><br></pre></td></tr></table></figure></p><h2><span id="将获取到的值做成图片的脚本">将获取到的值做成图片的脚本</span></h2><p>由于脚本执行环境是无图像的阿里云服务器，系统是<code>centos 7</code>，<code>ps.slow</code>这一步会爆错<code>RuntimeError: could not open display</code>，所以只能采取把生成的PNG图像文件保存到本地路径里的方法。脚本内容如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line">mpl.use('Agg')#在无法生成图像的环境下要添加了上面两句话</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pylab <span class="keyword">as</span> pl</span><br><span class="line"></span><br><span class="line">x=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>,<span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span>,<span class="number">24</span>]</span><br><span class="line">#横坐标的内容</span><br><span class="line">labels=[<span class="string">'10'</span>,<span class="string">'11'</span>,<span class="string">'12'</span>,<span class="string">'13'</span>,<span class="string">'14'</span>,<span class="string">'15'</span>,<span class="string">'16'</span>,<span class="string">'17'</span>,<span class="string">'18'</span>,<span class="string">'19'</span>,<span class="string">'20'</span>,<span class="string">'21'</span>,<span class="string">'22'</span>,<span class="string">'23'</span>,<span class="string">'24'</span>,<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>,<span class="string">'6'</span>,<span class="string">'7'</span>,<span class="string">'8'</span>,<span class="string">'9'</span>]</span><br><span class="line"></span><br><span class="line">#y1是delay延迟时长</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'/存储路径/A.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    y1 = []</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        lst = line.split('\n')#增加一个换行符，不然数字是不换行的</span><br><span class="line">        y1.append(float(lst[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">#y2是rate同步速率</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'/存储路径/B.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    y2 = []</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        lst = line.split(<span class="string">'\n'</span>)</span><br><span class="line">        y2.append(float(lst[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">#输入对应的坐标，后面是颜色</span><br><span class="line">plot1,=pl.plot(x,y1,<span class="string">'r'</span>)</span><br><span class="line">plot2,=pl.plot(x,y2,<span class="string">'b'</span>)</span><br><span class="line"></span><br><span class="line">pl.xticks(x,labels)</span><br><span class="line"></span><br><span class="line">pl.title('这里写标题',size=20)#中文会显示乱码，推荐还是英文</span><br><span class="line">pl.xlabel(<span class="string">'这里是X轴标题'</span>, size=<span class="number">14</span>)</span><br><span class="line">pl.ylabel(<span class="string">'这里写Y轴标题'</span>, size=<span class="number">14</span>)</span><br><span class="line">pl.ylim(<span class="number">0.0</span>,<span class="number">5.0</span>)</span><br><span class="line"></span><br><span class="line">#曲线对应注释</span><br><span class="line">pl.legend([plot1,plot2],(<span class="string">'Delay'</span>,<span class="string">'Sync rate'</span>),<span class="string">'best'</span>,numpoints=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">#开启网格</span><br><span class="line">pl.grid()</span><br><span class="line"></span><br><span class="line">#图片保存路径</span><br><span class="line">plt.savefig(<span class="string">'/保存路径/图片名称.png'</span>, format=<span class="string">'png'</span>)</span><br></pre></td></tr></table></figure></p><h2><span id="将生成的图片上传到阿里云oss的脚本">将生成的图片上传到阿里云OSS的脚本</span></h2><p>由于不想让“领导去手动点开附件查看图像”，所以我们干脆把图片作为邮件的正文展示出来，那么就在html里就需要<code>img src=图片的网络地址</code>的方法。于是就把刚刚生成的图片上传到阿里云OSS里，这样就可以获得图片的网络地址。而且阿里云OSS是“相同文件名会覆盖”，所以不用再去删除。整个脚本内容如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">import</span> oss2</span><br><span class="line"></span><br><span class="line">access_key_id = os.getenv(<span class="string">'OSS_TEST_ACCESS_KEY_ID'</span>, <span class="string">'这里填写ak'</span>)</span><br><span class="line">access_key_secret = os.getenv(<span class="string">'OSS_TEST_ACCESS_KEY_SECRET'</span>, <span class="string">'这里填写sk'</span>)</span><br><span class="line">bucket_name = os.getenv(<span class="string">'OSS_TEST_BUCKET'</span>, <span class="string">'这里填写bucket名称'</span>)</span><br><span class="line">endpoint = os.getenv(<span class="string">'OSS_TEST_ENDPOINT'</span>, <span class="string">'这里填写内网end-point'</span>)</span><br><span class="line"></span><br><span class="line"># 确认上面的参数都填写正确了</span><br><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> (access_key_id, access_key_secret, bucket_name, endpoint):</span><br><span class="line">    assert <span class="string">'&lt;'</span> not <span class="keyword">in</span> param, <span class="string">'请设置参数：'</span> + param</span><br><span class="line"></span><br><span class="line"># 创建Bucket对象，所有Object相关的接口都可以通过Bucket对象来进行</span><br><span class="line">bucket = oss2.Bucket(oss2.Auth(access_key_id, access_key_secret), endpoint, bucket_name)</span><br><span class="line">bucket.put_object_from_file(<span class="string">'上传到OSS的图片名称.png'</span>, <span class="string">'/服务器保存路径/图片名称.png'</span>)</span><br></pre></td></tr></table></figure></p><h2><span id="将图片作为内容发邮件的脚本">将图片作为内容发邮件的脚本</span></h2><p>整个脚本内容如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line"><span class="keyword">import</span> os,time,re,smtplib,logging</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.header <span class="keyword">import</span> Header</span><br><span class="line"></span><br><span class="line">def send_mail(to_list, cc_list, html, sub):</span><br><span class="line">    me = mail_user</span><br><span class="line">    msg = MIMEText(html, _subtype='html', _charset='utf-8')  # 格式化邮件内容为html，编码为utf-8</span><br><span class="line">    msg['Subject'] = sub    # 邮件主题</span><br><span class="line">    msg['From'] = me    # 发件人</span><br><span class="line">    msg['To'] = ";".join(to_list)  # 收件人，将列表转换为字符串</span><br><span class="line">    msg['Cc'] = ";".join(cc_list)  # 抄送人，将列表转换为字符串</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        send_smtp = smtplib.SMTP()    # 实例化</span><br><span class="line">        send_smtp.connect(mail_host)    # 连接smtp服务器</span><br><span class="line">        send_smtp.login(mail_user, mail_pass)    # 使用定义的账号密码进行登录</span><br><span class="line">        send_smtp.sendmail(me, to_list+cc_list, msg.as_string())    # 发送邮件</span><br><span class="line">        send_smtp.close()    # 关闭连接</span><br><span class="line">        <span class="keyword">return</span> True</span><br><span class="line">    except Exception, <span class="attr">e</span>:</span><br><span class="line">        logging.basicConfig(filename=<span class="string">'logger.log'</span>, level=logging.DEBUG)</span><br><span class="line">        logging.debug(e)</span><br><span class="line">        print (<span class="string">"ERROR!!!!"</span>)</span><br><span class="line">        <span class="keyword">return</span> False</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">   mail_host = <span class="string">'mail.dahuatech.com'</span></span><br><span class="line">   mail_user = <span class="string">'这里填写发件人地址'</span></span><br><span class="line">   mail_pass = <span class="string">'填写对应的密码'</span></span><br><span class="line">   mailto_list = [<span class="string">'收件人邮箱地址'</span>]</span><br><span class="line">   mailcc_list = [<span class="string">'抄送人1的邮箱地址'</span>，<span class="string">'抄送人2的邮箱地址'</span>]</span><br><span class="line">   html = <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">               &lt;body&gt; </span></span><br><span class="line"><span class="string">                &lt;br&gt;&lt;img src="</span>这里填写的是图片的http地址<span class="string">"&gt;&lt;/br&gt;</span></span><br><span class="line"><span class="string">               &lt;table color="</span>CCCC33<span class="string">" width="</span><span class="number">800</span><span class="string">" border="</span><span class="number">1</span><span class="string">" cellspacing="</span><span class="number">0</span><span class="string">" cellpadding="</span><span class="number">5</span><span class="string">" text-align="</span>center<span class="string">"&gt;</span></span><br><span class="line"><span class="string">                       &lt;tr&gt;</span></span><br><span class="line"><span class="string">                     &lt;td test-align="</span>center<span class="string">"&gt;上图是阿里云深圳VPC区数据同步过去24小时的情况。&lt;br /&gt;</span></span><br><span class="line"><span class="string">                     注意事项 1:dts的延迟时间是5秒计算一次，api请求会取到最新的延迟时间，而控制台是每隔20秒才刷新一次；</span></span><br><span class="line"><span class="string">                     注意事项 2:api在延迟时间取值为整数，即1.x显示为2，请知悉; </span></span><br><span class="line"><span class="string">                     注意事项 3:此邮件是系统自动发出，如果有任何疑问请联系运维人员；</span></span><br><span class="line"><span class="string">                       &lt;/tr&gt;&lt;/br&gt;</span></span><br><span class="line"><span class="string">               &lt;/table&gt;</span></span><br><span class="line"><span class="string">               &lt;/body&gt; "</span><span class="string">""</span></span><br><span class="line"></span><br><span class="line">    sub = <span class="string">"阿里云深圳VPC数据同步情况"</span></span><br><span class="line">    <span class="keyword">if</span> send_mail(mailto_list,mailcc_list,html,sub):</span><br><span class="line">        logging.debug(<span class="string">"Send mail succed!"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        logging.debug(<span class="string">"Send mail failed"</span>)</span><br></pre></td></tr></table></figure></p><p>上面四个脚本整个执行下来，效果如下，至此大功告成！<br><img src="/images/dts3.png" alt="paradin"></p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://github.com/aliyun/aliyun-oss-python-sdk/blob/master/examples/object_basic.py" target="_blank" rel="noopener">https://github.com/aliyun/aliyun-oss-python-sdk/blob/master/examples/object_basic.py</a><br><a href="https://hk.saowen.com/a/fe355cb5cc3ab17dbc84e9489621d2ab31da72b511092839832bc9e89d63bf71" target="_blank" rel="noopener">https://hk.saowen.com/a/fe355cb5cc3ab17dbc84e9489621d2ab31da72b511092839832bc9e89d63bf71</a><br><a href="http://blog.csdn.net/baoli1008/article/details/47980779" target="_blank" rel="noopener">http://blog.csdn.net/baoli1008/article/details/47980779</a><br><a href="https://www.digglife.net/articles/html-mail-with-inline-images-python-perl.html" target="_blank" rel="noopener">https://www.digglife.net/articles/html-mail-with-inline-images-python-perl.html</a></p>]]></content>
    
    <summary type="html">
    
      整个流程就一点不是很完美，就是matplotlib的中文显示是乱码
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>一个监控挂载盘的python脚本</title>
    <link href="http://yoursite.com/2018/02/27/%E4%B8%80%E4%B8%AA%E7%9B%91%E6%8E%A7%E6%8C%82%E8%BD%BD%E7%9B%98%E7%9A%84python%E8%84%9A%E6%9C%AC/"/>
    <id>http://yoursite.com/2018/02/27/一个监控挂载盘的python脚本/</id>
    <published>2018-02-27T15:08:09.000Z</published>
    <updated>2018-02-27T15:19:48.450Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="前言">前言</span></h2><p>公司产品线有一个公用的挂载盘，主要是用来方便各位开发人员去放置他们自己的一些工作材料，比如异常的日志或者<code>tcpdump</code>的抓包等等杂七杂八的东西，但是这个挂载盘由于使用人众多，容量自然要有监控，于是就有了写这个脚本的动机。</p><p>在这里我写了两个脚本，上面这个是用来监控磁盘容量，然后通过<code>df -h</code>的排序生成前十名占容量最大的文件夹，把这个文件夹的名字和对应的大小重定向到一个叫<code>alarm.txt</code>这个文件里，这个文件就是邮件正文。然后在确定他们的主人，统一加上公司邮箱后缀来得到他们主人的邮箱地址，最后对应他们各自的邮箱地址用下面那个脚本来发送文件夹容量过高的邮件。</p><h2><span id="监控挂载盘的脚本">监控挂载盘的脚本</span></h2><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line"># coding=utf-8</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> AutoMail</span><br><span class="line"><span class="keyword">import</span> commands</span><br><span class="line"></span><br><span class="line">#设定变量判断是否挂载和挂载盘的容量</span><br><span class="line">mount = commands.getoutput(<span class="string">"mount | grep ':.*nfs'|wc -l"</span>)</span><br><span class="line">size = commands.getoutput(<span class="string">"df -h | grep share | awk '&#123;print $5&#125;' | cut -d '%' -f 1"</span>)</span><br><span class="line"> </span><br><span class="line">##建立发邮件的文本文件</span><br><span class="line">def Createalarm():</span><br><span class="line">    <span class="keyword">if</span> os.path.exists(<span class="string">'/root/chenscript/alarm.txt'</span>) == True:</span><br><span class="line">        os.system(<span class="string">"python /root/chenscript/weixin_sharealarm.py"</span>)</span><br><span class="line">        print (<span class="string">"微信告警已经发送！"</span>)</span><br><span class="line">        os.system(<span class="string">"cd /root/chenscript; echo 'share盘容量大于80%，现在将调出容量排名前十位的文件夹名字及对应的容量，请各位处理一下不需要的文件！' &gt;/root/chenscript/alarm.txt"</span>)</span><br><span class="line">       os.system(<span class="string">"cd /挂载盘名称 ;du -s * --exclude='不想要计算在内的文件夹' --exclude='不想要计算在内的文件夹' --exclude='不想要计算在内的文件夹'|sort -nr |head &gt;&gt;/root/chenscript/alarm.txt"</span>)</span><br><span class="line">        os.system(<span class="string">"echo '\n' &gt;&gt; /root/chenscript/alarm.txt"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(<span class="string">'/root/chenscript/alarm.txt'</span>) == False:</span><br><span class="line">        os.system(<span class="string">"cd /root/chenscript;touch alarm.txt"</span>)</span><br><span class="line"></span><br><span class="line">def Sendmail():</span><br><span class="line">        fp = open(<span class="string">'/root/chenscript/alarm.txt'</span>, <span class="string">'r'</span>)</span><br><span class="line">        content = fp.read()</span><br><span class="line">        AutoMail.send_mail(<span class="string">'share挂载盘容量大于80%！收到邮件的各位请整理自己对应的文件夹！'</span>, content)</span><br><span class="line"> </span><br><span class="line">#将邮件的文件刷新</span><br><span class="line">def Dellist():</span><br><span class="line">        os.system(<span class="string">"cd /root/chenscript/;rm -f alarm.txt;touch alarm.txt"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> mount == <span class="string">'1'</span> and size &gt;= <span class="string">'80'</span>:</span><br><span class="line">        print (<span class="string">"挂载盘存在！"</span>)</span><br><span class="line">        print (<span class="string">"share盘容量大于80%..."</span>)</span><br><span class="line">        Createlist()</span><br><span class="line">        Sendmail()</span><br><span class="line">        Dellist()</span><br><span class="line">elif mount == <span class="string">'1'</span> and size &lt; <span class="string">'80'</span>:</span><br><span class="line">        print (<span class="string">"挂载盘存在！"</span>)</span><br><span class="line">        print (<span class="string">"share盘容量正常..."</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">       print (<span class="string">"挂载盘不存在，现在重新挂载..."</span>)</span><br><span class="line">       os.system(<span class="string">"mount -t nfs -o acl,rw,intr,soft,nolock,rsize=8192,wsize=8192 10.160.43.172:/share /share "</span>)</span><br></pre></td></tr></table></figure></code></pre><h2><span id="发送告警邮件脚本">发送告警邮件脚本</span></h2><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line">#coding=utf-8</span><br><span class="line">#这个脚本的用途是用来发送邮件</span><br><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"><span class="keyword">from</span> email.mime.multipart <span class="keyword">import</span> MIMEMultipart</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.mime.application <span class="keyword">import</span> MIMEApplication</span><br><span class="line"></span><br><span class="line">mailto_list=[]    #这里为空list，会从list.txt里一行一行的当做元素添加进来</span><br><span class="line"></span><br><span class="line">#生成list.txt</span><br><span class="line"><span class="keyword">if</span> os.path.exists(<span class="string">'/root/chenscript/list.txt'</span>) == True:</span><br><span class="line">        os.system(<span class="string">"cd /挂载盘名称;du -s * --exclude='不想要计算在内的文件夹' --exclude='不想要计算在内的文件夹' --exclude='不想要计算在内的文件夹'|sort -nr |head|awk \'&#123;print $2\"@dahuatech.com\"&#125;\'  &gt;&gt;/root/chenscript/list.txt"</span>)</span><br><span class="line"><span class="keyword">if</span> os.path.exists(<span class="string">'/root/chenscript/list.txt'</span>) == False:</span><br><span class="line">        os.system(<span class="string">"cd /root/chenscript/;rm -f list.txt;echo '本人的邮箱地址'&gt;list.txt"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'/root/chenscript/list.txt'</span>,<span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f=f.readlines()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> f:</span><br><span class="line">        i=i.strip(<span class="string">'\n'</span>)</span><br><span class="line">        mailto_list.append(i)</span><br><span class="line">mail_host=<span class="string">"这里填写邮箱主机"</span></span><br><span class="line">mail_user=<span class="string">"这里填写发送人的邮箱地址"</span></span><br><span class="line">mail_pass=<span class="string">"发送人的邮箱密码"</span></span><br><span class="line">mail_postfix=<span class="string">"dahuatech.com"</span></span><br><span class="line">mail_sender=<span class="string">"与mail_host内容相同"</span></span><br><span class="line">def send_mail(sub, content):</span><br><span class="line">    me=mail_sender</span><br><span class="line">    msg = MIMEMultipart()</span><br><span class="line">    msg[<span class="string">'Subject'</span>] = sub</span><br><span class="line">    msg[<span class="string">'From'</span>] = me</span><br><span class="line">    msg[<span class="string">'To'</span>] = <span class="string">";"</span>.join(mailto_list)</span><br><span class="line">    content1 = MIMEText(str(content), <span class="string">'plain'</span>, <span class="string">'utf-8'</span>)</span><br><span class="line">    msg.attach(content1)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        s = smtplib.SMTP()</span><br><span class="line">        s.connect(mail_host)</span><br><span class="line">        s.login(mail_user,mail_pass)</span><br><span class="line">        s.sendmail(me, mailto_list, msg.as_string())</span><br><span class="line">        print(<span class="string">'发送成功！\n'</span>)</span><br><span class="line">        s.close()</span><br><span class="line">    except Exception <span class="keyword">as</span> e: print(str(e))</span><br><span class="line"></span><br><span class="line">os.system(<span class="string">"cd /root/chenscript/;rm -f list.txt;echo '我本人的邮件地址'&gt;list.txt"</span>)</span><br></pre></td></tr></table></figure></code></pre><p>执行的效果如下：<br><img src="/images/gaojingmail1.png" alt="paradin"></p><h2><span id="隐藏的知识点">隐藏的知识点</span></h2><p>1）<code>du -s</code>是按照字节来统计，<code>--exclude=&#39;yunwei&#39;</code>是在排序的时候忽略掉<code>yunwei</code>这个文件夹，容后再用<code>sort -nr|head</code>是得到从大到小前10名，如果得到后10名就是<code>sort -nr|tail</code>；<br>2）如果使用的是<code>import commands</code>，那么<code>commands.getoutpu</code>t得到的是字符串！<br>3）用<code>mount | grep &#39;:.*nfs&#39;</code>来判断挂载盘是否存在是一个很简单的方式，如果挂了多个，就用<code>ip in</code>的方式来进一步判断；<br>4）python要一行一行的读取文件，就<code>readline</code>；<br>5）python按行读取文件，去掉换行符<code>\n</code>的方法：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> file.readlines():</span><br><span class="line">    line=line.strip(<span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure></p><p>6）<code>import Automail</code>的时候，就已经把<code>Automail.py</code>这个脚本固定住了，这时候<code>mailto_list</code>已经不能变化了，所以要把添加<code>list.txt</code>放到这个脚本里。<br><img src="/images/gaojingmail2.png" alt="paradin"></p><p>发了邮件，连吼带骂一顿，终于把share盘容量下降到了69这样一个美妙的数字…</p>]]></content>
    
    <summary type="html">
    
      将监控进行到无死角
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>使用matplotlib画图的一个脚本</title>
    <link href="http://yoursite.com/2018/02/27/%E4%BD%BF%E7%94%A8matplotlib%E7%94%BB%E5%9B%BE%E7%9A%84%E4%B8%80%E4%B8%AA%E8%84%9A%E6%9C%AC/"/>
    <id>http://yoursite.com/2018/02/27/使用matplotlib画图的一个脚本/</id>
    <published>2018-02-27T10:50:24.000Z</published>
    <updated>2018-02-27T13:33:18.045Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="准备工作">准备工作</span></h2><p>之前在<a href="https://rorschachchan.github.io/2018/02/24/阿里云获取DTS服务延迟的脚本/" target="_blank" rel="noopener">https://rorschachchan.github.io/2018/02/24/阿里云获取DTS服务延迟的脚本/</a> 里已经可以获取到阿里云DTS服务的延迟时长和同步速率。下一步就是把这些值以24小时为周期作一个图像，然后每天在固定时间发送到领导们的邮件里。</p><p>python作图的第三方工具叫<code>matplotlib</code>，安装步骤如下：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pip install matplotlib#画图模块</span><br><span class="line">pip install numpy#依赖的库</span><br><span class="line">pip install scipy#又一个依赖的库</span><br><span class="line">yum install -y Tkinter#如果是python3，那么就是yum install -y tkinter</span><br></pre></td></tr></table></figure></p><h2><span id="脚本内容">脚本内容</span></h2><p>由于我是在<code>centos 7</code>里进行脚本操作，而linux服务器有没有安装图像，所以在执行<code>import matplotlib.pyplot as plt</code>的时候可能会爆错：<code>RuntimeError: could not open display</code>，这个时候需要在前面改成如下样式（注意先后顺序）：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line">mpl.use(<span class="string">'Agg'</span>)</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure></p><p>举一个简单的脚本例子如下，就是给予（x,y）然后连成曲线图的效果，脚本里数字的部分不加引号也是可以识别的，当然使用变量也可以。<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line">mpl.use(<span class="string">'Agg'</span>)</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line"><span class="keyword">import</span> pylab <span class="keyword">as</span> pl  </span><br><span class="line"> </span><br><span class="line">x=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>,<span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span>,<span class="number">24</span>]</span><br><span class="line">#横坐标的内容</span><br><span class="line">labels=[<span class="string">'10'</span>,<span class="string">'11'</span>,<span class="string">'12'</span>,<span class="string">'13'</span>,<span class="string">'14'</span>,<span class="string">'15'</span>,<span class="string">'16'</span>,<span class="string">'17'</span>,<span class="string">'18'</span>,<span class="string">'19'</span>,<span class="string">'20'</span>,<span class="string">'21'</span>,<span class="string">'22'</span>,<span class="string">'23'</span>,<span class="string">'24'</span>,<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>,<span class="string">'6'</span>,<span class="string">'7'</span>,<span class="string">'8'</span>,<span class="string">'9'</span>]</span><br><span class="line"></span><br><span class="line">a = <span class="string">'1'</span></span><br><span class="line">b = <span class="string">'2'</span></span><br><span class="line">c = <span class="string">'3'</span></span><br><span class="line">d = <span class="string">'4'</span></span><br><span class="line"></span><br><span class="line">#y1是延迟</span><br><span class="line">y1=[<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'5'</span>,<span class="string">'4'</span>,<span class="string">'2'</span>,<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'5'</span>,<span class="string">'4'</span>,<span class="string">'2'</span>,<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'5'</span>,<span class="string">'4'</span>,<span class="string">'2'</span>,<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'5'</span>]</span><br><span class="line"></span><br><span class="line">#y2是同步速率</span><br><span class="line">y2=[a,b,c,d,<span class="number">0.13</span>,<span class="number">0.12</span>,<span class="number">0.14</span>,<span class="number">0.14</span>,<span class="number">0.14</span>,<span class="number">0.16</span>,<span class="number">0.15</span>,<span class="number">0.13</span>,<span class="number">0.12</span>,<span class="number">0.14</span>,<span class="number">0.14</span>,<span class="number">0.14</span>,<span class="number">0.16</span>,<span class="number">0.15</span>,<span class="number">0.13</span>,<span class="number">0.12</span>,<span class="number">0.14</span>,<span class="number">0.22</span>,<span class="number">0.18</span>,<span class="number">0.11</span>]</span><br><span class="line"></span><br><span class="line">#输入对应的坐标，后面是颜色</span><br><span class="line">plot1,=pl.plot(x,y1,'r')#这里是有逗号的，用于参数解包</span><br><span class="line">plot2,=pl.plot(x,y2,<span class="string">'b'</span>)  </span><br><span class="line">pl.xticks(x,labels)</span><br><span class="line"></span><br><span class="line">#图片的标题以及对应的字号大小</span><br><span class="line">pl.title(<span class="string">'The DTS status of Shenzhen VPC'</span>,size=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">#X轴的标题和字号大小</span><br><span class="line">pl.xlabel(<span class="string">'Time'</span>, size=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line">#Y轴的标题，字号大小和长度</span><br><span class="line">pl.xlabel(<span class="string">'Time'</span>, size=<span class="number">14</span>)</span><br><span class="line">pl.ylim(<span class="number">0.0</span>,<span class="number">5.0</span>)</span><br><span class="line"></span><br><span class="line">#曲线对应注释</span><br><span class="line">pl.legend([plot1,plot2],(<span class="string">'Delay'</span>,<span class="string">'Sync rate'</span>),<span class="string">'best'</span>,numpoints=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">#图片保存路径</span><br><span class="line">plt.savefig(<span class="string">'/tmp/dts.png'</span>, format=<span class="string">'png'</span>)</span><br></pre></td></tr></table></figure></p><p>脚本执行效果之后，会在对应的路径里生成一个图片文件，然后把这个图片转移到windows，打开就看到效果了，如图：<br><img src="/images/dts.png" alt="paradin"></p><p>这个图是全英文的，如果是中文的话，就会出现乱码，研究了半天也没搞明白，这一点让我很郁闷。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="http://python.jobbole.com/81182/" target="_blank" rel="noopener">http://python.jobbole.com/81182/</a><br><a href="https://absentm.github.io/2017/03/18/Python-matplotlib-数据可视化/" target="_blank" rel="noopener">https://absentm.github.io/2017/03/18/Python-matplotlib-数据可视化/</a><br><a href="https://liam0205.me/2014/09/11/matplotlib-tutorial-zh-cn/" target="_blank" rel="noopener">https://liam0205.me/2014/09/11/matplotlib-tutorial-zh-cn/</a><br><a href="https://morvanzhou.github.io/tutorials/data-manipulation/plt/1-1-why/" target="_blank" rel="noopener">https://morvanzhou.github.io/tutorials/data-manipulation/plt/1-1-why/</a><br><a href="https://www.lookfor404.com/%E8%BF%90%E8%A1%8Cggplot%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98no-display-name-and-no-display-environment-variable/" target="_blank" rel="noopener">https://www.lookfor404.com/%E8%BF%90%E8%A1%8Cggplot%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98no-display-name-and-no-display-environment-variable/</a></p>]]></content>
    
    <summary type="html">
    
      插播一句题外话：将域名解析到IP的其他端口的方法是通过一个临时域名来配置“隐性url”
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>解决https证书在赛门铁克认证失败的问题</title>
    <link href="http://yoursite.com/2018/02/26/%E8%A7%A3%E5%86%B3https%E8%AF%81%E4%B9%A6%E5%9C%A8%E8%B5%9B%E9%97%A8%E9%93%81%E5%85%8B%E8%AE%A4%E8%AF%81%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/02/26/解决https证书在赛门铁克认证失败的问题/</id>
    <published>2018-02-26T14:40:03.000Z</published>
    <updated>2018-02-27T06:57:58.892Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="问题描述">问题描述</span></h2><p>今天电子商城的市场接到一个故障，说更换了.lechange.com的https证书（原有的证书到期了，新买了一个依旧还是.lehcange.com域名证书）之后，订单在支付宝支付的时候提示支付失败。我把<code>request id</code>提供给支付宝的客服请他们查看一下后台，支付宝客服说我们电商的https证书没有认证成功。于是我就登陆<a href="https://cryptoreport.websecurity.symantec.com/checker/" target="_blank" rel="noopener">https://cryptoreport.websecurity.symantec.com/checker/</a> 去检查一下电商的域名，果不其然，赛门铁克的反馈是错误的，如图：<br><img src="/images/saimentieke1.png" alt="paradin"></p><p>但是登陆网站，在浏览器里却显示https证书是OK的，如图：<br><img src="/images/saimentieke2.png" alt="paradin"></p><p>然后我用<code>symantec</code>的那个网站测试了一下电商平台开发环境的域名，发现也是OK的，如图：<br><img src="/images/saimentieke3.png" alt="paradin"></p><p>这就郁闷了，到底哪里出问题了？</p><h2><span id="问题排查">问题排查</span></h2><p>首先跟研发确认，开发环境与线上环境在涉及到证书的代码是否一致，得到研发的确认之后。就检查服务器里的<code>nginx</code>，发现服务器<code>nginx</code>的配置文件里是没有涉及到<code>ssl</code>，无论是开发环境和线上环境都是通过阿里云slb配置的https证书。而且两者的证书指纹一模一样，如图：<br><img src="/images/saimentieke4.png" alt="paradin"></p><p>既然都是用的一样的证书，为啥一个检验通过，另一个检验不通过呢？这个时候我想到线上环境与开发环境唯一的不同就是线上环境多了一个cdn，于是就登陆到cdn的控制页面，找到对应的https证书，发现cdn的https证书指纹也是跟上面的指纹一样，如图：<br><img src="/images/saimentieke5.png" alt="paradin"></p><p>既然指纹一样，那证书也应该是一样的，场面又进入了一个僵局。</p><p>于是我就到一台服务器里使用<code>curl -vv https://www.lechange.com</code>，看到的结果如下：<br><img src="/images/saimentieke6.png" alt="paradin"></p><p>提示<code>未配置签发者根证书</code>，我这时候想起来了，<font color="red">首先证书指纹一致不能说明证书是完全一致的，只能说明key文件是一样的！</font>其次这个https证书是中级机构证书，那么中级机构颁发的证书链规则是这样的：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-----BEGIN CERTIFICATE-----</span><br><span class="line"></span><br><span class="line">-----END CERTIFICATE-----</span><br><span class="line"></span><br><span class="line">-----BEGIN CERTIFICATE-----</span><br><span class="line"></span><br><span class="line">-----END CERTIFICATE-----</span><br></pre></td></tr></table></figure></p><p>那么我怀疑就是https证书链那部分可能在cdn配置错误了，或许在slb配置错误了，甚至两个都配置错误了！</p><p>于是干脆删除掉线上电商原有的https证书，重新导入cdn和slb的https证书，返回到<code>symantec</code>刷新，这次的检验结果就OK了。<br><img src="/images/saimentieke7.png" alt="paradin"></p><h2><span id="补充">补充</span></h2><p>虽然这个问题解决了，但是我还是不明白，为什么在网页端查看证书是绿色OK的呢？在<code>sf.gg</code>上提问之后，一个叫Avro的朋友是这么回答我的：</p><blockquote><p>以chrome为例，他信任了[所在平台的信任证书列表][1]，而这些平台集成了一系列信任的根证书，如iOS 11 中可用的受信任根证书列表可以找到你的根证书“04 00 00 00 00 01 15 4B 5A C3 94 ”(序列号)，因此验证过程中没有问题，而对于其他的工具，如果未使用这些平台根证书信任列表依然需要完整的证书链（这个证书链在ssl握手过程中被下发）进行校验。</p></blockquote><h2><span id="参考资料">参考资料</span></h2><p><a href="https://openclub.alipay.com/read.php?tid=3451&amp;fid=57&amp;page=1" target="_blank" rel="noopener">https://openclub.alipay.com/read.php?tid=3451&amp;fid=57&amp;page=1</a><br><a href="https://www.jianshu.com/p/84af353f43c5" target="_blank" rel="noopener">https://www.jianshu.com/p/84af353f43c5</a><br><a href="https://help.aliyun.com/knowledge_detail/39468.html?spm=a2c4g.11186631.2.2.w2qcWT" target="_blank" rel="noopener">https://help.aliyun.com/knowledge_detail/39468.html?spm=a2c4g.11186631.2.2.w2qcWT</a></p>]]></content>
    
    <summary type="html">
    
      搞了半天其实就是https证书没弄对...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="https证书" scheme="http://yoursite.com/tags/https%E8%AF%81%E4%B9%A6/"/>
    
  </entry>
  
</feed>
