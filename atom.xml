<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chris Chan&#39;s BLOG</title>
  
  <subtitle>那些在阳光下挥洒青春的日子啊！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-02-28T15:27:54.743Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Chris Chan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>调用阿里云api获取阿里云数据同步服务（DTS）并且作图发送邮件的整个流程</title>
    <link href="http://yoursite.com/2018/02/28/%E8%B0%83%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91api%E8%8E%B7%E5%8F%96%E9%98%BF%E9%87%8C%E4%BA%91%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E6%9C%8D%E5%8A%A1%EF%BC%88DTS%EF%BC%89%E5%B9%B6%E4%B8%94%E4%BD%9C%E5%9B%BE%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E7%9A%84%E6%95%B4%E4%B8%AA%E6%B5%81%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/02/28/调用阿里云api获取阿里云数据同步服务（DTS）并且作图发送邮件的整个流程/</id>
    <published>2018-02-28T15:00:20.000Z</published>
    <updated>2018-02-28T15:27:54.743Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="前言">前言</span></h2><p>在<a href="https://rorschachchan.github.io/2018/02/24/阿里云获取DTS服务延迟的脚本/" target="_blank" rel="noopener">https://rorschachchan.github.io/2018/02/24/阿里云获取DTS服务延迟的脚本/</a> 文章里已经说了“领导要求每天查看阿里云dts同步的延迟情况和同步速率情况”，并且在<a href="https://rorschachchan.github.io/2018/02/27/使用matplotlib画图的一个脚本/" target="_blank" rel="noopener">https://rorschachchan.github.io/2018/02/27/使用matplotlib画图的一个脚本/</a> 里面也放了一个使用<code>python matplotlib</code>画图的demo，这篇文章的目的就是把整个过程实现，并且把dts图形以每日邮件的形式发送给领导的效果！</p><h2><span id="实现需求的思路">实现需求的思路</span></h2><p>本次需求有四个动作，分别是<code>获取一天以内的DTS延迟和同步速率</code>、<code>将获取到的DTS值做成PNG图像</code>、<code>将生成的PNG图像上传到阿里云云存储OSS</code>、<code>把图片展示到邮件里并发送给相关领导</code>。由于第一步<code>获取一天以内的DTS延迟和同步速率</code>需要将这个脚本每小时执行一次，执行24次，才可以执行<code>生成png图像</code>这一步，所以后三个其实可以写成一个大脚本。不过在本文为了表述的清楚，就把各自不同用途写成了不同的脚本。</p><h2><span id="获取阿里云dts延迟和同步速率的脚本">获取阿里云DTS延迟和同步速率的脚本</span></h2><p>这个脚本之前写过了，这里再拿出来晒一遍：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line">#coding=utf-8</span><br><span class="line">#这个脚本是用来获取dts延迟数字的</span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore <span class="keyword">import</span> client</span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore.acs_exception.exceptions <span class="keyword">import</span> ClientException</span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore.acs_exception.exceptions <span class="keyword">import</span> ServerException</span><br><span class="line"><span class="keyword">import</span> time,json,sys</span><br><span class="line">sys.path.append('/解压缩路径/aliyunsdkdts/request/v20160801/')#这里看不懂去看https://rorschachchan.github.io/2018/02/24/阿里云获取DTS服务延迟的脚本/</span><br><span class="line"><span class="keyword">import</span> DescribeSynchronizationJobStatusRequest</span><br><span class="line"></span><br><span class="line"># 创建 Client 实例</span><br><span class="line">clt = client.AcsClient(<span class="string">'这里填写ak'</span>,<span class="string">'这里填写sk'</span>,<span class="string">'cn-shenzhen'</span>)</span><br><span class="line"></span><br><span class="line"># 创建 request，并设置参数</span><br><span class="line">request = DescribeSynchronizationJobStatusRequest.DescribeSynchronizationJobStatusRequest()</span><br><span class="line">request.set_SynchronizationJobId(<span class="string">"这里填写DTS的ID号"</span>)</span><br><span class="line"></span><br><span class="line">response = clt.do_action_with_exception(request)</span><br><span class="line"></span><br><span class="line">delay = json.loads(response)</span><br><span class="line">rate = str(delay["Performance"]["FLOW"])[0:4]#由于同步速率默认是带单位的，这里就取前四位</span><br><span class="line"></span><br><span class="line">#用A.txt来存储延迟时长</span><br><span class="line">fd = open(<span class="string">"/存储路径/A.txt"</span>,<span class="string">"a"</span>)</span><br><span class="line">fd.write(str(delay[<span class="string">"DataSynchronizationStatus"</span>][<span class="string">"Delay"</span>]))</span><br><span class="line">fd.write(<span class="string">'\n'</span>)</span><br><span class="line">fd.close()</span><br><span class="line"></span><br><span class="line">#用B.txt来存储同步速率</span><br><span class="line">fr = open(<span class="string">"/存储路径/rate.txt"</span>,<span class="string">"a"</span>)</span><br><span class="line">fr.write(rate)</span><br><span class="line">fr.write(<span class="string">'\n'</span>)</span><br><span class="line">fr.close()</span><br></pre></td></tr></table></figure></p><h2><span id="将获取到的值做成图片的脚本">将获取到的值做成图片的脚本</span></h2><p>由于脚本执行环境是无图像的阿里云服务器，系统是<code>centos 7</code>，<code>ps.slow</code>这一步会爆错<code>RuntimeError: could not open display</code>，所以只能采取把生成的PNG图像文件保存到本地路径里的方法。脚本内容如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line">mpl.use('Agg')#在无法生成图像的环境下要添加了上面两句话</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pylab <span class="keyword">as</span> pl</span><br><span class="line"></span><br><span class="line">x=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>,<span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span>,<span class="number">24</span>]</span><br><span class="line">#横坐标的内容</span><br><span class="line">labels=[<span class="string">'10'</span>,<span class="string">'11'</span>,<span class="string">'12'</span>,<span class="string">'13'</span>,<span class="string">'14'</span>,<span class="string">'15'</span>,<span class="string">'16'</span>,<span class="string">'17'</span>,<span class="string">'18'</span>,<span class="string">'19'</span>,<span class="string">'20'</span>,<span class="string">'21'</span>,<span class="string">'22'</span>,<span class="string">'23'</span>,<span class="string">'24'</span>,<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>,<span class="string">'6'</span>,<span class="string">'7'</span>,<span class="string">'8'</span>,<span class="string">'9'</span>]</span><br><span class="line"></span><br><span class="line">#y1是delay延迟时长</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'/存储路径/A.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    y1 = []</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        lst = line.split('\n')#增加一个换行符，不然数字是不换行的</span><br><span class="line">        y1.append(float(lst[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">#y2是rate同步速率</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'/存储路径/B.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    y2 = []</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        lst = line.split(<span class="string">'\n'</span>)</span><br><span class="line">        y2.append(float(lst[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">#输入对应的坐标，后面是颜色</span><br><span class="line">plot1,=pl.plot(x,y1,<span class="string">'r'</span>)</span><br><span class="line">plot2,=pl.plot(x,y2,<span class="string">'b'</span>)</span><br><span class="line"></span><br><span class="line">pl.xticks(x,labels)</span><br><span class="line"></span><br><span class="line">pl.title('这里写标题',size=20)#中文会显示乱码，推荐还是英文</span><br><span class="line">pl.xlabel(<span class="string">'这里是X轴标题'</span>, size=<span class="number">14</span>)</span><br><span class="line">pl.ylabel(<span class="string">'这里写Y轴标题'</span>, size=<span class="number">14</span>)</span><br><span class="line">pl.ylim(<span class="number">0.0</span>,<span class="number">5.0</span>)</span><br><span class="line"></span><br><span class="line">#曲线对应注释</span><br><span class="line">pl.legend([plot1,plot2],(<span class="string">'Delay'</span>,<span class="string">'Sync rate'</span>),<span class="string">'best'</span>,numpoints=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">#开启网格</span><br><span class="line">pl.grid()</span><br><span class="line"></span><br><span class="line">#图片保存路径</span><br><span class="line">plt.savefig(<span class="string">'/保存路径/图片名称.png'</span>, format=<span class="string">'png'</span>)</span><br></pre></td></tr></table></figure></p><h2><span id="将生成的图片上传到阿里云oss的脚本">将生成的图片上传到阿里云OSS的脚本</span></h2><p>由于不想让“领导去手动点开附件查看图像”，所以我们干脆把图片作为邮件的正文展示出来，那么就在html里就需要<code>img src=图片的网络地址</code>的方法。于是就把刚刚生成的图片上传到阿里云OSS里，这样就可以获得图片的网络地址。而且阿里云OSS是“相同文件名会覆盖”，所以不用再去删除。整个脚本内容如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">import</span> oss2</span><br><span class="line"></span><br><span class="line">access_key_id = os.getenv(<span class="string">'OSS_TEST_ACCESS_KEY_ID'</span>, <span class="string">'这里填写ak'</span>)</span><br><span class="line">access_key_secret = os.getenv(<span class="string">'OSS_TEST_ACCESS_KEY_SECRET'</span>, <span class="string">'这里填写sk'</span>)</span><br><span class="line">bucket_name = os.getenv(<span class="string">'OSS_TEST_BUCKET'</span>, <span class="string">'这里填写bucket名称'</span>)</span><br><span class="line">endpoint = os.getenv(<span class="string">'OSS_TEST_ENDPOINT'</span>, <span class="string">'这里填写内网end-point'</span>)</span><br><span class="line"></span><br><span class="line"># 确认上面的参数都填写正确了</span><br><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> (access_key_id, access_key_secret, bucket_name, endpoint):</span><br><span class="line">    assert <span class="string">'&lt;'</span> not <span class="keyword">in</span> param, <span class="string">'请设置参数：'</span> + param</span><br><span class="line"></span><br><span class="line"># 创建Bucket对象，所有Object相关的接口都可以通过Bucket对象来进行</span><br><span class="line">bucket = oss2.Bucket(oss2.Auth(access_key_id, access_key_secret), endpoint, bucket_name)</span><br><span class="line">bucket.put_object_from_file(<span class="string">'上传到OSS的图片名称.png'</span>, <span class="string">'/服务器保存路径/图片名称.png'</span>)</span><br></pre></td></tr></table></figure></p><h2><span id="将图片作为内容发邮件的脚本">将图片作为内容发邮件的脚本</span></h2><p>整个脚本内容如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line"><span class="keyword">import</span> os,time,re,smtplib,logging</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.header <span class="keyword">import</span> Header</span><br><span class="line"></span><br><span class="line">def send_mail(to_list, cc_list, html, sub):</span><br><span class="line">    me = mail_user</span><br><span class="line">    msg = MIMEText(html, _subtype='html', _charset='utf-8')  # 格式化邮件内容为html，编码为utf-8</span><br><span class="line">    msg['Subject'] = sub    # 邮件主题</span><br><span class="line">    msg['From'] = me    # 发件人</span><br><span class="line">    msg['To'] = ";".join(to_list)  # 收件人，将列表转换为字符串</span><br><span class="line">    msg['Cc'] = ";".join(cc_list)  # 抄送人，将列表转换为字符串</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        send_smtp = smtplib.SMTP()    # 实例化</span><br><span class="line">        send_smtp.connect(mail_host)    # 连接smtp服务器</span><br><span class="line">        send_smtp.login(mail_user, mail_pass)    # 使用定义的账号密码进行登录</span><br><span class="line">        send_smtp.sendmail(me, to_list+cc_list, msg.as_string())    # 发送邮件</span><br><span class="line">        send_smtp.close()    # 关闭连接</span><br><span class="line">        <span class="keyword">return</span> True</span><br><span class="line">    except Exception, <span class="attr">e</span>:</span><br><span class="line">        logging.basicConfig(filename=<span class="string">'logger.log'</span>, level=logging.DEBUG)</span><br><span class="line">        logging.debug(e)</span><br><span class="line">        print (<span class="string">"ERROR!!!!"</span>)</span><br><span class="line">        <span class="keyword">return</span> False</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">   mail_host = <span class="string">'mail.dahuatech.com'</span></span><br><span class="line">   mail_user = <span class="string">'这里填写发件人地址'</span></span><br><span class="line">   mail_pass = <span class="string">'填写对应的密码'</span></span><br><span class="line">   mailto_list = [<span class="string">'收件人邮箱地址'</span>]</span><br><span class="line">   mailcc_list = [<span class="string">'抄送人1的邮箱地址'</span>，<span class="string">'抄送人2的邮箱地址'</span>]</span><br><span class="line">   html = <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">               &lt;body&gt; </span></span><br><span class="line"><span class="string">                &lt;br&gt;&lt;img src="</span>这里填写的是图片的http地址<span class="string">"&gt;&lt;/br&gt;</span></span><br><span class="line"><span class="string">               &lt;table color="</span>CCCC33<span class="string">" width="</span><span class="number">800</span><span class="string">" border="</span><span class="number">1</span><span class="string">" cellspacing="</span><span class="number">0</span><span class="string">" cellpadding="</span><span class="number">5</span><span class="string">" text-align="</span>center<span class="string">"&gt;</span></span><br><span class="line"><span class="string">                       &lt;tr&gt;</span></span><br><span class="line"><span class="string">                     &lt;td test-align="</span>center<span class="string">"&gt;上图是阿里云深圳VPC区数据同步过去24小时的情况。&lt;br /&gt;</span></span><br><span class="line"><span class="string">                     注意事项 1:dts的延迟时间是5秒计算一次，api请求会取到最新的延迟时间，而控制台是每隔20秒才刷新一次；</span></span><br><span class="line"><span class="string">                     注意事项 2:api在延迟时间取值为整数，即1.x显示为2，请知悉; </span></span><br><span class="line"><span class="string">                     注意事项 3:此邮件是系统自动发出，如果有任何疑问请联系运维人员；</span></span><br><span class="line"><span class="string">                       &lt;/tr&gt;&lt;/br&gt;</span></span><br><span class="line"><span class="string">               &lt;/table&gt;</span></span><br><span class="line"><span class="string">               &lt;/body&gt; "</span><span class="string">""</span></span><br><span class="line"></span><br><span class="line">    sub = <span class="string">"阿里云深圳VPC数据同步情况"</span></span><br><span class="line">    <span class="keyword">if</span> send_mail(mailto_list,mailcc_list,html,sub):</span><br><span class="line">        logging.debug(<span class="string">"Send mail succed!"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        logging.debug(<span class="string">"Send mail failed"</span>)</span><br></pre></td></tr></table></figure></p><p>上面四个脚本整个执行下来，效果如下，至此大功告成！<br><img src="/images/dts3.png" alt="paradin"></p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://github.com/aliyun/aliyun-oss-python-sdk/blob/master/examples/object_basic.py" target="_blank" rel="noopener">https://github.com/aliyun/aliyun-oss-python-sdk/blob/master/examples/object_basic.py</a><br><a href="https://hk.saowen.com/a/fe355cb5cc3ab17dbc84e9489621d2ab31da72b511092839832bc9e89d63bf71" target="_blank" rel="noopener">https://hk.saowen.com/a/fe355cb5cc3ab17dbc84e9489621d2ab31da72b511092839832bc9e89d63bf71</a><br><a href="http://blog.csdn.net/baoli1008/article/details/47980779" target="_blank" rel="noopener">http://blog.csdn.net/baoli1008/article/details/47980779</a><br><a href="https://www.digglife.net/articles/html-mail-with-inline-images-python-perl.html" target="_blank" rel="noopener">https://www.digglife.net/articles/html-mail-with-inline-images-python-perl.html</a></p>]]></content>
    
    <summary type="html">
    
      整个流程就一点不是很完美，就是matplotlib的中文显示是乱码
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>一个监控挂载盘的python脚本</title>
    <link href="http://yoursite.com/2018/02/27/%E4%B8%80%E4%B8%AA%E7%9B%91%E6%8E%A7%E6%8C%82%E8%BD%BD%E7%9B%98%E7%9A%84python%E8%84%9A%E6%9C%AC/"/>
    <id>http://yoursite.com/2018/02/27/一个监控挂载盘的python脚本/</id>
    <published>2018-02-27T15:08:09.000Z</published>
    <updated>2018-02-27T15:19:48.450Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="前言">前言</span></h2><p>公司产品线有一个公用的挂载盘，主要是用来方便各位开发人员去放置他们自己的一些工作材料，比如异常的日志或者<code>tcpdump</code>的抓包等等杂七杂八的东西，但是这个挂载盘由于使用人众多，容量自然要有监控，于是就有了写这个脚本的动机。</p><p>在这里我写了两个脚本，上面这个是用来监控磁盘容量，然后通过<code>df -h</code>的排序生成前十名占容量最大的文件夹，把这个文件夹的名字和对应的大小重定向到一个叫<code>alarm.txt</code>这个文件里，这个文件就是邮件正文。然后在确定他们的主人，统一加上公司邮箱后缀来得到他们主人的邮箱地址，最后对应他们各自的邮箱地址用下面那个脚本来发送文件夹容量过高的邮件。</p><h2><span id="监控挂载盘的脚本">监控挂载盘的脚本</span></h2><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line"># coding=utf-8</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> AutoMail</span><br><span class="line"><span class="keyword">import</span> commands</span><br><span class="line"></span><br><span class="line">#设定变量判断是否挂载和挂载盘的容量</span><br><span class="line">mount = commands.getoutput(<span class="string">"mount | grep ':.*nfs'|wc -l"</span>)</span><br><span class="line">size = commands.getoutput(<span class="string">"df -h | grep share | awk '&#123;print $5&#125;' | cut -d '%' -f 1"</span>)</span><br><span class="line"> </span><br><span class="line">##建立发邮件的文本文件</span><br><span class="line">def Createalarm():</span><br><span class="line">    <span class="keyword">if</span> os.path.exists(<span class="string">'/root/chenscript/alarm.txt'</span>) == True:</span><br><span class="line">        os.system(<span class="string">"python /root/chenscript/weixin_sharealarm.py"</span>)</span><br><span class="line">        print (<span class="string">"微信告警已经发送！"</span>)</span><br><span class="line">        os.system(<span class="string">"cd /root/chenscript; echo 'share盘容量大于80%，现在将调出容量排名前十位的文件夹名字及对应的容量，请各位处理一下不需要的文件！' &gt;/root/chenscript/alarm.txt"</span>)</span><br><span class="line">       os.system(<span class="string">"cd /挂载盘名称 ;du -s * --exclude='不想要计算在内的文件夹' --exclude='不想要计算在内的文件夹' --exclude='不想要计算在内的文件夹'|sort -nr |head &gt;&gt;/root/chenscript/alarm.txt"</span>)</span><br><span class="line">        os.system(<span class="string">"echo '\n' &gt;&gt; /root/chenscript/alarm.txt"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(<span class="string">'/root/chenscript/alarm.txt'</span>) == False:</span><br><span class="line">        os.system(<span class="string">"cd /root/chenscript;touch alarm.txt"</span>)</span><br><span class="line"></span><br><span class="line">def Sendmail():</span><br><span class="line">        fp = open(<span class="string">'/root/chenscript/alarm.txt'</span>, <span class="string">'r'</span>)</span><br><span class="line">        content = fp.read()</span><br><span class="line">        AutoMail.send_mail(<span class="string">'share挂载盘容量大于80%！收到邮件的各位请整理自己对应的文件夹！'</span>, content)</span><br><span class="line"> </span><br><span class="line">#将邮件的文件刷新</span><br><span class="line">def Dellist():</span><br><span class="line">        os.system(<span class="string">"cd /root/chenscript/;rm -f alarm.txt;touch alarm.txt"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> mount == <span class="string">'1'</span> and size &gt;= <span class="string">'80'</span>:</span><br><span class="line">        print (<span class="string">"挂载盘存在！"</span>)</span><br><span class="line">        print (<span class="string">"share盘容量大于80%..."</span>)</span><br><span class="line">        Createlist()</span><br><span class="line">        Sendmail()</span><br><span class="line">        Dellist()</span><br><span class="line">elif mount == <span class="string">'1'</span> and size &lt; <span class="string">'80'</span>:</span><br><span class="line">        print (<span class="string">"挂载盘存在！"</span>)</span><br><span class="line">        print (<span class="string">"share盘容量正常..."</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">       print (<span class="string">"挂载盘不存在，现在重新挂载..."</span>)</span><br><span class="line">       os.system(<span class="string">"mount -t nfs -o acl,rw,intr,soft,nolock,rsize=8192,wsize=8192 10.160.43.172:/share /share "</span>)</span><br></pre></td></tr></table></figure></code></pre><h2><span id="发送告警邮件脚本">发送告警邮件脚本</span></h2><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line">#coding=utf-8</span><br><span class="line">#这个脚本的用途是用来发送邮件</span><br><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"><span class="keyword">from</span> email.mime.multipart <span class="keyword">import</span> MIMEMultipart</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.mime.application <span class="keyword">import</span> MIMEApplication</span><br><span class="line"></span><br><span class="line">mailto_list=[]    #这里为空list，会从list.txt里一行一行的当做元素添加进来</span><br><span class="line"></span><br><span class="line">#生成list.txt</span><br><span class="line"><span class="keyword">if</span> os.path.exists(<span class="string">'/root/chenscript/list.txt'</span>) == True:</span><br><span class="line">        os.system(<span class="string">"cd /挂载盘名称;du -s * --exclude='不想要计算在内的文件夹' --exclude='不想要计算在内的文件夹' --exclude='不想要计算在内的文件夹'|sort -nr |head|awk \'&#123;print $2\"@dahuatech.com\"&#125;\'  &gt;&gt;/root/chenscript/list.txt"</span>)</span><br><span class="line"><span class="keyword">if</span> os.path.exists(<span class="string">'/root/chenscript/list.txt'</span>) == False:</span><br><span class="line">        os.system(<span class="string">"cd /root/chenscript/;rm -f list.txt;echo '本人的邮箱地址'&gt;list.txt"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'/root/chenscript/list.txt'</span>,<span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f=f.readlines()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> f:</span><br><span class="line">        i=i.strip(<span class="string">'\n'</span>)</span><br><span class="line">        mailto_list.append(i)</span><br><span class="line">mail_host=<span class="string">"这里填写邮箱主机"</span></span><br><span class="line">mail_user=<span class="string">"这里填写发送人的邮箱地址"</span></span><br><span class="line">mail_pass=<span class="string">"发送人的邮箱密码"</span></span><br><span class="line">mail_postfix=<span class="string">"dahuatech.com"</span></span><br><span class="line">mail_sender=<span class="string">"与mail_host内容相同"</span></span><br><span class="line">def send_mail(sub, content):</span><br><span class="line">    me=mail_sender</span><br><span class="line">    msg = MIMEMultipart()</span><br><span class="line">    msg[<span class="string">'Subject'</span>] = sub</span><br><span class="line">    msg[<span class="string">'From'</span>] = me</span><br><span class="line">    msg[<span class="string">'To'</span>] = <span class="string">";"</span>.join(mailto_list)</span><br><span class="line">    content1 = MIMEText(str(content), <span class="string">'plain'</span>, <span class="string">'utf-8'</span>)</span><br><span class="line">    msg.attach(content1)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        s = smtplib.SMTP()</span><br><span class="line">        s.connect(mail_host)</span><br><span class="line">        s.login(mail_user,mail_pass)</span><br><span class="line">        s.sendmail(me, mailto_list, msg.as_string())</span><br><span class="line">        print(<span class="string">'发送成功！\n'</span>)</span><br><span class="line">        s.close()</span><br><span class="line">    except Exception <span class="keyword">as</span> e: print(str(e))</span><br><span class="line"></span><br><span class="line">os.system(<span class="string">"cd /root/chenscript/;rm -f list.txt;echo '我本人的邮件地址'&gt;list.txt"</span>)</span><br></pre></td></tr></table></figure></code></pre><p>执行的效果如下：<br><img src="/images/gaojingmail1.png" alt="paradin"></p><h2><span id="隐藏的知识点">隐藏的知识点</span></h2><p>1）<code>du -s</code>是按照字节来统计，<code>--exclude=&#39;yunwei&#39;</code>是在排序的时候忽略掉<code>yunwei</code>这个文件夹，容后再用<code>sort -nr|head</code>是得到从大到小前10名，如果得到后10名就是<code>sort -nr|tail</code>；<br>2）如果使用的是<code>import commands</code>，那么<code>commands.getoutpu</code>t得到的是字符串！<br>3）用<code>mount | grep &#39;:.*nfs&#39;</code>来判断挂载盘是否存在是一个很简单的方式，如果挂了多个，就用<code>ip in</code>的方式来进一步判断；<br>4）python要一行一行的读取文件，就<code>readline</code>；<br>5）python按行读取文件，去掉换行符<code>\n</code>的方法：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> file.readlines():</span><br><span class="line">    line=line.strip(<span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure></p><p>6）<code>import Automail</code>的时候，就已经把<code>Automail.py</code>这个脚本固定住了，这时候<code>mailto_list</code>已经不能变化了，所以要把添加<code>list.txt</code>放到这个脚本里。<br><img src="/images/gaojingmail2.png" alt="paradin"></p><p>发了邮件，连吼带骂一顿，终于把share盘容量下降到了69这样一个美妙的数字…</p>]]></content>
    
    <summary type="html">
    
      将监控进行到无死角
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>使用matplotlib画图的一个脚本</title>
    <link href="http://yoursite.com/2018/02/27/%E4%BD%BF%E7%94%A8matplotlib%E7%94%BB%E5%9B%BE%E7%9A%84%E4%B8%80%E4%B8%AA%E8%84%9A%E6%9C%AC/"/>
    <id>http://yoursite.com/2018/02/27/使用matplotlib画图的一个脚本/</id>
    <published>2018-02-27T10:50:24.000Z</published>
    <updated>2018-02-27T13:33:18.045Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="准备工作">准备工作</span></h2><p>之前在<a href="https://rorschachchan.github.io/2018/02/24/阿里云获取DTS服务延迟的脚本/" target="_blank" rel="noopener">https://rorschachchan.github.io/2018/02/24/阿里云获取DTS服务延迟的脚本/</a> 里已经可以获取到阿里云DTS服务的延迟时长和同步速率。下一步就是把这些值以24小时为周期作一个图像，然后每天在固定时间发送到领导们的邮件里。</p><p>python作图的第三方工具叫<code>matplotlib</code>，安装步骤如下：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pip install matplotlib#画图模块</span><br><span class="line">pip install numpy#依赖的库</span><br><span class="line">pip install scipy#又一个依赖的库</span><br><span class="line">yum install -y Tkinter#如果是python3，那么就是yum install -y tkinter</span><br></pre></td></tr></table></figure></p><h2><span id="脚本内容">脚本内容</span></h2><p>由于我是在<code>centos 7</code>里进行脚本操作，而linux服务器有没有安装图像，所以在执行<code>import matplotlib.pyplot as plt</code>的时候可能会爆错：<code>RuntimeError: could not open display</code>，这个时候需要在前面改成如下样式（注意先后顺序）：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line">mpl.use(<span class="string">'Agg'</span>)</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure></p><p>举一个简单的脚本例子如下，就是给予（x,y）然后连成曲线图的效果，脚本里数字的部分不加引号也是可以识别的，当然使用变量也可以。<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line">mpl.use(<span class="string">'Agg'</span>)</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line"><span class="keyword">import</span> pylab <span class="keyword">as</span> pl  </span><br><span class="line"> </span><br><span class="line">x=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>,<span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span>,<span class="number">24</span>]</span><br><span class="line">#横坐标的内容</span><br><span class="line">labels=[<span class="string">'10'</span>,<span class="string">'11'</span>,<span class="string">'12'</span>,<span class="string">'13'</span>,<span class="string">'14'</span>,<span class="string">'15'</span>,<span class="string">'16'</span>,<span class="string">'17'</span>,<span class="string">'18'</span>,<span class="string">'19'</span>,<span class="string">'20'</span>,<span class="string">'21'</span>,<span class="string">'22'</span>,<span class="string">'23'</span>,<span class="string">'24'</span>,<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>,<span class="string">'6'</span>,<span class="string">'7'</span>,<span class="string">'8'</span>,<span class="string">'9'</span>]</span><br><span class="line"></span><br><span class="line">a = <span class="string">'1'</span></span><br><span class="line">b = <span class="string">'2'</span></span><br><span class="line">c = <span class="string">'3'</span></span><br><span class="line">d = <span class="string">'4'</span></span><br><span class="line"></span><br><span class="line">#y1是延迟</span><br><span class="line">y1=[<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'5'</span>,<span class="string">'4'</span>,<span class="string">'2'</span>,<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'5'</span>,<span class="string">'4'</span>,<span class="string">'2'</span>,<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'5'</span>,<span class="string">'4'</span>,<span class="string">'2'</span>,<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'5'</span>]</span><br><span class="line"></span><br><span class="line">#y2是同步速率</span><br><span class="line">y2=[a,b,c,d,<span class="number">0.13</span>,<span class="number">0.12</span>,<span class="number">0.14</span>,<span class="number">0.14</span>,<span class="number">0.14</span>,<span class="number">0.16</span>,<span class="number">0.15</span>,<span class="number">0.13</span>,<span class="number">0.12</span>,<span class="number">0.14</span>,<span class="number">0.14</span>,<span class="number">0.14</span>,<span class="number">0.16</span>,<span class="number">0.15</span>,<span class="number">0.13</span>,<span class="number">0.12</span>,<span class="number">0.14</span>,<span class="number">0.22</span>,<span class="number">0.18</span>,<span class="number">0.11</span>]</span><br><span class="line"></span><br><span class="line">#输入对应的坐标，后面是颜色</span><br><span class="line">plot1,=pl.plot(x,y1,'r')#这里是有逗号的，用于参数解包</span><br><span class="line">plot2,=pl.plot(x,y2,<span class="string">'b'</span>)  </span><br><span class="line">pl.xticks(x,labels)</span><br><span class="line"></span><br><span class="line">#图片的标题以及对应的字号大小</span><br><span class="line">pl.title(<span class="string">'The DTS status of Shenzhen VPC'</span>,size=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">#X轴的标题和字号大小</span><br><span class="line">pl.xlabel(<span class="string">'Time'</span>, size=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line">#Y轴的标题，字号大小和长度</span><br><span class="line">pl.xlabel(<span class="string">'Time'</span>, size=<span class="number">14</span>)</span><br><span class="line">pl.ylim(<span class="number">0.0</span>,<span class="number">5.0</span>)</span><br><span class="line"></span><br><span class="line">#曲线对应注释</span><br><span class="line">pl.legend([plot1,plot2],(<span class="string">'Delay'</span>,<span class="string">'Sync rate'</span>),<span class="string">'best'</span>,numpoints=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">#图片保存路径</span><br><span class="line">plt.savefig(<span class="string">'/tmp/dts.png'</span>, format=<span class="string">'png'</span>)</span><br></pre></td></tr></table></figure></p><p>脚本执行效果之后，会在对应的路径里生成一个图片文件，然后把这个图片转移到windows，打开就看到效果了，如图：<br><img src="/images/dts.png" alt="paradin"></p><p>这个图是全英文的，如果是中文的话，就会出现乱码，研究了半天也没搞明白，这一点让我很郁闷。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="http://python.jobbole.com/81182/" target="_blank" rel="noopener">http://python.jobbole.com/81182/</a><br><a href="https://absentm.github.io/2017/03/18/Python-matplotlib-数据可视化/" target="_blank" rel="noopener">https://absentm.github.io/2017/03/18/Python-matplotlib-数据可视化/</a><br><a href="https://liam0205.me/2014/09/11/matplotlib-tutorial-zh-cn/" target="_blank" rel="noopener">https://liam0205.me/2014/09/11/matplotlib-tutorial-zh-cn/</a><br><a href="https://morvanzhou.github.io/tutorials/data-manipulation/plt/1-1-why/" target="_blank" rel="noopener">https://morvanzhou.github.io/tutorials/data-manipulation/plt/1-1-why/</a><br><a href="https://www.lookfor404.com/%E8%BF%90%E8%A1%8Cggplot%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98no-display-name-and-no-display-environment-variable/" target="_blank" rel="noopener">https://www.lookfor404.com/%E8%BF%90%E8%A1%8Cggplot%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98no-display-name-and-no-display-environment-variable/</a></p>]]></content>
    
    <summary type="html">
    
      插播一句题外话：将域名解析到IP的其他端口的方法是通过一个临时域名来配置“隐性url”
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>解决https证书在赛门铁克认证失败的问题</title>
    <link href="http://yoursite.com/2018/02/26/%E8%A7%A3%E5%86%B3https%E8%AF%81%E4%B9%A6%E5%9C%A8%E8%B5%9B%E9%97%A8%E9%93%81%E5%85%8B%E8%AE%A4%E8%AF%81%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/02/26/解决https证书在赛门铁克认证失败的问题/</id>
    <published>2018-02-26T14:40:03.000Z</published>
    <updated>2018-02-27T06:57:58.892Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="问题描述">问题描述</span></h2><p>今天电子商城的市场接到一个故障，说更换了.lechange.com的https证书（原有的证书到期了，新买了一个依旧还是.lehcange.com域名证书）之后，订单在支付宝支付的时候提示支付失败。我把<code>request id</code>提供给支付宝的客服请他们查看一下后台，支付宝客服说我们电商的https证书没有认证成功。于是我就登陆<a href="https://cryptoreport.websecurity.symantec.com/checker/" target="_blank" rel="noopener">https://cryptoreport.websecurity.symantec.com/checker/</a> 去检查一下电商的域名，果不其然，赛门铁克的反馈是错误的，如图：<br><img src="/images/saimentieke1.png" alt="paradin"></p><p>但是登陆网站，在浏览器里却显示https证书是OK的，如图：<br><img src="/images/saimentieke2.png" alt="paradin"></p><p>然后我用<code>symantec</code>的那个网站测试了一下电商平台开发环境的域名，发现也是OK的，如图：<br><img src="/images/saimentieke3.png" alt="paradin"></p><p>这就郁闷了，到底哪里出问题了？</p><h2><span id="问题排查">问题排查</span></h2><p>首先跟研发确认，开发环境与线上环境在涉及到证书的代码是否一致，得到研发的确认之后。就检查服务器里的<code>nginx</code>，发现服务器<code>nginx</code>的配置文件里是没有涉及到<code>ssl</code>，无论是开发环境和线上环境都是通过阿里云slb配置的https证书。而且两者的证书指纹一模一样，如图：<br><img src="/images/saimentieke4.png" alt="paradin"></p><p>既然都是用的一样的证书，为啥一个检验通过，另一个检验不通过呢？这个时候我想到线上环境与开发环境唯一的不同就是线上环境多了一个cdn，于是就登陆到cdn的控制页面，找到对应的https证书，发现cdn的https证书指纹也是跟上面的指纹一样，如图：<br><img src="/images/saimentieke5.png" alt="paradin"></p><p>既然指纹一样，那证书也应该是一样的，场面又进入了一个僵局。</p><p>于是我就到一台服务器里使用<code>curl -vv https://www.lechange.com</code>，看到的结果如下：<br><img src="/images/saimentieke6.png" alt="paradin"></p><p>提示<code>未配置签发者根证书</code>，我这时候想起来了，<font color="red">首先证书指纹一致不能说明证书是完全一致的，只能说明key文件是一样的！</font>其次这个https证书是中级机构证书，那么中级机构颁发的证书链规则是这样的：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-----BEGIN CERTIFICATE-----</span><br><span class="line"></span><br><span class="line">-----END CERTIFICATE-----</span><br><span class="line"></span><br><span class="line">-----BEGIN CERTIFICATE-----</span><br><span class="line"></span><br><span class="line">-----END CERTIFICATE-----</span><br></pre></td></tr></table></figure></p><p>那么我怀疑就是https证书链那部分可能在cdn配置错误了，或许在slb配置错误了，甚至两个都配置错误了！</p><p>于是干脆删除掉线上电商原有的https证书，重新导入cdn和slb的https证书，返回到<code>symantec</code>刷新，这次的检验结果就OK了。<br><img src="/images/saimentieke7.png" alt="paradin"></p><h2><span id="补充">补充</span></h2><p>虽然这个问题解决了，但是我还是不明白，为什么在网页端查看证书是绿色OK的呢？在<code>sf.gg</code>上提问之后，一个叫Avro的朋友是这么回答我的：</p><blockquote><p>以chrome为例，他信任了[所在平台的信任证书列表][1]，而这些平台集成了一系列信任的根证书，如iOS 11 中可用的受信任根证书列表可以找到你的根证书“04 00 00 00 00 01 15 4B 5A C3 94 ”(序列号)，因此验证过程中没有问题，而对于其他的工具，如果未使用这些平台根证书信任列表依然需要完整的证书链（这个证书链在ssl握手过程中被下发）进行校验。</p></blockquote><h2><span id="参考资料">参考资料</span></h2><p><a href="https://openclub.alipay.com/read.php?tid=3451&amp;fid=57&amp;page=1" target="_blank" rel="noopener">https://openclub.alipay.com/read.php?tid=3451&amp;fid=57&amp;page=1</a><br><a href="https://www.jianshu.com/p/84af353f43c5" target="_blank" rel="noopener">https://www.jianshu.com/p/84af353f43c5</a><br><a href="https://help.aliyun.com/knowledge_detail/39468.html?spm=a2c4g.11186631.2.2.w2qcWT" target="_blank" rel="noopener">https://help.aliyun.com/knowledge_detail/39468.html?spm=a2c4g.11186631.2.2.w2qcWT</a></p>]]></content>
    
    <summary type="html">
    
      搞了半天其实就是https证书没弄对...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="https证书" scheme="http://yoursite.com/tags/https%E8%AF%81%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>记录Apache Storm的部署始末</title>
    <link href="http://yoursite.com/2018/02/25/%E8%AE%B0%E5%BD%95Apache-Storm%E7%9A%84%E9%83%A8%E7%BD%B2%E5%A7%8B%E6%9C%AB/"/>
    <id>http://yoursite.com/2018/02/25/记录Apache-Storm的部署始末/</id>
    <published>2018-02-25T13:27:42.000Z</published>
    <updated>2018-02-25T13:56:07.024Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="前言">前言</span></h2><p><code>Storm</code>是一个流式处理框架（你可以把它当成一种消息队列），开发人员开发出特定的项目，然后通过storm这个渠道下发各种任务，从而达到任务执行的效果。</p><p>Storm有两个比较重要的组件：<code>nimbus</code>和<code>supervision</code>，其中<code>nimbus</code>主要是承接任务和分配任务用，而每一个<code>supervision</code>可以有若干<code>worker</code>（视服务器硬件而定），而<code>supervison</code>的主要任务就是监控对应的<code>worker</code>，一旦<code>worker</code>死了，<code>supervision</code>就会把他们唤醒。</p><p>本次试验是用的是金山云服务器，storm的版本是<code>1.0.2</code>，配置是<code>1个nimbus，三个supervision</code>，每一个worker上只执行一个任务，总共三个任务。</p><h2><span id="准备工作">准备工作</span></h2><p>安装<code>storm</code>之前需要在<code>storm</code>里新安装一套<code>zookeeper</code>，因为<code>storm</code>是需要一个zk集群的，<code>nimbus</code>和每一个<code>supervisior</code>是通过zk的心跳来传递存活的信息，于是我们就在每一个<code>supervision</code>里面安装一个<code>zookeeper</code>，并且启动<code>zookeeper</code>的<code>server</code>端，安装<code>zookeeper</code>的方法可以移步<a href="http://chenx1242.blog.51cto.com/10430133/1889715" target="_blank" rel="noopener">http://chenx1242.blog.51cto.com/10430133/1889715</a> 。</p><p>上面这段话用图来说就是这样子：<br><img src="/images/storm1.jpg" alt="paradin"></p><p>启动<code>zookeeper</code>之后，就需要在<code>nimbus</code>和<code>supervisior</code>里安装<code>storm</code>，上面说过本次安装的<code>storm</code>是<code>1.0.2</code>版本，路径直接是<code>/storm/apache-storm-1.0.2</code>。</p><p>将<code>storm</code>安装完之后，需要在<code>nimbus</code>和<code>supervisior</code>里更改<code>/etc/hosts</code>文件，改成如下的格式：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> localhost</span><br><span class="line"> </span><br><span class="line">nimbus的内网IP online-nimbus<span class="number">-001</span></span><br><span class="line">supervision1的内网IP supervision<span class="number">-001</span></span><br><span class="line">supervision2的内网IP supervision<span class="number">-002</span></span><br><span class="line">supervision3的内网IP supervision<span class="number">-003</span></span><br><span class="line"> </span><br><span class="line">zookeeper的内网IP zookeeper的名称            #注意，这里的zk是给模块拉取配置的zk</span><br><span class="line">storm的zk1的内网IP storm的zk1            #这里的zk就是给storm集群用的zk</span><br><span class="line">storm的zk2的内网IP  storm的zk2                      #如果storm的zk是standalone模式，这里就不要写了。</span><br><span class="line">storm的zk3的内网IP  storm的zk3                      #如果storm的zk是standalone模式，这里就不要写了。</span><br></pre></td></tr></table></figure></p><p>保存完<code>/etc/hosts</code>之后，还有一个比较重要的步骤，就是在<code>/etc/ld.so.conf.d/</code>这个路径里面建立一个<code>ffmped.conf</code>这个文件，文件的内容如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/storm/apache-storm<span class="number">-1.0</span><span class="number">.2</span>/lib</span><br><span class="line">/storm/apache-storm<span class="number">-1.0</span><span class="number">.2</span>/lib/<span class="number">3</span>rd</span><br></pre></td></tr></table></figure></p><p>注意，<code>/storm/apache-storm-1.0.2</code>是我的storm路径，在实际情况下需要根据自己的路径进行更改。</p><p>把这个<code>ffmped.conf</code>建立成功之后，我们可以测试一下，如果输入<code>ldconfig</code>的话，会出现如下的内容，就证明达到了我们的效果：<br><img src="/images/storm2.jpg" alt="paradin"></p><p><code>storm</code>本身的<code>bin</code>目录夹里也有很多命令可以直接使用，为了调用<code>storm list</code>方便，我们需要把<code>bin/storm</code>这个可执行文件作一个软连接，方法就是先<code>cd /usr/local/bin/</code>，然后<code>ln -s /storm/apache-storm-1.0.2/bin/storm storm</code>。这样的话，我们就可以直接使用<code>storm list</code>来查看任务列表了。</p><h2><span id="storm的具体配置">Storm的具体配置</span></h2><p>安装了<code>storm</code>，调整了命令行，同时也搞定了<code>ffmpeg.conf</code>，下面就是调整<code>storm</code>的配置文件了，<code>nimbus</code>和<code>supervisior</code>都要修改。</p><p>storm的配置文件叫<code>storm.yaml</code>，路径位于<code>storm</code>文件夹下的<code>/conf/</code>文件夹，我们需要在这个文件里面输入如下的内容：<br><img src="/images/storm3.png" alt="paradin"></p><p>下面对配置文件作一个简单的解释：<br>1）storm.zookeeper.port:zk的默认端口2181；<br>2）storm.cluster.mode:storm的集群运行模式，这里我们也是采用默认的distributed（分布式）；<br>3）storm.local.dir:storm使用的本地文件的目录，这个目录必须存在而且storm进程可读写；<br>4）supervisor.slots.ports：这个地方在nimbus里可以不用管，但是在supervisior里是需要改的，如果你只打开6700，那么就只放开了6700端口，即只有一个worker，如果你打开了6700、6701、6702三个端口，那么就意味这个supervisior将有三个worker在工作，由于这次试验里我们每一个supervisor只开启一个任务，所以在supervisior的storm.yaml里这个节点就只保留6700，其他的就全部注释掉；<br>5）nimbus.task.launch.secs:task启动时的一个特殊超时设置.在启动后第一次心跳前会使用该值来临时替代nimbus.task.timeout.secs；<br>6）worker.childopts:设定每个worker (JVM任务)的最小和最大内存；</p><p>更改完了<code>storm.yaml</code>之后，就要在<code>nimbus</code>里面安装<code>zkclient</code>。直接复制粘贴过来就好了。</p><p>如果你不喜欢<code>storm</code>自带的日志格式，想更改一下日志的内容，那么就要在<code>/storm/apache-storm-1.0.2/log4j2</code>文件夹里面修改<code>worker.xml</code>，不过在这里善意的提醒，最好在修改之前先备份原有的<code>worker.xml</code>。</p><h2><span id="连接具体任务">连接具体任务</span></h2><p>这次的实验包用的是我所在的公司开发内部使用的包，先把这个包的内容复制到<code>/storm/</code>文件夹下，同时<code>mkdir install</code>和<code>makir properties</code>这两个文件夹，在<code>install</code>文件夹里有开发写的任务的<code>jar</code>包和启动程序，如下：<br><img src="/images/storm4.png" alt="paradin"></p><p>而在<code>properties</code>文件夹里，应该有这个任务的配置文件，如下：<br><img src="/images/storm5.png" alt="paradin"></p><p>由于我们已经事前在<code>/etc/hosts</code>里指定了zkclient需要访问的zk的ip地址了，那么如果zk项配置正确，zkclient这个时候是可以成功启动的。同时在<code>install</code>文件夹里<code>./update_stormserver_config.sh</code>也应该是反应正确的。</p><p>然后我们就可以启动storm了。</p><h2><span id="启动nimbus和supervision">启动nimbus和supervision</span></h2><p>启动<code>storm</code>要先启动<code>nimbus</code>，在<code>/storm/apache-storm-1.0.2/bin</code>里面启动<code>run_nimbus.sh</code>，然后等一下会有一大片东西出现，再<code>jps</code>一下就能看到<code>nimbus</code>已经启动了，如图：<br><img src="/images/storm6.png" alt="paradin"></p><p>从上图我们可以看到，18141的进程就是<code>zkclient</code>，只不过在<code>jps</code>里它名字叫<code>AppServerDaemon</code>，而<code>zkServer</code>在<code>jps</code>里叫<code>QuorumPeerMain</code>。</p><p>如果 <code>storm</code>出现<code>Did you specify a valid list of nimbus hosts for config nimbus.seeds?</code>的错误提示，那么就是<code>nimbus</code>没有启动的缘故。</p><p>启动了<code>nimbus</code>之后，就可以在<code>supervisor</code>的机器里去效仿着启动<code>supervisor</code>，但是这里要注意，如果你开启了一个<code>supervisior</code>，那么按照我们上面的配置文件，就启动了一个6700端口的<code>worker</code>，这个时候在<code>nimbus</code>执行下派一个任务的命令，<code>nimbus</code>就会下派这个任务给这个<code>worker</code>。</p><p>下派命令的例子如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">storm jar storm-starter<span class="number">-0.9</span><span class="number">.2</span>-incubating-jar-<span class="keyword">with</span>-dependencies.jar com.lechange.recordshare.RecordShareTopology <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>这样就启动了一个叫<code>videoshare</code>的任务，这个任务只用1个<code>worker</code>。</p><p>如果在命令行里反馈这样的错误：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Error</span>: Could not find or load main <span class="class"><span class="keyword">class</span> <span class="title">storm</span>.<span class="title">starter</span>.<span class="title">recordshare</span>.<span class="title">RecordShareTopology</span></span></span><br></pre></td></tr></table></figure></p><p>或者<code>exception in thread main java.lang.NoClassDefFoundError</code>这样的错误，那就要检查jar包和路径。</p><p>而如果你再打开一个<code>supervisor</code>，在<code>nimbus</code>端又下发了一个任务，那么这个任务就会给刚刚新启动的<code>supervisor</code>。这样，启动一个下发一个，就会对每一个<code>worker</code>具体干的任务情况有一个比较清晰的了解。<br><img src="/images/storm7.png" alt="paradin"></p><p>在nimbus上执行<code>storm list</code>，就可以获得上图的样子，可以看出，我在nimbus端下发了三个任务，就是<code>topology_name</code>这一栏，他们的状态也是<code>active</code>，而<code>workers</code>数量都是1，也就是说在那三台<code>supervisor</code>里都在工作。而跑到<code>supervisor</code>一看日志，也是对应有各自的任务日志。</p><p>至此整个storm和具体的模块工作的搭建就完成了。</p><h2><span id="补充">补充</span></h2><p>如果你事前一口气把三个<code>supervisor</code>都打开了，即开启了3个<code>worker</code>，然后一口气在<code>nimbus</code>端，一口气输入了三个下发任务的命令，那么这三个命令会随机的到这三个<code>worker</code>里，没有任何顺序而言，你只能通过日志的关键词来判断具体的<code>worker</code>做哪些任务。</p><p>而如果你的worker数量少于<code>nimbus</code>下发任务的数量，会有什么反应呢？</p><p>答案就是任务根本没有<code>worker</code>去干，在<code>storm list</code>里，多余的任务对应的<code>num_workers</code>的数字是0，而如果这个时候你新增一个<code>supervisor</code>到这个<code>storm</code>集群，那么这个任务就会吭哧吭哧开始工作了。</p>]]></content>
    
    <summary type="html">
    
      杭州终于要有一点春天的温暖了
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="大数据分析" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
      <category term="storm" scheme="http://yoursite.com/tags/storm/"/>
    
  </entry>
  
  <entry>
    <title>DockerFile创建一个nginx容器的全过程</title>
    <link href="http://yoursite.com/2018/02/25/DockerFile%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAnginx%E5%AE%B9%E5%99%A8%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/02/25/DockerFile创建一个nginx容器的全过程/</id>
    <published>2018-02-25T11:54:34.000Z</published>
    <updated>2018-02-25T12:09:17.094Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="创建容器">创建容器</span></h2><p>首先，随便建立一个文件夹，比如先<code>mkdir sample</code>，然后我在这个sample文件夹里建立一个<code>Dockerfile</code>，内容如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:<span class="number">14.04</span></span><br><span class="line">MAINTAINER Chris Chan <span class="string">"chenx1242@163.com"</span></span><br><span class="line">ENV REFRESHED_AT <span class="number">2016</span><span class="number">-12</span><span class="number">-05</span></span><br><span class="line">RUN apt-get -y update &amp;&amp; apt-get install -y nginx</span><br><span class="line">RUN mkdir -p /<span class="keyword">var</span>/www/html/website</span><br><span class="line">ADD nginx/global.conf /etc/nginx/conf.d/</span><br><span class="line">ADD nginx/nginx.conf /etc/nginx/nginx.conf</span><br><span class="line">EXPOSE <span class="number">80</span></span><br></pre></td></tr></table></figure></p><p>从这个Dockfile里面看出：我们使用了ubuntu的基础镜像，然后下载了nginx，同时建立一个<code>/var/www/html/website</code>文件夹，然后又拷贝了宿主机上的两个文件，一个是<code>global.conf</code>，另一个是<code>nginx.conf</code>，这两个文件需要我们自己写。于是我们就要在sample下再建立一个叫nginx的文件夹，里面写上这两个文件，其中<code>global.conf</code>的内容如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">       listen   <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">80</span>;</span><br><span class="line">       server_name     _;</span><br><span class="line">       root    /<span class="keyword">var</span>/www/html/website;</span><br><span class="line">       index   index.html index.htm;</span><br><span class="line">       access_log      /<span class="keyword">var</span>/log/nginx/default_access.log;</span><br><span class="line">       error_log       /<span class="keyword">var</span>/log/nginx/default_error.log;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而<code>nginx.conf</code>的内容如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">user www-data;</span><br><span class="line">worker_processes <span class="number">4</span>;</span><br><span class="line">pid /run/nginx.pid;</span><br><span class="line">events &#123; &#125;</span><br><span class="line">http &#123;</span><br><span class="line"> sendfile on;</span><br><span class="line"> tcp_nopush on;</span><br><span class="line"> tcp_nodelay on;</span><br><span class="line"> keepalive_timeout <span class="number">65</span>;</span><br><span class="line"> types_hash_max_size <span class="number">2048</span>;</span><br><span class="line"> include /etc/nginx/mime.types;</span><br><span class="line"> default_type application/octet-stream;</span><br><span class="line"> access_log /<span class="keyword">var</span>/log/nginx/access.log;</span><br><span class="line"> error_log /<span class="keyword">var</span>/log/nginx/error.log;</span><br><span class="line"> gzip on;</span><br><span class="line"> gzip_disable <span class="string">"msie6"</span>;</span><br><span class="line"> include /etc/nginx/conf.d<span class="comment">/*.conf;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure></p><p>全部搞定之后，我们就来build这个镜像，比如这个镜像名叫做<code>chentest/nginx001</code>，在sample文件夹里使用的命令语句就是：<code>docker build -t=&#39;chentest/nginx001&#39; .</code>。</p><p>一顿七七八八之后，显示OK，<code>docker ps -a</code>就会显示我们新建的镜像，如图：<br><img src="/images/dockernginx1.png" alt="paradin"></p><p>有了镜像，再在sample文件夹里新增一个文件夹，比如就叫<code>webiste</code>，里面有一个文件叫<code>index.html</code>。而<code>index.html</code>的内容如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span> is a nginxtest page.</span><br></pre></td></tr></table></figure></p><p>保存退出之后，返回到sample目录。</p><p>现在我们可以制作一个容器了，制作容器命令是<code>docker run -d -p 8080:80 --name test02 -v $PWD/website:/var/www/html/website chentest/nginx001 nginx -g &quot;daemon off;&quot;</code>,这句话里规定容器的8080端口映射到宿主机的80端口，同时引入了当前目录的website目录到容器的<code>/var/www/html/website</code>目录，nginx也默认在前台进程进行。执行之后，<code>docker ps -a</code>看一下：<br><img src="/images/dockernginx2.png" alt="paradin"></p><p>看见port这一栏已经显示8080与80端口的相勾结成功，于是我们可以登录这台机器的80端口看一下。<br><img src="/images/dockernginx3.png" alt="paradin"></p><p>而如果现在我更改一下上面的<code>index.html</code>，改成另外一句话。比如说改成“why so serious??”,保存文件之后，直接刷新网页，就会看到网页的内容已经发生了变化，如图：<br><img src="/images/dockernginx4.png" alt="paradin"></p><p>可见引入<code>-v</code>这个命令在容器里，可以随时调试内容，而不是每次都要重新打包生成镜像。这一点再调试阶段为我们提供了很大的方便。</p><h2><span id="docker端口映射的问题">docker端口映射的问题</span></h2><p><code>docker run</code>命令里指定端口的格式是<code>-p 容器端口:宿主机端口</code>。如果想要随机指定就是大写的<code>P</code>。如图：<br><img src="/images/dockernginx5.png" alt="paradin"></p><p>这里就是随机分配了一个32775端口给宿主机，访问的时候也是要访问这个32775端口。</p><p>有时候port这里却不显示端口映射的情况，如图：<br><img src="/images/dockernginx6.png" alt="paradin"></p><p>这个情况是因为这个容器的status是<code>exited</code>，docker会在容器主进程结束后自动终止容器运行，而<code>nginx</code>启动后就会在后台运行，docker以为<code>nginx</code>已经结束运行了，所以就会停止容器。</p>]]></content>
    
    <summary type="html">
    
      中国共产党建议修改宪法，取消国家主席任期不得超过两届的规定。
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>DockerFile创建一个redis容器的全过程</title>
    <link href="http://yoursite.com/2018/02/25/DockerFile%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAredis%E5%AE%B9%E5%99%A8%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/02/25/DockerFile创建一个redis容器的全过程/</id>
    <published>2018-02-25T11:36:46.000Z</published>
    <updated>2018-02-25T11:47:14.380Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="正文">正文</span></h2><p>本次目标是用<code>Centos 7</code>的基础镜像做一个redis容器供开发人员在开发环境里蹂躏。</p><p>首先，创建一个叫<code>redis-test</code>的文件夹，在这个<code>redis-test</code>文件夹里建立一个<code>Dockerfile</code>，内容如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM centos:latest</span><br><span class="line">MAINTAINER Chris Chan <span class="string">"chenx1242@163.com"</span></span><br><span class="line">ENV REFRESHED_AT <span class="number">2017</span><span class="number">-02</span><span class="number">-16</span></span><br><span class="line">RUN yum -y update &amp;&amp;  yum -y install epel-release &amp;&amp; yum -y install redis &amp;&amp; yum -y install net-tools</span><br><span class="line">EXPOSE <span class="number">6379</span></span><br><span class="line">ENTRYPOINT [ <span class="string">"/usr/bin/redis-server"</span> ]</span><br><span class="line">CMD []</span><br></pre></td></tr></table></figure></p><p>这里我们简单说一下整个<code>Dockerfile</code>的内容：</p><p>首先选择了基础镜像是centos的最新版，即<code>centos 7</code>，然后填写作者信息；</p><p>在yum这一块要注意，如果没有安装<code>epel-release</code>的话，是无法正常安装redis的，这是centos与ubuntu不一样的地方。至于后面又补充安装了<code>net-tools</code>是因为<code>centos 7</code>里不自带<code>ifconfig</code>命令，所以需要安装一下<code>net-tools</code>，这样就有了<code>ifconfig</code>了；</p><p>随即我们又开放了<code>6379</code>端口；</p><p>然后就是<code>entrypoint</code>和<code>cmd</code>，这两个命令的区别很重要，具体区别请看：<a href="http://cloud.51cto.com/art/201411/457338.htm" target="_blank" rel="noopener">http://cloud.51cto.com/art/201411/457338.htm</a> 这篇文章。</p><p>然后我们就可以依照这个Dockfile去建立一个镜像，因为目的是要在“centos环境下建立一个redis”，那么我们这个镜像的名字就叫作<code>lccentos/redis</code>，具体操作就是在<code>redis-test</code>文件夹下执行<code>docker build -t lccentos/redis .</code>。</p><p>然后根据这个镜像需要制作一个容器，容器的名字就叫<code>redisforcentos</code>，那么命令就是：<code>docker run -d -p 6379 --name redisforcentos lccentos/redis</code>。</p><p>然后我们<code>docker ps -a</code>看一下效果，如下：<br><img src="/images/redisinfo2.png" alt="paradin"></p><p>可见宿主机的32774端口和容器的6379端口“融为一体”，这个时候，我们测试一下这个<code>redisforcento</code>s的容器是否已经正常启动了redis，如图：<br><img src="/images/redisinfo3.png" alt="paradin"></p><p>而且对于Docker来说，可以多个docker对应宿主机的同一个端口，比如我这台机器搞了两个redis，两个容器都可以指向6379的端口，如图：<br><img src="/images/redisinfo4.png" alt="paradin"></p><h2><span id="dockerfile的优化原则">Dockerfile的优化原则</span></h2><p>1）ADD和VOLUME应该放在Dockerfile底部，因为它们相对比yum安装那些变化的更勤；<br>2）EXPOSE可以一口气对应多个端口，比如<code>EXPOSE 80 2003 2004 7002</code>的效果跟下面的效果一样；<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE <span class="number">80</span> </span><br><span class="line">EXPOSE <span class="number">2003</span> </span><br><span class="line">EXPOSE <span class="number">2004</span> </span><br><span class="line">EXPOSE <span class="number">7002</span></span><br></pre></td></tr></table></figure></p><p>3）<code>ADD</code>的操作应该放在<code>Dockerfile</code>的最下面；</p><h2><span id="参考资料">参考资料</span></h2><p><a href="http://dockone.io/article/255?spm=5176.100239.blogcont40494.25.8RXqDX" target="_blank" rel="noopener">http://dockone.io/article/255?spm=5176.100239.blogcont40494.25.8RXqDX</a></p>]]></content>
    
    <summary type="html">
    
      用这个dockerfile作为模板，以后就在这个基础上拓展
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>阿里云获取DTS服务延迟值的脚本</title>
    <link href="http://yoursite.com/2018/02/24/%E9%98%BF%E9%87%8C%E4%BA%91%E8%8E%B7%E5%8F%96DTS%E6%9C%8D%E5%8A%A1%E5%BB%B6%E8%BF%9F%E7%9A%84%E8%84%9A%E6%9C%AC/"/>
    <id>http://yoursite.com/2018/02/24/阿里云获取DTS服务延迟的脚本/</id>
    <published>2018-02-24T08:49:31.000Z</published>
    <updated>2018-02-27T13:16:31.556Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="正文">正文</span></h2><p>春节“嗖”的一下就过完了，在年前领导交代另一个任务，想要每天统计一下在阿里云DTS（数据同步）服务的延迟情况，于是我就要使用阿里云的api去写一个脚本，每小时运行一次，然后将这24个数字输出出来给领导过目。</p><p>阿里云dts的sdk包在这里：<a href="https://help.aliyun.com/document_detail/57694.html?spm=a2c4g.11186623.6.675.W811bN" target="_blank" rel="noopener">https://help.aliyun.com/document_detail/57694.html?spm=a2c4g.11186623.6.675.W811bN</a> ，直接点击<code>Python</code>下载即可，不过这个地址经我测试使用非国内IP 地址是打不开的，需要使用国内IP地址下载。</p><p>下载完毕之后，上传到linux服务器并解压，解压后的样子如图：<br><img src="/images/dts1.png" alt="paradin"></p><p>由于我们这次只是查看同步作业状态，所用的py就是<code>DescribeSynchronizationJobStatusRequest.py</code>，现在我们就可以写脚本，假设这个脚本叫<code>getDTS.py</code>,那么整个内容如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line">#coding=utf-8</span><br><span class="line">#auther:ChrisChan@2018-2-24</span><br><span class="line">#这个脚本是用来获取DTS服务的延迟值</span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore <span class="keyword">import</span> client</span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore.acs_exception.exceptions <span class="keyword">import</span> ClientException</span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore.acs_exception.exceptions <span class="keyword">import</span> ServerException</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line">import sys#由于这个包不是通过pip install的方式安装,要调用其它路径的python脚本就要使用sys方法</span><br><span class="line">sys.path.append(<span class="string">'sdk压缩包的绝对路径'</span>)</span><br><span class="line"><span class="keyword">import</span> DescribeSynchronizationJobStatusRequest</span><br><span class="line"></span><br><span class="line"># 创建Client实例</span><br><span class="line">clt = client.AcsClient(<span class="string">'阿里云AK'</span>,<span class="string">'阿里云SK'</span>,<span class="string">'所属地域'</span>)</span><br><span class="line"></span><br><span class="line"># 创建request并设置参数</span><br><span class="line">request = DescribeSynchronizationJobStatusRequest.DescribeSynchronizationJobStatusRequest()</span><br><span class="line">request.set_accept_format(<span class="string">'json'</span>)</span><br><span class="line"></span><br><span class="line"># 写上对应的服务ID</span><br><span class="line">request.set_SynchronizationJobId(<span class="string">"这里写上DTS的ID"</span>)</span><br><span class="line"></span><br><span class="line">response = clt.do_action_with_exception(request)</span><br><span class="line">print response</span><br><span class="line">delay = json.loads(response)</span><br><span class="line">print <span class="string">"===================================================="</span></span><br><span class="line">print <span class="string">"当前延迟是："</span> + str(delay[<span class="string">"DataSynchronizationStatus"</span>][<span class="string">"Delay"</span>])</span><br><span class="line">print <span class="string">"当前同步速度是："</span> + str(delay[<span class="string">"Performance"</span>][<span class="string">"FLOW"</span>])</span><br></pre></td></tr></table></figure></p><p>整个脚本执行的效果如下：<br><img src="/images/dts2.png" alt="paradin"></p><p>dts的延迟时间是5秒计算一次，API请求会取到最新的延迟时间，控制台是每隔20秒才刷新一次。</p><h2><span id="补充">补充</span></h2><p><code>getDTS.py</code>这个脚本获取到的<code>response</code>是一个str字符串，这里我使用<code>json.loads</code>来将其转化成了<code>dict</code>模式。但是除了这个方法还有两个方法：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; user</span><br><span class="line"><span class="string">"&#123;'name' : 'jim', 'sex' : 'male', 'age': 18&#125;"</span></span><br><span class="line">&gt;&gt;&gt; b=<span class="built_in">eval</span>(user)</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">&#123;<span class="string">'age'</span>: <span class="number">18</span>, <span class="string">'name'</span>: <span class="string">'jim'</span>, <span class="string">'sex'</span>: <span class="string">'male'</span>&#125;</span><br><span class="line">&gt;&gt;&gt; print b[<span class="string">'sex'</span>]</span><br><span class="line">male</span><br><span class="line">&gt;&gt;&gt; exec(<span class="string">"c="</span>+user)</span><br><span class="line">&gt;&gt;&gt; c</span><br><span class="line">&#123;<span class="string">'age'</span>: <span class="number">18</span>, <span class="string">'name'</span>: <span class="string">'jim'</span>, <span class="string">'sex'</span>: <span class="string">'male'</span>&#125;</span><br><span class="line">&gt;&gt;&gt; print c[<span class="string">'name'</span>]</span><br><span class="line">jim</span><br></pre></td></tr></table></figure></p><font color="red">但是要注意！上面这两个方法有一定的安全隐患，而且只能全是字符串可用，如果有的<code>value</code>是<code>True</code>、<code>False</code>、<code>Null</code>这样的字眼的话，<code>eval</code>是不支持的，所以没法正确转换，就会爆这样的错：<code>NameError: name &#39;True&#39; is not defined</code>。</font><h2><span id="参考资料">参考资料</span></h2><p><a href="https://help.aliyun.com/document_detail/49453.html?spm=a2c4g.11186623.6.667.sRyVqY" target="_blank" rel="noopener">https://help.aliyun.com/document_detail/49453.html?spm=a2c4g.11186623.6.667.sRyVqY</a><br><a href="https://segmentfault.com/q/1010000000174694" target="_blank" rel="noopener">https://segmentfault.com/q/1010000000174694</a><br><a href="https://www.crifan.com/resolved_in_python_using_eval_to_force_variable_to_convert_a_string_to_a_dictionary_when_the_error_nameerror_name_39null39_is_not_defined/" target="_blank" rel="noopener">https://www.crifan.com/resolved_in_python_using_eval_to_force_variable_to_convert_a_string_to_a_dictionary_when_the_error_nameerror_name_39null39_is_not_defined/</a><br><a href="https://segmentfault.com/q/1010000000345915" target="_blank" rel="noopener">https://segmentfault.com/q/1010000000345915</a></p>]]></content>
    
    <summary type="html">
    
      先获取到值，然后做出来一个图。
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="阿里云" scheme="http://yoursite.com/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>Atlas的几种常见故障解决方法</title>
    <link href="http://yoursite.com/2018/02/23/Atlas%E7%9A%84%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2018/02/23/Atlas的几种常见故障解决方法/</id>
    <published>2018-02-23T13:39:43.000Z</published>
    <updated>2018-02-24T10:59:54.346Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="使用atlas却发现读库闲置框架还是去主库读写数据"><font color="red">使用atlas却发现“读库闲置，框架还是去主库读写数据”</font></span></h2><p>配置完atlas之后，发现使用<code>jdbc</code>框架的话，读库和写库各司其职，但是使用<code>mybatis</code>框架之后，就发现框架的读写都去了主库，把读库放置一边，那么这种情况是因为<code>有事务存在的话，atlas就会强制走主库</code>，遇到这种情况就检查一下是否有事务的存在，比如<code>@Transactional</code>，如果要解决的话，就加上<code>@Transactional(propagation=Propagation.NOT_SUPPORTED)</code>即可。<br><img src="/images/atlas13.png" alt="paradin"></p><h2><span id="自动读写分离挺好但有时候我写完马上就想读万一主从同步延迟怎么办"><font color="red">自动读写分离挺好，但有时候我写完马上就想读，万一主从同步延迟怎么办?</font></span></h2><p>SQL语句前增加 <code>/*master*/</code> 就可以将读请求强制发往主库。在mysql命令行测试该功能时，需要加<code>-c</code>选项，以防mysql客户端过滤掉注释信息。不过这不能从本质上解决问题，使用Atlas需要考虑到这点，提高主机的IO性能，加大memory可以缓解延迟症状，但依旧不能避免延迟的出现，尤其是读多写少的应用。</p><h2><span id="resource-limit的问题"><font color="red"><code>resource limit</code>的问题</font></span></h2><p>atlas有自己的连接池，会吃掉很多CPU, <code>php</code>应用端改用短链接来连接atlas, 这时候atlas对<code>php</code>发送来的sql只负责验证和转发的操作，后端DB的连接由atlas自己管理,未使用的连接线程进行剔除操作(DB的wait_timeout和interactive_timeout设置为300s,超时亦退出)。</p><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2014</span><span class="number">-04</span><span class="number">-12</span> <span class="number">20</span>:<span class="number">56</span>:<span class="number">29</span>: (warning) (libevent) event_del: event has no event_base set.</span><br><span class="line"><span class="number">2014</span><span class="number">-04</span><span class="number">-12</span> <span class="number">20</span>:<span class="number">56</span>:<span class="number">29</span>: (critical) last message repeated <span class="number">5</span> times</span><br><span class="line"><span class="number">2014</span><span class="number">-04</span><span class="number">-12</span> <span class="number">20</span>:<span class="number">56</span>:<span class="number">29</span>: (critical) network-conn-pool-lua.c<span class="number">.144</span>: socket() failed: Too many open files (<span class="number">24</span>)</span><br><span class="line"><span class="number">2014</span><span class="number">-04</span><span class="number">-12</span> <span class="number">20</span>:<span class="number">56</span>:<span class="number">29</span>: (warning) (libevent) event_del: event has no event_base set.</span><br><span class="line"><span class="number">2014</span><span class="number">-04</span><span class="number">-12</span> <span class="number">20</span>:<span class="number">56</span>:<span class="number">30</span>: (debug) chassis-unix-daemon.c:<span class="number">168</span>: <span class="number">12951</span> returned: <span class="number">12951</span></span><br><span class="line"><span class="number">2014</span><span class="number">-04</span><span class="number">-12</span> <span class="number">20</span>:<span class="number">56</span>:<span class="number">30</span>: (critical) chassis-unix-daemon.c:<span class="number">196</span>: [angel] PID=<span class="number">12951</span> died on signal=<span class="number">11</span> (it used <span class="number">16</span> kBytes max) ... waiting <span class="number">3</span>min before restart</span><br></pre></td></tr></table></figure></code></pre><p>如果MySQL后端的连接数也满了可能会报以下错误:</p><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2014</span><span class="number">-11</span><span class="number">-13</span> <span class="number">12</span>:<span class="number">21</span>:<span class="number">07</span>: (critical) network_mysqld_proto_password_scramble: assertion <span class="string">`20 == challenge_len' failed</span></span><br><span class="line"><span class="string">2014-11-13 12:21:07: (warning) (libevent) event_del: event has no event_base set.</span></span><br><span class="line"><span class="string">2014-11-13 12:21:07: (critical)</span></span><br></pre></td></tr></table></figure></code></pre><p>可以临时增加MySQL connection数量:</p><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo -n “Max processes=SOFT_LIMIT:HARD_LIMIT” &gt; <span class="regexp">/proc/</span><span class="string">`pidof mysqld`</span>/limits</span><br></pre></td></tr></table></figure></code></pre><h2><span id="出现too-many-open-files的错误怎么办"><font color="red">出现<code>Too many open files</code>的错误，怎么办？</font></span></h2><p>关于<code>Too many open files</code>错误，可能由两种情况引起:<br>一、php长连接连接到atlas后，每个线程占用一个FD,直到超出系统资源限制而出现too many错误;<br>二、php应用端发送到atlas的sql过多，大量并发的情况下,linevent维护的队列过多，每个event吃一个FD，超出系统资源限制引起<code>Too many open files</code>错误;</p><p>避免<code>Too many open files</code>错误,增加用户的ulimit值加大<code>FD</code>的使用量,可增加系统ulimit资源到 <code>~/.bash_profile</code>文件或<code>/etc/security/limits.conf</code>文件:</p><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># cat .bash_profile </span><br><span class="line"># .bash_profile</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="keyword">export</span> PATH</span><br><span class="line">ulimit -n <span class="number">16384</span></span><br></pre></td></tr></table></figure></code></pre>]]></content>
    
    <summary type="html">
    
      一口气连看17集《大明王朝1566》
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="atlas" scheme="http://yoursite.com/tags/atlas/"/>
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>如何手动释放linux内存</title>
    <link href="http://yoursite.com/2018/02/23/%E5%A6%82%E4%BD%95%E6%89%8B%E5%8A%A8%E9%87%8A%E6%94%BElinux%E5%86%85%E5%AD%98/"/>
    <id>http://yoursite.com/2018/02/23/如何手动释放linux内存/</id>
    <published>2018-02-23T12:57:35.000Z</published>
    <updated>2018-02-23T13:13:55.869Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>在生产过程中，一些java模块会比较残忍的吃系统内存，然后如果这个模块写的比较挫，产生的垃圾就会比较多，如果linux系统的内存释放也不会及时，然后恶性循环，最后就把进程卡死，但是服务器是不可以down机的，所以这个时候就需要我们运维出来，手动的释放内存。</p><p>首先，我们登陆一台服务器，<code>free -m</code>看一下目前的情况：<br><img src="/images/neicun1.png" alt="paradin"></p><p>然后<code>cat /proc/sys/vm/drop_caches</code>，会看到里面的值是0，0是不释放的意思。</p><p><code>sync</code>,将系统缓存区中的脏数据写入磁盘中，包括已修改的i-node、已延迟的块I/O和读写映射文件。</p><p><code>echo 3 &gt; /proc/sys/vm/drop_caches</code></p><p>为什么这里是<code>3</code>呢？这是因为<code>echo 1</code>的话代表“清理页面缓存”，<code>echo 2</code>的话代表“清理索引节点（inode）链接”，<code>echo 3</code>就是包括上面两者。</p><p><code>sysctl -p</code>,这样不用重启服务器也可以生效。出现下面的一连串文字之后，再<code>free -m</code>看一下：<br><img src="/images/neicun2.png" alt="paradin"></p><p>从112释放到2790，可见效果立竿见影。</p><p>上面整个过程的自动化脚本是这样的：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">#Author:Chris Chan</span><br><span class="line">#E-mail:chen_shuo@dahuatech.com</span><br><span class="line">oldmemory=$(free -m|sed -n <span class="string">'2p'</span>|awk <span class="string">'&#123;printf $4&#125;'</span>)</span><br><span class="line">echo <span class="string">"开始的空余内存值："</span>$oldmemory</span><br><span class="line">sync</span><br><span class="line">echo <span class="number">3</span> &gt; <span class="regexp">/proc/</span>sys/vm/drop_caches</span><br><span class="line">sysctl -p</span><br><span class="line">correctmemory=$(free -m|sed -n <span class="string">'2p'</span>|awk <span class="string">'&#123;printf $4&#125;'</span>)</span><br><span class="line">echo <span class="string">"释放完后的空余内存值："</span>$correctmemory</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      这里释放的内存主要是缓存的内存
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>回家过年</title>
    <link href="http://yoursite.com/2018/02/21/%E5%9B%9E%E5%AE%B6/"/>
    <id>http://yoursite.com/2018/02/21/回家/</id>
    <published>2018-02-21T08:08:40.000Z</published>
    <updated>2018-02-22T14:07:36.532Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>我承认我是一个很恋家的人，但是我在3年之前还不是这样。</p><p>我记得我在哈尔滨上大学的时候，虽然坐火车也就一个半小时的时间，但是是“能不回家就不回家”，哪怕自己一个人蹲在寝室也是自由舒服，后来上班，我也是有很长的时间自己独住，只有周末才回去一次。那时候我奶不止一次的批评我“都快成一个客人了”。</p><p>真的应了那句传烂了的话“只有失去的才是美好的”，现在我人在杭州，天天忙成狗。最欢喜的事情第一个是涨工资，第二个是发工资，第三个是放假，第四个就是放假回家。当初的我总是忽略家庭的温暖，在家里逗留的时间不长，现在却倍感珍惜回家的机会，唉，那几年真是简单的可笑。<br><img src="/images/jia5.jpg" alt="paradin"></p><p>这一次回家过年看到了许许多多亲人：生病的大姨夫的精神状态也好了许多，不过他这次回来又害了一次发烧；小外甥和他那婴儿肥的脸蛋，在《守望先锋》里越死越勇；我那几个弟弟们全都瘦了也更精神了，从我妈和女票看我的眼神里，我觉得我的体重是应该好好管控一下了：体型太腐败。</p><p>短短的六天时间，吃完三姨家吃四姨家，吃完老叔家吃小舅家，总之就是带着女票游走于各种亲戚家。中途还抽空跟龙南数据班的几个老同事一起吃了顿“一口猪”，主要也是带我女票看看东北菜，看上去我这几个老同事们都过得很不错，至少几杯酒下去均红光满面，依旧插科打屁、大呼小叫。这次过年唯一可惜的是，没有给四姨夫装上翻墙软件，害得他要继续挠墙忍耐。</p><p>我吃我妈的菜已经吃了30年，但是这次过年真正在家里吃饭仅仅只有一顿。我妈烧了虾，做了孜然羊肉，而且煮了酸菜馅饺子。这都是我爱吃的，杭州的确能吃到很多美味，但我妈的手艺却是独一份儿。我跟我爹依旧话不算多，但是关系却比之前好了许多倍。有可能是我现在比以前有了一点进步，让我爸看起来顺眼了一点，这一次回家没有跟我爸单独喝上酒，但是他有几顿喝的很开心。看到他俩这个年过得快乐满足，我这个做儿子的，心底涌起了最大的温暖。</p><p>离开家的时候，依旧是箱子沉沉，里面有爸妈装的许多东西，有给我的也有给我女票她妈的，每一个东西都是代表了他们的心思。其实家中长辈身体健康、心情愉悦，就是给我们这些在外的儿女最大的宽慰了。假期就这样结束了，我也马上要踏上回杭州的航班，希望家里所有长辈都平平安安，也希望我今年能够达到自己给自己定下的目标！<br><img src="/images/quanjiafu.jpg" alt="paradin"></p>]]></content>
    
    <summary type="html">
    
      最期盼的假期，已经余额不足了...
    
    </summary>
    
      <category term="坠乱花天" scheme="http://yoursite.com/categories/%E5%9D%A0%E4%B9%B1%E8%8A%B1%E5%A4%A9/"/>
    
    
      <category term="春节" scheme="http://yoursite.com/tags/%E6%98%A5%E8%8A%82/"/>
    
      <category term="心情" scheme="http://yoursite.com/tags/%E5%BF%83%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>中国梦，宪政梦</title>
    <link href="http://yoursite.com/2018/02/13/%E4%B8%AD%E5%9B%BD%E6%A2%A6%EF%BC%8C%E5%AE%AA%E6%94%BF%E6%A2%A6/"/>
    <id>http://yoursite.com/2018/02/13/中国梦，宪政梦/</id>
    <published>2018-02-12T17:00:57.000Z</published>
    <updated>2018-02-13T04:26:08.912Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p><strong>本文原作者：《南方周末》评论部编辑戴志勇</strong></p><p>天地之间，时间绽放。</p><p>这是我们在2013年的第一次相见，愿你被梦想点亮。</p><p>2012年，你守护自己的生活，他们守护自己的工作。守护这份工作，就是在守护他们对生活的梦想。</p><p>2012年，庙堂之上发出的宪政强音嗡然回响：”宪法的生命在于实施，宪法的权威也在于实施。”我们期待宪法长出牙齿，宪政早日落地。惟如此，才能成就这个沧桑古国的艰难转型；惟如此，国家与人民，才能重新站立于坚实的大地之上。</p><p>今天，已是能够梦想的中国，今天，已是兑现梦想的时代。经历过宪政缺失的”文革”梦魇，我们花费三十多年的时间来逐渐回归常理与常情。从土地联产承包责任制到个体户、乡镇企业到”民企”，稍稍归还国人自主安排生活的权利，我们便创造了繁华城市，收获了满仓粮食。</p><p>我们重新体认什么是真，什么是假，是其是，非其非；我们重燃对公义的热爱，对自由的向往。面对暴虐强力，我们双手相握，一起走过艰难时刻，迎接生活转机。</p><p>今天，我们终于可以从厚厚的历史尘埃中挺起胸，从琐碎的日常生活中抬起头，重走先辈的宪政长征，重温先辈的伟大梦想。</p><p>一百七十多年前，我们开始从天朝上国的迷梦中醒来。先败于英，后败于日。百姓愈加民不聊生，耻感深深刺痛中国士人。保国！保种！由洋务而君宪，由立宪而革命。从器物到制度再至文化，激愤者不惜彻底打倒”孔家店”，决绝地将自己的文明连根拔起。</p><p>辛亥革命后，清帝退位，先辈们终于建立了亚洲第一个共和国。但是，一个自由、民主、富强的宪政中国并没有随之而来。</p><p>国家内外，战争连连；人群内外，残酷不断。</p><p>一度，人们远离仁，远离义，远离天道，远离对自由的坚守。</p><p>一度，人们认错为对，指鹿为马，万千生灵生机断绝。</p><p>美梦与山河，齐齐破碎。自由与宪政，双双消隐。</p><p>度尽人世劫波，深味人性幽暗，我们依然是能做梦的人，有颗能做梦的心。</p><p>今天，我们断断不只梦想物质丰盛，更希望性灵充盈；我们断断不只梦想国力能强盛，更希望国民有自尊。新民和新国，救亡与启蒙，谁也离不开谁，谁也不能压倒谁。而宪政便是这一切美梦的根基。</p><p>兑现宪政，坚守权利，人人才能心如日月流光溢彩；鳏寡孤独才能感受冬日暖意而非瑟瑟发抖；”城管”与小贩才能谈笑风生；房屋才能成为自己与家人的城堡；</p><p>兑现宪政，限权分权，公民们才能大声说出对公权力的批评；每个人才能依内心信仰自由生活；我们才能建成一个自由的强大国家。</p><p>兑现宪政大梦，每个人才能做好个人的美梦。而这需要我们就从手边做起，就从守护此时此刻的生活做起，而不要将重任留给子孙。</p><p>很多人一直深深懂得这一点，很多人早就努力践行这一点。</p><p>不是杰出者才做梦，是善于做梦者才杰出。</p><p>你的天赋权利就是可以梦想，并且兑现梦想！</p><p>为你的梦想鼓掌，为这个国家的梦想加油，这就是很多新闻人的梦想，是他们不大不小的野心。他们忠于新闻，更忠于内心。愿你也有个玫瑰色的美梦；自由成就自己，完成天之所赋。</p><p>总会梦想人人都可以做一个有尊严的人，不论身居高位，还是街头卖艺；</p><p>总会梦想人人内心有爱，即使罪犯也未必穷凶极恶，总有恻隐之心自由闪动；</p><p>总会梦想阶层只是引人自由流动的动力，而不再是相互猜忌和仇视的天堑；总会梦想这五千年文明生生不息，为改善人类的现代处境，捧出一掬甘冽清泉……</p><p>兑现这一千一万个梦想，才能抚平这一百多年的刻骨痛楚。</p><p>兜兜转转一百七十年，美梦成真何其难！一百七十年后，依然有人渴望良知萌新芽，重温天命之谓性；依然有人坚持要求权利一一落地，政治复归于正，公义自在流淌。</p><p>依然有人相信，不管多难，梦想终会落实为宪政良制，风行为敦敦美俗。</p><p>先辈们筚路蓝缕，践义成仁。如今，后人承继其志，燃灯前行。</p><p>兑现梦想，自然要借鉴前贤智慧，与古人的信仰、习俗和情感和解。儒释道法墨，百家皆是源泉；周汉唐宋明，代代皆有可取。</p><p>但这决不是要复古，古人不能给予今天所需的一切。只是不再轻易贬损先辈，平心静气地吸收转进，以让中华文明开新花，结新果。</p><p>兑现梦想，自然要吸取世界经验。所以要认真审视希腊民主，罗马法治，借鉴英美宪政，追赶现代科技文明。</p><p>但这也不是仅仅作一个西方文明的优等生，西人有西人演进的轨迹，同样未必能直接给予我们今天所需的一切。</p><p>我们要站在自己的大地上，与各国人民一起，生活出一种古今相融的新生活，文明出一种中西合璧的新文明。在古今中西的激荡中，要遵循人类共通的价值，也要不惮于做自己的新梦。</p><p>称美古人，赞扬邻居，不是因为他们足够完美，而是因为我们熟悉他们眼中洋溢的快乐，心底流淌的自由。</p><p>中国人本应就是自由人。中国梦本应就是宪政梦。</p><p>宪政之下，才能国家持续强盛，宪政之下，才有人民真正强大。兑现宪政梦想，才能更好地外争国权，维护国家的自由；才能更好地内争民权，维护人民的自由。而国家的自由最终必得落脚于人民的自由，必得落脚于人人可以我口说我心，人人可以用心做美梦。</p><p>生而为人，谁能不热爱自由？这自由，不仅是权利针对权力而言，也是宽恕针对报复而言，是般若针对无明而言，是仁爱针对暴虐而言，是有道针对无道而言。</p><p>大道之行，天下为公；万物自在，各正性命。这就是古人的梦想，先辈的梦想，也是今天很多人的梦想。</p><p>中国梦，自由梦，宪政梦。</p><p>万物速朽，但梦想永在。万物诞生，因梦想不灭。梦想就是生生之几，就是当你失败了一百次，那第一百零一次充实你内心的不死之希望。</p><p>依然有人倾听你的梦想，期待你敢于做梦。你从苦难中爬起，他们为你加油；你尝尽人世冷暖，他们为你加油；你收获美好生活，他们为你加油……他们别无所资，惟有对梦想的执着；他们别无所长，惟有对真相的追求。</p><p>一句真话能比整个世界还重，一个梦想能让生命迸射光芒！</p>]]></content>
    
    <summary type="html">
    
      谨以此文纪念“南方周末事件”
    
    </summary>
    
      <category term="坠乱花天" scheme="http://yoursite.com/categories/%E5%9D%A0%E4%B9%B1%E8%8A%B1%E5%A4%A9/"/>
    
    
      <category term="中国政治" scheme="http://yoursite.com/tags/%E4%B8%AD%E5%9B%BD%E6%94%BF%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>关于logrotate的额外补充</title>
    <link href="http://yoursite.com/2018/02/12/%E5%85%B3%E4%BA%8Elogrotate%E7%9A%84%E9%A2%9D%E5%A4%96%E8%A1%A5%E5%85%85/"/>
    <id>http://yoursite.com/2018/02/12/关于logrotate的额外补充/</id>
    <published>2018-02-12T12:09:27.000Z</published>
    <updated>2018-02-12T14:28:49.154Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p><code>https://rorschachchan.github.io/2018/02/12/日志文件管理者：Logrotate/</code> 里面已经简单介绍了logrotate命令，这里还有一些额外补充的东西：</p><p>1）查看logrotate对log文件的具体执行情况的语句是<code>cat /var/lib/logrotate.status</code>，效果如图：<br><img src="/images/logrotate6.png" alt="paradin"></p><p>2）使用<code>-v</code>或<code>-d</code>参数时，显示<code>log does not need rotating</code>，这是因为logrotate在对status未记录的文件进行转储时，会在status添加一条该文件的记录，并将操作时间设为当天。之后程序再次对此文件进行转储时发现这个文件今天已经操作过，就不再进行相关操作。要是想解决这个问题可以使用<code>-s</code>指定logrotate状态文件；</p><p>3）分割日志时报错：<code>error: skipping &quot;/var/log/nginx/test.access.log&quot; because parent directory has insecure permissions (It&#39;s world writable or writable by group which is not &quot;root&quot;) Set &quot;su&quot; directive in config file to tell logrotate which user/group should be used for rotation.</code>这是当前用户不是root，需要添加<code>su root list</code>这个语句到对应的logrotate配置文件里，比如：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">var</span>/log/nginx<span class="comment">/*.log &#123;</span></span><br><span class="line"><span class="comment">        su root list#第一句添加</span></span><br><span class="line"><span class="comment">        daily</span></span><br><span class="line"><span class="comment">        missingok</span></span><br><span class="line"><span class="comment">        rotate 52</span></span><br><span class="line"><span class="comment">        compress</span></span><br><span class="line"><span class="comment">        delaycompress</span></span><br><span class="line"><span class="comment">        notifempty</span></span><br><span class="line"><span class="comment">        #ifempty</span></span><br><span class="line"><span class="comment">        create 0640 www-data adm</span></span><br><span class="line"><span class="comment">        sharedscripts</span></span><br><span class="line"><span class="comment">        postrotate</span></span><br><span class="line"><span class="comment">                [ ! -f /var/run/nginx.pid ] || kill -USR1 `cat /var/run/nginx.pid`</span></span><br><span class="line"><span class="comment">        endscript</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4）如果觉得使用`logrotate`很麻烦，而当某个文件过大的时候，要实现把该文件压缩并且拆成若干个指定大小的文件，怎么办？</span></span><br><span class="line"><span class="comment">```js</span></span><br><span class="line"><span class="comment">tar -zcvf 新文件名.tar.gz 原文件名 | split -b 每个分格包大小 -d -a 1 - 新文件名.tar.gz</span></span><br></pre></td></tr></table></figure></p><p>比如：<code>tar -zcvf ABC.tar.gz ABC | split -b 4000M -d -a 1 - ABC.tar.gz</code>。这个命令就是把ABC这个文件压缩成ABC.tar.gz，但是如果ABC大于4000M就会切块，切成ABC.tar.gz.0,ABC.tar.gz.1,ABC.tar.gz.2……这个样子。<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用split命令，-b 4000M 表示设置每个分割包的大小，单位还是可以k</span></span><br><span class="line"><span class="comment">// -d 参数指定生成的分割包后缀为数字的形式</span></span><br><span class="line"><span class="comment">//-a x来设定序列的长度(默认值是2)，这里设定序列的长度为1</span></span><br></pre></td></tr></table></figure></p><p>如果要把这一堆已经切块的文件重新接压缩的命令：<code>cat ABC.tar.gz.* | tar -zxv</code>;</p><p>5）如果用<code>kill -HUP</code>来重启一个包含守护进程的进程，比如httpd，一条语句搞定：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep httpd | grep -v grep | awk <span class="string">'&#123; print $2; &#125;'</span> | xargs -L <span class="number">1</span> sudo kill -HUP</span><br></pre></td></tr></table></figure></p><p>这里面首先用awk获取到httpd的pid进程号，然后把这个进程号传给了xargs，通过<code>-L 1</code>来一次提取一行pid值，然后分批进行<code>kill -HUP</code>;</p><p>6）想更多的了解守护进程，参看<code>http://www.cnblogs.com/mickole/p/3188321.html</code>；</p><p><img src="/images/slamdunk.jpg" alt="paradin"></p>]]></content>
    
    <summary type="html">
    
      祝各位看官新春快乐！！！
    
    </summary>
    
      <category term="技术与工作" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E4%BD%9C/"/>
    
    
      <category term="运维技术" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4%E6%8A%80%E6%9C%AF/"/>
    
      <category term="logrotate" scheme="http://yoursite.com/tags/logrotate/"/>
    
  </entry>
  
  <entry>
    <title>日志文件管理者：Logrotate</title>
    <link href="http://yoursite.com/2018/02/12/%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E8%80%85%EF%BC%9ALogrotate/"/>
    <id>http://yoursite.com/2018/02/12/日志文件管理者：Logrotate/</id>
    <published>2018-02-12T11:57:18.000Z</published>
    <updated>2018-02-12T12:07:05.274Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="前言">前言</span></h2><p>服务器在服务运行的时候，难免会生成大量日志，一般来说遇到日志过多的情况，就会写一个看门狗：监控磁盘容量的大小，如果磁盘剩余空间小于某个值，就去日志文件夹里把一个月或者几个月之前的废弃日志删除掉以达到释放磁盘空间的目的。</p><p>但是往往有的时候过期的日志很重要，或者即使是一周的时间内，也会生成容量非常可观的日志，那么就需要使用logrotate命令来管理这些日志，这个命令是linux自带的。</p><p>logrotate这个命令的用法请看：<code>https://linux.cn/article-8227-1-rel.html</code>和<code>https://linux.cn/article-4126-1.html</code> 。</p><h2><span id="实验开始">实验开始</span></h2><p>首先，假设服务器里某个日志文件夹里的日志<code>auc.log.10</code>是这样的：<br><img src="/images/logrotate1.png" alt="paradin"></p><p>然后在logrotate的配置文件是这么写的：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/mnt/hswx/auc/logs/auc.log<span class="number">.10</span> &#123;             这里是目标日志的绝对路径</span><br><span class="line">       daily        每天执行一次</span><br><span class="line">       minsize <span class="number">200</span>M    文件容量大于<span class="number">200</span>M开始处理，如果到了时间但是没有大于<span class="number">200</span>M，不会处理</span><br><span class="line">       compress          压缩</span><br><span class="line">       dateext          文件会以日期为后缀</span><br><span class="line">       create <span class="number">777</span> root root    新建的那个日志文件属性是<span class="number">777</span></span><br><span class="line">       rotate <span class="number">2</span>         保留最多<span class="number">2</span>个文件</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后执行<code>logrotate -vf /etc/logrotate.conf</code>，看到的效果是：<br><img src="/images/logrotate2.png" alt="paradin"></p><p>命令执行后，服务器create了新的<code>auc.log.10</code>，而且属性变成了777，同时把原有的部分压缩成gz的格式。</p><p>上面那个测试的对象是已经过期的日志，现在我们要压缩当前的日志，目的是<code>在压缩了auc.log并且重命名之后，可以生成新的auc.log，同时这个新的auc.log会被写入</code>。</p><p>现在我们尝试一下，把原来的配置文件改成这样：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/mnt/hswx/auc/logs/auc.log &#123;</span><br><span class="line">       weekly</span><br><span class="line">       minsize <span class="number">200</span>M</span><br><span class="line">       compress</span><br><span class="line">       rotate <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是执行之后，我们发现变成了这样：<br><img src="/images/logrotate3.png" alt="paradin"></p><p>原来的<code>auc.log</code>不见了，而出现的<code>auc.log.1</code>里面的内容是原来<code>auc.log</code>的内容，可见原有的<code>auc.log</code>已经被顶掉了。这是因为我们上面的配置文件里面没有加上<code>dateext</code>，所以默认会以<code>.1、.2、.3</code>为后缀。</p><p>问题是我们没有生成<code>auc.log</code>，那么这段时间的日志就会找不到<code>auc.log</code>而凭空消失。可见这个方法没有达到我们的目的，需要改进。</p><h2><span id="改进之后">改进之后</span></h2><p>我们这个内部模块auc只有重新启动这个进程才会生成<code>auc.log</code>，既然要解决这样的问题，我们很自然的就想到<code>kill -HUP</code>这种平滑启动的方式，但是要注意！<code>kill -HUP</code>对deamon会进行重新读取配置启动，但是对于普通的进程只会把其杀死！而这个auc就是一个普通的java程序，没有配套的守护进程。所以只能使用一般的重启方式来达到生成<code>auc.log</code>这个目的。</p><p>首先我们把原来的配置文件改成这样：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/mnt/hswx/auc/logs/auc.log &#123;</span><br><span class="line">       weekly    #每周执行</span><br><span class="line">       dateext    #以日期作为后缀</span><br><span class="line">       minsize 200M    #到达了200M自动执行，不然即使到了一周的时间也不执行</span><br><span class="line">       compress    #压缩</span><br><span class="line">       rotate 2    #最多保留两个文件</span><br><span class="line">       sharedsripts    </span><br><span class="line">       postrotate    #在执行完日志压缩之后就执行如下动作</span><br><span class="line">               /bin/bash /root/restart.sh    #动作就是执行这个绝对路径的脚本</span><br><span class="line">       endscript    #收工</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而这个<code>restart.sh</code>的内容很简单:<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">cd /mnt &amp;&amp; ./stopAUC.sh    #停止auc进程</span><br><span class="line">cd /mnt &amp;&amp; ./startAUC.sh    #启动auc进程</span><br><span class="line">echo HAHAHAHA！！！    #表示已经OK了，让我们发出杠铃一般的笑声</span><br></pre></td></tr></table></figure></p><p>现在我们重新跑一下logrotate，<code>logrotate -vf /etc/logrotate.conf</code>。看一下效果：<br><img src="/images/logrotate4.png" alt="paradin"></p><p>可以看到先把日志改名压缩，完事后也执行了<code>restart.sh</code>这个脚本，再日志里一看，<code>auc.log</code>也顺利生成了！<br><img src="/images/logrotate5.png" alt="paradin"></p><h2><span id="参考资料">参考资料</span></h2><p><a href="http://www.pythondev.org/post/8.html" target="_blank" rel="noopener">http://www.pythondev.org/post/8.html</a></p>]]></content>
    
    <summary type="html">
    
      rotate是“轮转、交替、转动、试转动”的意思
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="运维技术" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>一个暗藏杀机的脚本</title>
    <link href="http://yoursite.com/2018/02/11/%E4%B8%80%E4%B8%AA%E6%9A%97%E8%97%8F%E6%9D%80%E6%9C%BA%E7%9A%84%E8%84%9A%E6%9C%AC/"/>
    <id>http://yoursite.com/2018/02/11/一个暗藏杀机的脚本/</id>
    <published>2018-02-11T07:13:54.000Z</published>
    <updated>2018-02-11T07:19:46.610Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="脚本背景">脚本背景</span></h2><p>老总最近总是发现某台relay服务器的CPU值会突然彪很高，于是勒令几位工程师检查问题，但是工程师一时半会也想不到究竟是什么程序这么耗费CPU，于是就委托运维写一个脚本，具体要求是这样的：每隔一秒钟输出一下top命令的前十二行情况（其实就是配置总览和耗费cpu前五名程序情况），将这些情况保存到一个文件里，如果这个文件大于500MB，就把这个文件删除（为啥要删除？我也不知道），重新再生成一个文件用来保存top命令结果。</p><h2><span id="分析">分析</span></h2><p>由于脚本无法自己跳出运行并检查自己的大小，所以这个任务需要两个脚本，一个是单纯的把top命令重定向到一个文件（recordTOP.sh），另一个脚本就是一个if判断大小（checksize.sh）。再加上crontab每一天一检查（其实完全没必要，500MB足够top这个命令跑5天的），应该可以满足开发人员的需求。</p><h2><span id="脚本内容">脚本内容</span></h2><p>获取<code>top.txt</code>的脚本<code>recordTOP.sh</code>如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">#written by ChenShuo @2016-8-15</span><br><span class="line">#Desription:每一秒钟记录一次top命令里占用cpu前五程序</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">                $(top -bn <span class="number">1</span> | head <span class="number">-12</span> &gt;&gt; <span class="regexp">/root/</span>top.txt)</span><br><span class="line">                echo <span class="string">"------------------------------------------------"</span> &gt;&gt; <span class="regexp">/root/</span>top.txt</span><br><span class="line">                sleep <span class="number">1</span></span><br><span class="line">        done</span><br></pre></td></tr></table></figure></p><p>判断<code>top.txt</code>大小的脚本<code>checksize.sh</code>如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">#written by ChenShuo @2016-8-15</span><br><span class="line">#Desription:当recordTOP.sh文件大小超过500MB的时候将会重新覆盖</span><br><span class="line">size=$(ls -l | grep top.txt |cut -d <span class="string">" "</span> -f <span class="number">5</span>)</span><br><span class="line"><span class="keyword">if</span> [[ $size -ge <span class="number">536870912</span> ]]</span><br><span class="line">        then</span><br><span class="line">                $(ps -ef|grep recordTOP.sh|grep -v grep|awk <span class="string">'&#123;print $2&#125;'</span>|xargs kill <span class="number">-9</span>)</span><br><span class="line">                $(rm -rf /root/top.txt)</span><br><span class="line">                bash /root/recordTOP.sh &amp;</span><br><span class="line">        fi</span><br></pre></td></tr></table></figure></p><p><code>crontab</code>这一步我就略掉不写了。</p><h2><span id="补充说明">补充说明</span></h2><p>1）top不可以直接重定向，如果是<code>top &gt; 123.txt</code>，它将会不断的导入，因为top就是一个实时更新的命令，所以这里要用<code>top -bn 1|head 12 &gt;&gt; /top.txt</code>；</p><p>2）shell脚本里调用shell，不能采用<code>$()</code>的方法了，因为<code>$()</code>是一个返回值，而.sh是一个不断进行的脚本，所以要用<code>bash +脚本名</code>的方式；</p><p>3）recordTOP.sh这个脚本是可以同时存在多个的，但是如果不小心后台启动多个，用checksize脚本ps -ef语句就会报错，因为获得到的不是一个数字，而是多个数字，没法一波kill掉。同理，直接调用checksize也会报错，因为没有ps -ef的值；</p><p>4）因为是要先关闭原来的top重定向脚本，所以才用了保守的ps -ef，然后kill的方式，这里不可以使用pkill，因为pkill是干掉整个类型程序，比如<code>pkill -9 java</code>，就是干掉所有java的进程。而在linux里，千万不可以<code>pkill -9 sh</code>，可以想象一下，这个命令的结果就是会从ssh上跳出，同时无法登陆，因为整个sh都被你杀死了。那么真的出现了这个结果怎么办？答曰：重启，重启能救命。</p><p>整个执行效果如下，可见top.txt文件是在不断的扩大，由于是测试，我把文件大小调整为20000字节，即大于20000字节就覆盖原文件，当文件大于20000字节的时候，就会把原来的top.txt删除，同时生成一个新的top.txt。<br><img src="/images/top5.png" alt="paradin"></p>]]></content>
    
    <summary type="html">
    
      shell里面调用shell，这是一个坑。
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
      <category term="top" scheme="http://yoursite.com/tags/top/"/>
    
  </entry>
  
  <entry>
    <title>http返回码是000...</title>
    <link href="http://yoursite.com/2018/02/11/http%E8%BF%94%E5%9B%9E%E7%A0%81%E6%98%AF000/"/>
    <id>http://yoursite.com/2018/02/11/http返回码是000/</id>
    <published>2018-02-11T01:51:39.000Z</published>
    <updated>2018-02-11T02:08:46.611Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="正文">正文</span></h2><p>今天开发童鞋在测试往一个网站发请求的时候，发现返回码是000，如图：<br><img src="/images/http0001.png" alt="paradin"></p><p>众所周知，常见的返回码是以下四种：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>XX 成功；</span><br><span class="line"><span class="number">3</span>XX 重定向；</span><br><span class="line"><span class="number">4</span>XX 客户端错误；</span><br><span class="line"><span class="number">5</span>XX 服务器端错误；</span><br></pre></td></tr></table></figure></p><p>但是000是啥玩意？简单的说就是没有有效的http状态码，比如连接被拒绝，连接超时等。</p><p>使用<code>curl -w &quot;%{http_code}\n&quot; -m 5 https://60.191.94.115:38303/cloudSignalling/events/deviceState ; echo &quot;Exit code: $?</code>看一下详细的code，显示如图：<br><img src="/images/http0002.png" alt="paradin"></p><p>可以看到提示：<code>curl: (60) Peer certificate cannot be authenticated with known CA certificates</code>，翻译过来就是<code>对方的证书不能用已知的CA证书验证</code>。但是下面也说了可以用<code>-k</code>或者<code>--insecure</code>来跳过这一步。</p><p>于是我又使用<code>curl -I -k https://60.191.94.115:38303/cloudSignalling/events/deviceState</code>这个命令，效果如图：<br><img src="/images/http0003.png" alt="paradin"></p><p>里面这一下说的就很明白了，405，方法不正确，再搭配一下<code>curl -k -w &quot;%{http_code}\n&quot; -m 5 https://60.191.94.115:38303/cloudSignalling/events/deviceState</code>，看一下：<br><img src="/images/http0004.png" alt="paradin"></p><p>这么上下一结合，明白了GET是不准许的，准许POST。于是反馈给60.191.94.115告诉他们把前后台接口请求方式、参数传递方式都拿回去整改。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="http://www.1987.name/365.html" target="_blank" rel="noopener">http://www.1987.name/365.html</a><br><a href="https://superuser.com/questions/501690/curl-http-code-of-000" target="_blank" rel="noopener">https://superuser.com/questions/501690/curl-http-code-of-000</a></p>]]></content>
    
    <summary type="html">
    
      站好春节前的最后两班岗...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="http" scheme="http://yoursite.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>将redis加入到elk日志系统里</title>
    <link href="http://yoursite.com/2018/02/09/%E5%B0%86redis%E5%8A%A0%E5%85%A5%E5%88%B0elk%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E9%87%8C/"/>
    <id>http://yoursite.com/2018/02/09/将redis加入到elk日志系统里/</id>
    <published>2018-02-09T09:14:18.000Z</published>
    <updated>2018-02-09T09:40:44.505Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>之前在<code>https://rorschachchan.github.io/2018/01/16/记录日志系统ELKB-5-6-4的搭建过程/</code>里面，我画的那个架构图里说了整个架构可以加入redis，但是在文章里我没有写到redis怎么加进去。为了让整个系统更好的分层，是非常建议引入Redis的，毕竟Redis服务器是logstash官方推荐的broker选择。Redis作为一个缓存，能够帮助我们在主节点上屏蔽掉多个从节点之间不同日志文件的差异，负责管理日志端（从节点）的人可以专注于向 Redis 里生产数据，而负责数据分析聚合端的人则可以专注于从Redis内消费数据。所以这一次实验要把redis加进去，同时也要部署一个nginx，让elk再去采集nginx的日志。</p><p>整个架构图图下：<br><img src="/images/elkredis1.png" alt="paradin"></p><h2><span id="部署redis">部署redis</span></h2><p>安装redis的方法请去看<code>http://blog.51cto.com/chenx1242/1793895</code>，我这里使用的redis版本是<code>4.0.6</code>，在执行<code>make test</code>的时候可能会有如下的错误：<br><img src="/images/elkredis2.png" alt="paradin"></p><p>那就安装新一点的<code>tcl</code>吧，方法如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget http:<span class="comment">//downloads.sourceforge.net/tcl/tcl8.6.1-src.tar.gz</span></span><br><span class="line">tar xzvf tcl8<span class="number">.6</span><span class="number">.1</span>-src.tar.gz  -C /usr/local/</span><br><span class="line">cd  /usr/local/tcl8<span class="number">.6</span><span class="number">.1</span>/unix/</span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure></p><p>然后重新去<code>make test</code>就会看到成功的字样，如图：<br><img src="/images/elkredis3.png" alt="paradin"></p><p>现在redis的漏洞比较多，大多数就是因为密码太简单导致的，所以把redis密码改一下，在<code>redis.conf</code>里，改成如下的样子：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bind 内网IP地址 127.0.0.1              ###仅允许内网和本机访问</span><br><span class="line">protected-mode yes                   ###保护模式开启</span><br><span class="line">port 6379                          ###端口默认为6379，按需修改</span><br><span class="line">daemonize yes                        ###守护模式开启</span><br><span class="line">pidfile /usr/local/redis/redis.pid               ###指定pid文件路径和文件名</span><br><span class="line">logfile "/usr/local/redis/redis.log"             ###指定日志文件路径和文件名</span><br><span class="line">dbfilename redis.rdb                     ###指定数据文件RDB文件名</span><br><span class="line">dir /usr/local/redis/                    ###指定数据文件RDB文件的存放路径</span><br><span class="line">requirepass 『YOURPASSWORD』              ###设置访问密码，提升密码强度</span><br></pre></td></tr></table></figure></p><p>保存之后启动redis即可。</p><p>如果redis是主从配置，若master配置了密码则slave也要配置相应的密码参数否则无法进行正常复制的。需要在slave的<code>redis.conf</code>里找到<code>#masterauth  mstpassword</code>，去掉注释，也改成跟master一样的密码，重启一下即可。 </p><p>nginx的安装这里就不写了，直接看<code>http://www.runoob.com/linux/nginx-install-setup.html</code>这个就行了。</p><h2><span id="安装x-pack">安装x-pack</span></h2><p>x-pack是elk官方提供的认证授权插件，安装方法很简单，分别找到下面三个文件，然后后面加上<code>install x-pack</code>即可：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./elasticsearch-plugin install x-pack --batch </span><br><span class="line">./logstash-plugin install x-pack </span><br><span class="line">./kibana-plugin install x-pack</span><br></pre></td></tr></table></figure></p><p>如果要查看已经安装的插件，那就是：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@chen-elk-001 bin]# ./elasticsearch-plugin list</span><br><span class="line">x-pack</span><br><span class="line">[root@chen-elk-001 bin]# ./kibana-plugin list</span><br><span class="line">x-pack@<span class="number">5.6</span><span class="number">.4</span></span><br></pre></td></tr></table></figure></p><p>如果kibana-plugin要卸载x-pack，那就是：<code>./kibana-plugin remove x-pack</code>。</p><p>重启服务即可登录，默认的登录用户名: <code>elastic</code>，密码:<code>changeme</code>。<br><img src="/images/elkredis4.png" alt="paradin"><br><img src="/images/elkredis5.png" alt="paradin"></p><p>这里注意一下，<code>./logstash-plugin install x-pack</code>的时候可能是出现ruby源的错误，如图：<br><img src="/images/elkredis6.png" alt="paradin"></p><p>这是因为中国特色社会主义的网络限制访问<code>https://rubygems.org</code>，一般来说，可以把它更改成阿里的ruby源<code>https://ruby.taobao.org/</code>，不过如果你的服务器无法跨越长城的话，那么更改也是不好使的，所以在这一步，我选择离线安装x-pack。也就是先把<code>https://artifacts.elastic.co/downloads/packs/x-pack/x-pack-5.6.4.zip</code>这个文件下载到本地上传到服务器的root文件夹里，然后安装：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@chen-logstash-001 bin]# ./logstash-plugin install file:///root/x-pack-5.6.4.zip</span><br><span class="line">Installing file: <span class="regexp">/root/</span>x-pack<span class="number">-5.6</span><span class="number">.4</span>.zip</span><br><span class="line">Install successful</span><br></pre></td></tr></table></figure></p><h2><span id="配置filebeat">配置filebeat</span></h2><p>由于这个nginx我们需要先让filebeat把<code>nginx.log</code>和<code>error.log</code>先推到redis存储，然后再由redis推到logstash。配置<code>filebeat.yml</code>的具体信息如下:<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@iZbp10hw6wezxmrvrcjyhlZ filebeat]# grep -iv '#' /etc/filebeat/filebeat.yml | grep -iv '^$'</span><br><span class="line">filebeat.prospectors:</span><br><span class="line">- input_type: log</span><br><span class="line">  paths:</span><br><span class="line">    - <span class="regexp">/usr/</span>local/nginx/logs<span class="comment">/*.log    #这里是nginx的日志文件夹</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">output.redis:                #以下这部分都是新加的</span></span><br><span class="line"><span class="comment">  enabled: true</span></span><br><span class="line"><span class="comment">  hosts: ["127.0.0.1:6379"]</span></span><br><span class="line"><span class="comment">  key: logindexer_list            #与redis配置文件里的key遥相呼应</span></span><br><span class="line"><span class="comment">  password: 『YOURPASSWORD』    #跟上面的密码遥相呼应</span></span><br></pre></td></tr></table></figure></p><p>配置完毕之后，启动filebeat，命令语句：<code>/etc/init.d/filebeat start -c /etc/filebeat/filebeat.yml</code>。</p><h2><span id="配置logstash">配置logstash</span></h2><p>由于这台logstash已经开启了一个logstash进程，那么再收集nginx的日志需要新开一个logstash进程，也需要新写一个conf文件，假设新的conf文件是<code>nginx-logstash.conf</code>，它的写法如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">    redis &#123;</span><br><span class="line">        host =&gt; <span class="string">"10.168.173.181"</span></span><br><span class="line">        type =&gt; <span class="string">"redis-input"</span></span><br><span class="line">        data_type =&gt; <span class="string">"list"</span></span><br><span class="line">        key =&gt; <span class="string">"logindexer_list"</span></span><br><span class="line">        port =&gt; <span class="number">6379</span></span><br><span class="line">        password =&gt; <span class="string">"ChenRedi$"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># filter configration here</span><br><span class="line">output &#123;</span><br><span class="line">     elasticsearch &#123;</span><br><span class="line">        hosts =&gt; [ <span class="string">"10.162.80.192:9200"</span> ]</span><br><span class="line">        user =&gt; elastic</span><br><span class="line">        password =&gt; changeme</span><br><span class="line">        index =&gt; "nginxlogstash-%&#123;+YYYY.MM.dd&#125;"        #这个是新的索引</span><br><span class="line">    &#125;</span><br><span class="line">stdout &#123;</span><br><span class="line">    codec =&gt; rubydebug</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在logstash不支持多个实例共享一个<code>path.data</code>，所以要在在启动不同实例的时候，命令行里增加<code>--path.data PATH</code>，为不同实例指定不同的路径。启动logstash之后，看到显示如下：<br><img src="/images/elkredis7.png" alt="paradin"></p><p>再到nginx的日志看一下，因为logstash里没有做日志的切割，所以是整个一个类似字符串的形式发送了过来：<br><img src="/images/elkredis8.png" alt="paradin"></p><p>果然有这样的日志，可见logstash与nginx的redis已经正确连接。在elasticsearch里，使用<code>curl -u 账号密码 &#39;localhost:9200/_cat/indices?v&#39;</code>查询索引的时候，就会看到那个<code>nginxlogstash</code>，如图：<br><img src="/images/elkredis9.png" alt="paradin"></p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://doc.yonyoucloud.com/doc/logstash-best-practice-cn/input/redis.html" target="_blank" rel="noopener">https://doc.yonyoucloud.com/doc/logstash-best-practice-cn/input/redis.html</a></p>]]></content>
    
    <summary type="html">
    
      整个搭建完毕之后，redis可能key是0，这是正常现象，因为日志量少，直接就消费掉了。
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
      <category term="elk" scheme="http://yoursite.com/tags/elk/"/>
    
      <category term="大数据分析" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Mysql-Atlas从库始终没有建立连接怎么办</title>
    <link href="http://yoursite.com/2018/02/09/Mysql-Atlas%E4%BB%8E%E5%BA%93%E5%A7%8B%E7%BB%88%E6%B2%A1%E6%9C%89%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E6%80%8E%E4%B9%88%E5%8A%9E/"/>
    <id>http://yoursite.com/2018/02/09/Mysql-Atlas从库始终没有建立连接怎么办/</id>
    <published>2018-02-09T05:45:56.000Z</published>
    <updated>2018-02-09T09:29:50.262Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>最近发现阿里云线上环境有一台hls模块的数据库从库一直没有连接，而主库却一直连接不断。在阿里云控制后台看到连接情况如下图：<br><img src="/images/atlas1.png" alt="paradin"></p><p><img src="/images/atlas2.png" alt="paradin"><br>上图是主库的，下面那个是从库的，两者差距很大，可见这样的配置是错误的，因为读库根本没有使用，也就是说读库的那份钱是在浪费！</p><p>来到对应的atlas服务器查看配置，看到atlas 的配置里规定管理接口的用户名和密码是默认的原始套餐，端口被改成了2346，如下面，<br><img src="/images/atlas3.png" alt="paradin"></p><p><img src="/images/atlas4.png" alt="paradin"><br>于是我们就在模块服务器（也就是图里的online-hls-001)上登录这个atlas服务器的管理端口，看一下效果：<br><img src="/images/atlas6.png" alt="paradin"></p><p>发现mysql根本没有反应，可当我们telnet去atlas的2346端口的时候，发现端口是通的：<br><img src="/images/atlas7.png" alt="paradin"></p><p>于是我们返回到atlas 的配置文件，把这台hls模块服务器的ip地址添加到<code>clients-ips</code>这个字段里。<br><img src="/images/atlas8.png" alt="paradin"></p><p>然后再用hls服务器去测试一下atlas的管理端口，<code>mysql -hatlas服务器ip地址 -uuser -ppwd</code>，然后使用<code>select * from backends;</code>,发现里面的两个库一个连接成功，另一个是失败的：<br><img src="/images/atlas9.png" alt="paradin"></p><p>两个库都可以ping通，state却有这样的差别。由此可见这台atlas根本没有连接到从库，导致从库的连接数始终为0。这个时候我们就要检查从库配置的账号密码是否正确，而且在阿里云控制后台给从库开启这个atlas的白名单，然后重新启动这个mysql-proxy进程，再登录atlas管理端口查看，发现从库由down转up了：<br><img src="/images/atlas10.png" alt="paradin"></p><p>但是此时的atlas日志里却出现了很多forbidden的warning的提示：<br><img src="/images/atlas11.png" alt="paradin"></p><p>这时候我们返回atlas的配置文件，把之前的修改过的<code>client-ips</code>这个字段注释掉，让所有合法ip都连接，然后重启atlas，这样这种forbidden ip的警告日志就会消失。</p><p>稍等一会，就会看到从库上也会出现连接数了，至此一切恢复到正常状态，故障排除！<br><img src="/images/atlas12.png" alt="paradin"></p><p>本次故障排除感谢<code>https://highdb.com/?s=atlas</code>这位大神的帮助！</p><h2><span id="文末补充">文末补充</span></h2><p>数据库访问使用了事务的话，从库也会建立连接，只是连接量要小于“非事务访问”，而不是一点连接都没有。</p><p>一般来说，在atlas配置文件里，主库写一个，而从库最好把主库和从库都写进去，如果希望从库承担读的任务多一点的话，可以把权重调高，比如我想从库与主库的读任务比是2：1，那么就可以这么写：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#Atlas后端连接的MySQL主库的IP和端口，可设置多项，用逗号分隔</span><br><span class="line">proxy-backend-addresses = 主库地址:<span class="number">3306</span></span><br><span class="line">#Atlas后端连接的MySQL从库的IP和端口，@后面的数字代表权重，用来作负载均衡，若省略则默认为1，可设置多项，用逗号分隔</span><br><span class="line">proxy-read-only-backend-addresses = 从库地址:<span class="number">3306</span>@<span class="number">2</span>,主库地址:<span class="number">3306</span>@<span class="number">1</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      心已经向家里飞去
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="读写分离中间件" scheme="http://yoursite.com/tags/%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>脚本里添加crontab的方法</title>
    <link href="http://yoursite.com/2018/02/08/%E8%84%9A%E6%9C%AC%E9%87%8C%E6%B7%BB%E5%8A%A0crontab%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2018/02/08/脚本里添加crontab的方法/</id>
    <published>2018-02-08T13:48:37.000Z</published>
    <updated>2018-02-08T13:55:55.951Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>一般来说，增加计划任务都是<code>crontab -e</code>，然后在里面添加内容。但是在一些脚本里，需要自动添加，那么这种情况怎么办？</p><h2><span id="第一种方法">第一种方法</span></h2><p>重定向crontab到其他文件：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">crontab -l &gt; crontab.bak</span><br><span class="line">echo <span class="string">"*/1 * * * * ./yourscript  &gt; /dev/null 2&gt;&amp;1"</span> &gt;&gt; crontab.bak</span><br><span class="line">crontab crontab.bak</span><br></pre></td></tr></table></figure></p><p>如果想删除某个计划任务，就进去<code>crontab -e</code>删除就好，<code>crontab.bak</code>不用管，不用担心内容会自动变成<code>crontab.bak</code>的样子。</p><h2><span id="第二种方法">第二种方法</span></h2><p>如果你觉得使用<code>crontab 文件</code>这种方法心里没有底的话，就选择最妥善的方式，也就是下面这样：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">"*/1 * * * * ./yourscript &gt; /dev/null 2&gt;&amp;1"</span> &gt;&gt; <span class="regexp">/var/</span>spool/cron/root</span><br></pre></td></tr></table></figure></p><p>当crontab突然失效时，可以尝试<code>/etc/init.d/crond restart</code>解决问题。或者查看日志看某个job有没有执行/报错<code>tail -f /var/log/cron</code>。<br><img src="/images/vc15.jpg" alt="paradin" title="半人半神！"></p>]]></content>
    
    <summary type="html">
    
      把脚本作的尽善尽美
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="crontab" scheme="http://yoursite.com/tags/crontab/"/>
    
  </entry>
  
  <entry>
    <title>在百花之中干掉一个杂草连接...</title>
    <link href="http://yoursite.com/2018/02/08/%E5%9C%A8%E7%99%BE%E8%8A%B1%E4%B9%8B%E4%B8%AD%E5%B9%B2%E6%8E%89%E4%B8%80%E4%B8%AA%E6%9D%82%E8%8D%89%E8%BF%9E%E6%8E%A5/"/>
    <id>http://yoursite.com/2018/02/08/在百花之中干掉一个杂草连接/</id>
    <published>2018-02-08T12:43:12.000Z</published>
    <updated>2018-02-08T12:59:06.757Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="正文">正文</span></h2><p>早上接到阿里云的服务器报警，说有一台服务器的流量超标，这个服务器的外网带宽是5M，但是登陆进去使用<code>iftop -i eth1</code>发现里面的流量已经几乎跑满，如图：<br><img src="/images/tcpkill1.png" alt="paradin"></p><p>我这个服务器的名称叫online-mts-001，为啥会有一个mail25.u.tsender.com，这个是什么鬼？莫非是通过我的服务器去连接这个“邮箱”域名？于是我就ping了一下这个mail25.u.tsender.com，结果如图：<br><img src="/images/tcpkill2.png" alt="paradin"></p><p>看到这个域名对应的ip地址是115.29.177.8，嗯，115.29.177.8，哎？这个ip地址好熟悉啊，卧槽，这特么不是这个<code>online-mts-001</code>的外网ip么？<br><img src="/images/tcpkill3.png" alt="paradin"></p><p>也就是说我这个机器在我不知道的情况下被人绑定了一个域名！但是我这个服务器不是网页服务器，上面那个tsender.com的域名打不开，我检查了服务器一番，发现这个机器没有被人入侵的痕迹，只能说是被人有意/无意（无意的可能性更大，比如看错了阿拉伯数字）绑定了域名。</p><p>被人绑定了域名就好比被人起了外号一样，一旦非本人操作就不太好往下摘了，查了很多资料都没有办法，毕竟主动权不在我这里了。</p><p>但是回头过来，我们的重心是要解决那个占据了3M带宽的连接，<code>netstat</code>看了一下，发现这个连接的具体信息如下：<br><img src="/images/tcpkill4.png" alt="paradin"></p><p>仅仅是干掉连接的话，方法有很多，关闭网卡再重开或者关闭相应的服务都可以，但是现在的问题是这台服务器是生产环境的服务器，它主要是给用户提供视频拉流，通过抓包分析得知，这位183.228.128.188的用户合法通过外网连接到了这台视频服务器，而且拉取的是高清视频，所以才占据了这么大的带宽。不过我们还是决定先断开这位用户的连接同时不动其他用户的连接，这位183.228.128.188的用户在客户端虽然会发觉视频断开，但是有缓存和人为刷新的客观因素，实际的体验不会差太多，至少不会投诉400…</p><p>那么如何干掉一个established连接同时保证其他连接呢？请使用<code>tcpkill</code>。</p><p>tcpkill的下载比较有说法，下面是安装步骤：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget http:<span class="comment">//rpm.repo.onapp.com/ramdisk-hv/centos6/dsniff/libnids-1.24-1.el6.x86_64.rpm</span></span><br><span class="line">wget http:<span class="comment">//rpm.repo.onapp.com/ramdisk-hv/centos6/dsniff/libnet-1.1.5-1.el6.x86_64.rpm</span></span><br><span class="line">wget http:<span class="comment">//rpm.repo.onapp.com/ramdisk-hv/centos6/dsniff/dsniff-2.4-0.14.b1.el6.x86_64.rpm</span></span><br><span class="line">yum install libICE libSM libXmu -y</span><br><span class="line">rpm -ivh libnet<span class="number">-1.1</span><span class="number">.5</span><span class="number">-1.</span>el6.x86_64.rpm</span><br><span class="line">rpm -ivh libnids<span class="number">-1.24</span><span class="number">-1.</span>el6.x86_64.rpm </span><br><span class="line">rpm -ivh  dsniff<span class="number">-2.4</span><span class="number">-0.14</span>.b1.el6.x86_64.rpm</span><br></pre></td></tr></table></figure></p><p>请按顺序操作，不然的话dsniff就会报错：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">warning: dsniff<span class="number">-2.4</span><span class="number">-0.14</span>.b1.el6.x86_64.rpm: Header V3 RSA/SHA256 Signature, key ID <span class="number">0608</span>b895: NOKEY</span><br><span class="line">error: Failed dependencies:</span><br><span class="line">libnet.so<span class="number">.1</span>()(<span class="number">64</span>bit) is needed by dsniff<span class="number">-2.4</span><span class="number">-0.14</span>.b1.el6.x86_64</span><br><span class="line">libnids.so<span class="number">.1</span><span class="number">.24</span>()(<span class="number">64</span>bit) is needed by dsniff<span class="number">-2.4</span><span class="number">-0.14</span>.b1.el6.x86_64</span><br></pre></td></tr></table></figure></p><p>安装完毕之后，就会生成<code>tcpkill</code>命令，如图：<br><img src="/images/tcpkill5.png" alt="paradin"></p><p>然后断开上面那个大带宽连接的命令是：<code>./tcpkill -i eth0 src port 9132 and dst port 9595 and src host 115.29.177.8 dst host 183.228.128.188</code>或者<code>./tcpkill -s 115.29.177.8:9132 -d 183.228.128.188:9595</code>。</p><p>但是要注意一下！<font color="red">tcpkill一定要运行在能接收到应答包的主机上在，最好运行在连接或半连接存在的一端主机上，因为tcpkill会发现这个连接里有数据传输进而感知并且干掉</font>。而且tcpkill默认情况下是只能干掉established状态的连接，对于假死连接（连接在，但是数据不传输）或者半连接（由于tcp keeplive没打开而又没有数据向对端发送，导致一直无法感知次连接其实已经断开）是无法断开的。</p><p>如果遇到上述所说的假死连接和半连接就需要手动更改tcpkill的源码，更改原理在<code>https://yq.aliyun.com/articles/59308</code>。</p><p>如果使用的系统是ubuntu or debian，还可以使用cutter命令，<code>apt-get install cutter</code>下载即可。使用方法：<code>http://www.cyberciti.biz/tips/cutting-the-tcpip-network-connection-with-cutter.html</code>。</p><p>至于第一个问题，怎么把这台服务器上的域名撤除，我倒要好好想想了…</p><h2><span id="参考资料">参考资料</span></h2><p><a href="http://www.cyberciti.biz/howto/question/linux/kill-tcp-connection-using-linux-netstat.php" target="_blank" rel="noopener">http://www.cyberciti.biz/howto/question/linux/kill-tcp-connection-using-linux-netstat.php</a><br><a href="http://www.gnutoolbox.com/tcpkill-command/" target="_blank" rel="noopener">http://www.gnutoolbox.com/tcpkill-command/</a></p>]]></content>
    
    <summary type="html">
    
      记得这篇文章是在《人民的名义》热播的时候写的
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="运维" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
</feed>
