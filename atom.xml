<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chris Chan&#39;s BLOG</title>
  
  <subtitle>那些在阳光下挥洒青春的日子啊！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-02-22T05:02:54.873Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Chris Chan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>回家过年</title>
    <link href="http://yoursite.com/2018/02/21/%E5%9B%9E%E5%AE%B6/"/>
    <id>http://yoursite.com/2018/02/21/回家/</id>
    <published>2018-02-21T08:08:40.000Z</published>
    <updated>2018-02-22T05:02:54.873Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>我承认我是一个很恋家的人，但是我在3年之前还不是这样。</p><p>我记得我在哈尔滨上大学的时候，虽然坐火车也就一个半小时的时间，但是是“能不回家就不回家”，哪怕自己一个人蹲在寝室也是自由舒服，后来上班，我也是有很长的时间自己独住，只有周末才回去一次。那时候我奶不止一次的批评我“都快成一个客人了”。</p><p>真的应了那句传烂了的话“只有失去的才是美好的”，现在我人在他乡，天天忙成狗。最欢喜的事情第一个是涨工资，第二个是发工资，第三个是放假，第四个就是放假回家。当初我不觉得家庭的温暖，现在却倍感珍惜，唉，那几年真是简单的可笑。</p><p><img src="/images/jia5.jpg" alt="paradin"></p><p>这一次回家过年看到了许许多多亲人。大姨夫的精神状态也好了许多，不过他这次回来又害了一次发烧。小外甥和他那婴儿肥的脸蛋，在《守望先锋》里越死越勇。我那几个弟弟都瘦了也更精神了，从我妈和女票看我的眼神里，我觉得我的体重是应该好好管控一下了：体型太腐败。</p><p>短短的六天时间，吃完三姨家吃四姨家，吃完老叔家吃小舅家，各种亲戚连轴转。中途跟龙南数据班的几个老同事一起吃了顿“一口猪”，</p>]]></content>
    
    <summary type="html">
    
      最期盼的假期，已经余额不足了...
    
    </summary>
    
      <category term="坠乱花天" scheme="http://yoursite.com/categories/%E5%9D%A0%E4%B9%B1%E8%8A%B1%E5%A4%A9/"/>
    
    
      <category term="春节" scheme="http://yoursite.com/tags/%E6%98%A5%E8%8A%82/"/>
    
      <category term="心情" scheme="http://yoursite.com/tags/%E5%BF%83%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>中国梦，宪政梦</title>
    <link href="http://yoursite.com/2018/02/13/%E4%B8%AD%E5%9B%BD%E6%A2%A6%EF%BC%8C%E5%AE%AA%E6%94%BF%E6%A2%A6/"/>
    <id>http://yoursite.com/2018/02/13/中国梦，宪政梦/</id>
    <published>2018-02-12T17:00:57.000Z</published>
    <updated>2018-02-13T04:26:08.912Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p><strong>本文原作者：《南方周末》评论部编辑戴志勇</strong></p><p>天地之间，时间绽放。</p><p>这是我们在2013年的第一次相见，愿你被梦想点亮。</p><p>2012年，你守护自己的生活，他们守护自己的工作。守护这份工作，就是在守护他们对生活的梦想。</p><p>2012年，庙堂之上发出的宪政强音嗡然回响：”宪法的生命在于实施，宪法的权威也在于实施。”我们期待宪法长出牙齿，宪政早日落地。惟如此，才能成就这个沧桑古国的艰难转型；惟如此，国家与人民，才能重新站立于坚实的大地之上。</p><p>今天，已是能够梦想的中国，今天，已是兑现梦想的时代。经历过宪政缺失的”文革”梦魇，我们花费三十多年的时间来逐渐回归常理与常情。从土地联产承包责任制到个体户、乡镇企业到”民企”，稍稍归还国人自主安排生活的权利，我们便创造了繁华城市，收获了满仓粮食。</p><p>我们重新体认什么是真，什么是假，是其是，非其非；我们重燃对公义的热爱，对自由的向往。面对暴虐强力，我们双手相握，一起走过艰难时刻，迎接生活转机。</p><p>今天，我们终于可以从厚厚的历史尘埃中挺起胸，从琐碎的日常生活中抬起头，重走先辈的宪政长征，重温先辈的伟大梦想。</p><p>一百七十多年前，我们开始从天朝上国的迷梦中醒来。先败于英，后败于日。百姓愈加民不聊生，耻感深深刺痛中国士人。保国！保种！由洋务而君宪，由立宪而革命。从器物到制度再至文化，激愤者不惜彻底打倒”孔家店”，决绝地将自己的文明连根拔起。</p><p>辛亥革命后，清帝退位，先辈们终于建立了亚洲第一个共和国。但是，一个自由、民主、富强的宪政中国并没有随之而来。</p><p>国家内外，战争连连；人群内外，残酷不断。</p><p>一度，人们远离仁，远离义，远离天道，远离对自由的坚守。</p><p>一度，人们认错为对，指鹿为马，万千生灵生机断绝。</p><p>美梦与山河，齐齐破碎。自由与宪政，双双消隐。</p><p>度尽人世劫波，深味人性幽暗，我们依然是能做梦的人，有颗能做梦的心。</p><p>今天，我们断断不只梦想物质丰盛，更希望性灵充盈；我们断断不只梦想国力能强盛，更希望国民有自尊。新民和新国，救亡与启蒙，谁也离不开谁，谁也不能压倒谁。而宪政便是这一切美梦的根基。</p><p>兑现宪政，坚守权利，人人才能心如日月流光溢彩；鳏寡孤独才能感受冬日暖意而非瑟瑟发抖；”城管”与小贩才能谈笑风生；房屋才能成为自己与家人的城堡；</p><p>兑现宪政，限权分权，公民们才能大声说出对公权力的批评；每个人才能依内心信仰自由生活；我们才能建成一个自由的强大国家。</p><p>兑现宪政大梦，每个人才能做好个人的美梦。而这需要我们就从手边做起，就从守护此时此刻的生活做起，而不要将重任留给子孙。</p><p>很多人一直深深懂得这一点，很多人早就努力践行这一点。</p><p>不是杰出者才做梦，是善于做梦者才杰出。</p><p>你的天赋权利就是可以梦想，并且兑现梦想！</p><p>为你的梦想鼓掌，为这个国家的梦想加油，这就是很多新闻人的梦想，是他们不大不小的野心。他们忠于新闻，更忠于内心。愿你也有个玫瑰色的美梦；自由成就自己，完成天之所赋。</p><p>总会梦想人人都可以做一个有尊严的人，不论身居高位，还是街头卖艺；</p><p>总会梦想人人内心有爱，即使罪犯也未必穷凶极恶，总有恻隐之心自由闪动；</p><p>总会梦想阶层只是引人自由流动的动力，而不再是相互猜忌和仇视的天堑；总会梦想这五千年文明生生不息，为改善人类的现代处境，捧出一掬甘冽清泉……</p><p>兑现这一千一万个梦想，才能抚平这一百多年的刻骨痛楚。</p><p>兜兜转转一百七十年，美梦成真何其难！一百七十年后，依然有人渴望良知萌新芽，重温天命之谓性；依然有人坚持要求权利一一落地，政治复归于正，公义自在流淌。</p><p>依然有人相信，不管多难，梦想终会落实为宪政良制，风行为敦敦美俗。</p><p>先辈们筚路蓝缕，践义成仁。如今，后人承继其志，燃灯前行。</p><p>兑现梦想，自然要借鉴前贤智慧，与古人的信仰、习俗和情感和解。儒释道法墨，百家皆是源泉；周汉唐宋明，代代皆有可取。</p><p>但这决不是要复古，古人不能给予今天所需的一切。只是不再轻易贬损先辈，平心静气地吸收转进，以让中华文明开新花，结新果。</p><p>兑现梦想，自然要吸取世界经验。所以要认真审视希腊民主，罗马法治，借鉴英美宪政，追赶现代科技文明。</p><p>但这也不是仅仅作一个西方文明的优等生，西人有西人演进的轨迹，同样未必能直接给予我们今天所需的一切。</p><p>我们要站在自己的大地上，与各国人民一起，生活出一种古今相融的新生活，文明出一种中西合璧的新文明。在古今中西的激荡中，要遵循人类共通的价值，也要不惮于做自己的新梦。</p><p>称美古人，赞扬邻居，不是因为他们足够完美，而是因为我们熟悉他们眼中洋溢的快乐，心底流淌的自由。</p><p>中国人本应就是自由人。中国梦本应就是宪政梦。</p><p>宪政之下，才能国家持续强盛，宪政之下，才有人民真正强大。兑现宪政梦想，才能更好地外争国权，维护国家的自由；才能更好地内争民权，维护人民的自由。而国家的自由最终必得落脚于人民的自由，必得落脚于人人可以我口说我心，人人可以用心做美梦。</p><p>生而为人，谁能不热爱自由？这自由，不仅是权利针对权力而言，也是宽恕针对报复而言，是般若针对无明而言，是仁爱针对暴虐而言，是有道针对无道而言。</p><p>大道之行，天下为公；万物自在，各正性命。这就是古人的梦想，先辈的梦想，也是今天很多人的梦想。</p><p>中国梦，自由梦，宪政梦。</p><p>万物速朽，但梦想永在。万物诞生，因梦想不灭。梦想就是生生之几，就是当你失败了一百次，那第一百零一次充实你内心的不死之希望。</p><p>依然有人倾听你的梦想，期待你敢于做梦。你从苦难中爬起，他们为你加油；你尝尽人世冷暖，他们为你加油；你收获美好生活，他们为你加油……他们别无所资，惟有对梦想的执着；他们别无所长，惟有对真相的追求。</p><p>一句真话能比整个世界还重，一个梦想能让生命迸射光芒！</p>]]></content>
    
    <summary type="html">
    
      谨以此文纪念“南方周末事件”
    
    </summary>
    
      <category term="坠乱花天" scheme="http://yoursite.com/categories/%E5%9D%A0%E4%B9%B1%E8%8A%B1%E5%A4%A9/"/>
    
    
      <category term="中国政治" scheme="http://yoursite.com/tags/%E4%B8%AD%E5%9B%BD%E6%94%BF%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>关于logrotate的额外补充</title>
    <link href="http://yoursite.com/2018/02/12/%E5%85%B3%E4%BA%8Elogrotate%E7%9A%84%E9%A2%9D%E5%A4%96%E8%A1%A5%E5%85%85/"/>
    <id>http://yoursite.com/2018/02/12/关于logrotate的额外补充/</id>
    <published>2018-02-12T12:09:27.000Z</published>
    <updated>2018-02-12T14:28:49.154Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p><code>https://rorschachchan.github.io/2018/02/12/日志文件管理者：Logrotate/</code> 里面已经简单介绍了logrotate命令，这里还有一些额外补充的东西：</p><p>1）查看logrotate对log文件的具体执行情况的语句是<code>cat /var/lib/logrotate.status</code>，效果如图：<br><img src="/images/logrotate6.png" alt="paradin"></p><p>2）使用<code>-v</code>或<code>-d</code>参数时，显示<code>log does not need rotating</code>，这是因为logrotate在对status未记录的文件进行转储时，会在status添加一条该文件的记录，并将操作时间设为当天。之后程序再次对此文件进行转储时发现这个文件今天已经操作过，就不再进行相关操作。要是想解决这个问题可以使用<code>-s</code>指定logrotate状态文件；</p><p>3）分割日志时报错：<code>error: skipping &quot;/var/log/nginx/test.access.log&quot; because parent directory has insecure permissions (It&#39;s world writable or writable by group which is not &quot;root&quot;) Set &quot;su&quot; directive in config file to tell logrotate which user/group should be used for rotation.</code>这是当前用户不是root，需要添加<code>su root list</code>这个语句到对应的logrotate配置文件里，比如：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">var</span>/log/nginx<span class="comment">/*.log &#123;</span></span><br><span class="line"><span class="comment">        su root list#第一句添加</span></span><br><span class="line"><span class="comment">        daily</span></span><br><span class="line"><span class="comment">        missingok</span></span><br><span class="line"><span class="comment">        rotate 52</span></span><br><span class="line"><span class="comment">        compress</span></span><br><span class="line"><span class="comment">        delaycompress</span></span><br><span class="line"><span class="comment">        notifempty</span></span><br><span class="line"><span class="comment">        #ifempty</span></span><br><span class="line"><span class="comment">        create 0640 www-data adm</span></span><br><span class="line"><span class="comment">        sharedscripts</span></span><br><span class="line"><span class="comment">        postrotate</span></span><br><span class="line"><span class="comment">                [ ! -f /var/run/nginx.pid ] || kill -USR1 `cat /var/run/nginx.pid`</span></span><br><span class="line"><span class="comment">        endscript</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4）如果觉得使用`logrotate`很麻烦，而当某个文件过大的时候，要实现把该文件压缩并且拆成若干个指定大小的文件，怎么办？</span></span><br><span class="line"><span class="comment">```js</span></span><br><span class="line"><span class="comment">tar -zcvf 新文件名.tar.gz 原文件名 | split -b 每个分格包大小 -d -a 1 - 新文件名.tar.gz</span></span><br></pre></td></tr></table></figure></p><p>比如：<code>tar -zcvf ABC.tar.gz ABC | split -b 4000M -d -a 1 - ABC.tar.gz</code>。这个命令就是把ABC这个文件压缩成ABC.tar.gz，但是如果ABC大于4000M就会切块，切成ABC.tar.gz.0,ABC.tar.gz.1,ABC.tar.gz.2……这个样子。<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用split命令，-b 4000M 表示设置每个分割包的大小，单位还是可以k</span></span><br><span class="line"><span class="comment">// -d 参数指定生成的分割包后缀为数字的形式</span></span><br><span class="line"><span class="comment">//-a x来设定序列的长度(默认值是2)，这里设定序列的长度为1</span></span><br></pre></td></tr></table></figure></p><p>如果要把这一堆已经切块的文件重新接压缩的命令：<code>cat ABC.tar.gz.* | tar -zxv</code>;</p><p>5）如果用<code>kill -HUP</code>来重启一个包含守护进程的进程，比如httpd，一条语句搞定：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep httpd | grep -v grep | awk <span class="string">'&#123; print $2; &#125;'</span> | xargs -L <span class="number">1</span> sudo kill -HUP</span><br></pre></td></tr></table></figure></p><p>这里面首先用awk获取到httpd的pid进程号，然后把这个进程号传给了xargs，通过<code>-L 1</code>来一次提取一行pid值，然后分批进行<code>kill -HUP</code>;</p><p>6）想更多的了解守护进程，参看<code>http://www.cnblogs.com/mickole/p/3188321.html</code>；</p><p><img src="/images/slamdunk.jpg" alt="paradin"></p>]]></content>
    
    <summary type="html">
    
      祝各位看官新春快乐！！！
    
    </summary>
    
      <category term="技术与工作" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%B7%A5%E4%BD%9C/"/>
    
    
      <category term="运维技术" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4%E6%8A%80%E6%9C%AF/"/>
    
      <category term="logrotate" scheme="http://yoursite.com/tags/logrotate/"/>
    
  </entry>
  
  <entry>
    <title>日志文件管理者：Logrotate</title>
    <link href="http://yoursite.com/2018/02/12/%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E8%80%85%EF%BC%9ALogrotate/"/>
    <id>http://yoursite.com/2018/02/12/日志文件管理者：Logrotate/</id>
    <published>2018-02-12T11:57:18.000Z</published>
    <updated>2018-02-12T12:07:05.274Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="前言">前言</span></h2><p>服务器在服务运行的时候，难免会生成大量日志，一般来说遇到日志过多的情况，就会写一个看门狗：监控磁盘容量的大小，如果磁盘剩余空间小于某个值，就去日志文件夹里把一个月或者几个月之前的废弃日志删除掉以达到释放磁盘空间的目的。</p><p>但是往往有的时候过期的日志很重要，或者即使是一周的时间内，也会生成容量非常可观的日志，那么就需要使用logrotate命令来管理这些日志，这个命令是linux自带的。</p><p>logrotate这个命令的用法请看：<code>https://linux.cn/article-8227-1-rel.html</code>和<code>https://linux.cn/article-4126-1.html</code> 。</p><h2><span id="实验开始">实验开始</span></h2><p>首先，假设服务器里某个日志文件夹里的日志<code>auc.log.10</code>是这样的：<br><img src="/images/logrotate1.png" alt="paradin"></p><p>然后在logrotate的配置文件是这么写的：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/mnt/hswx/auc/logs/auc.log<span class="number">.10</span> &#123;             这里是目标日志的绝对路径</span><br><span class="line">       daily        每天执行一次</span><br><span class="line">       minsize <span class="number">200</span>M    文件容量大于<span class="number">200</span>M开始处理，如果到了时间但是没有大于<span class="number">200</span>M，不会处理</span><br><span class="line">       compress          压缩</span><br><span class="line">       dateext          文件会以日期为后缀</span><br><span class="line">       create <span class="number">777</span> root root    新建的那个日志文件属性是<span class="number">777</span></span><br><span class="line">       rotate <span class="number">2</span>         保留最多<span class="number">2</span>个文件</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后执行<code>logrotate -vf /etc/logrotate.conf</code>，看到的效果是：<br><img src="/images/logrotate2.png" alt="paradin"></p><p>命令执行后，服务器create了新的<code>auc.log.10</code>，而且属性变成了777，同时把原有的部分压缩成gz的格式。</p><p>上面那个测试的对象是已经过期的日志，现在我们要压缩当前的日志，目的是<code>在压缩了auc.log并且重命名之后，可以生成新的auc.log，同时这个新的auc.log会被写入</code>。</p><p>现在我们尝试一下，把原来的配置文件改成这样：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/mnt/hswx/auc/logs/auc.log &#123;</span><br><span class="line">       weekly</span><br><span class="line">       minsize <span class="number">200</span>M</span><br><span class="line">       compress</span><br><span class="line">       rotate <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是执行之后，我们发现变成了这样：<br><img src="/images/logrotate3.png" alt="paradin"></p><p>原来的<code>auc.log</code>不见了，而出现的<code>auc.log.1</code>里面的内容是原来<code>auc.log</code>的内容，可见原有的<code>auc.log</code>已经被顶掉了。这是因为我们上面的配置文件里面没有加上<code>dateext</code>，所以默认会以<code>.1、.2、.3</code>为后缀。</p><p>问题是我们没有生成<code>auc.log</code>，那么这段时间的日志就会找不到<code>auc.log</code>而凭空消失。可见这个方法没有达到我们的目的，需要改进。</p><h2><span id="改进之后">改进之后</span></h2><p>我们这个内部模块auc只有重新启动这个进程才会生成<code>auc.log</code>，既然要解决这样的问题，我们很自然的就想到<code>kill -HUP</code>这种平滑启动的方式，但是要注意！<code>kill -HUP</code>对deamon会进行重新读取配置启动，但是对于普通的进程只会把其杀死！而这个auc就是一个普通的java程序，没有配套的守护进程。所以只能使用一般的重启方式来达到生成<code>auc.log</code>这个目的。</p><p>首先我们把原来的配置文件改成这样：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/mnt/hswx/auc/logs/auc.log &#123;</span><br><span class="line">       weekly    #每周执行</span><br><span class="line">       dateext    #以日期作为后缀</span><br><span class="line">       minsize 200M    #到达了200M自动执行，不然即使到了一周的时间也不执行</span><br><span class="line">       compress    #压缩</span><br><span class="line">       rotate 2    #最多保留两个文件</span><br><span class="line">       sharedsripts    </span><br><span class="line">       postrotate    #在执行完日志压缩之后就执行如下动作</span><br><span class="line">               /bin/bash /root/restart.sh    #动作就是执行这个绝对路径的脚本</span><br><span class="line">       endscript    #收工</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而这个<code>restart.sh</code>的内容很简单:<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">cd /mnt &amp;&amp; ./stopAUC.sh    #停止auc进程</span><br><span class="line">cd /mnt &amp;&amp; ./startAUC.sh    #启动auc进程</span><br><span class="line">echo HAHAHAHA！！！    #表示已经OK了，让我们发出杠铃一般的笑声</span><br></pre></td></tr></table></figure></p><p>现在我们重新跑一下logrotate，<code>logrotate -vf /etc/logrotate.conf</code>。看一下效果：<br><img src="/images/logrotate4.png" alt="paradin"></p><p>可以看到先把日志改名压缩，完事后也执行了<code>restart.sh</code>这个脚本，再日志里一看，<code>auc.log</code>也顺利生成了！<br><img src="/images/logrotate5.png" alt="paradin"></p><h2><span id="参考资料">参考资料</span></h2><p><a href="http://www.pythondev.org/post/8.html" target="_blank" rel="noopener">http://www.pythondev.org/post/8.html</a></p>]]></content>
    
    <summary type="html">
    
      rotate是“轮转、交替、转动、试转动”的意思
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="运维技术" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>一个暗藏杀机的脚本</title>
    <link href="http://yoursite.com/2018/02/11/%E4%B8%80%E4%B8%AA%E6%9A%97%E8%97%8F%E6%9D%80%E6%9C%BA%E7%9A%84%E8%84%9A%E6%9C%AC/"/>
    <id>http://yoursite.com/2018/02/11/一个暗藏杀机的脚本/</id>
    <published>2018-02-11T07:13:54.000Z</published>
    <updated>2018-02-11T07:19:46.610Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="脚本背景">脚本背景</span></h2><p>老总最近总是发现某台relay服务器的CPU值会突然彪很高，于是勒令几位工程师检查问题，但是工程师一时半会也想不到究竟是什么程序这么耗费CPU，于是就委托运维写一个脚本，具体要求是这样的：每隔一秒钟输出一下top命令的前十二行情况（其实就是配置总览和耗费cpu前五名程序情况），将这些情况保存到一个文件里，如果这个文件大于500MB，就把这个文件删除（为啥要删除？我也不知道），重新再生成一个文件用来保存top命令结果。</p><h2><span id="分析">分析</span></h2><p>由于脚本无法自己跳出运行并检查自己的大小，所以这个任务需要两个脚本，一个是单纯的把top命令重定向到一个文件（recordTOP.sh），另一个脚本就是一个if判断大小（checksize.sh）。再加上crontab每一天一检查（其实完全没必要，500MB足够top这个命令跑5天的），应该可以满足开发人员的需求。</p><h2><span id="脚本内容">脚本内容</span></h2><p>获取<code>top.txt</code>的脚本<code>recordTOP.sh</code>如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">#written by ChenShuo @2016-8-15</span><br><span class="line">#Desription:每一秒钟记录一次top命令里占用cpu前五程序</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">                $(top -bn <span class="number">1</span> | head <span class="number">-12</span> &gt;&gt; <span class="regexp">/root/</span>top.txt)</span><br><span class="line">                echo <span class="string">"------------------------------------------------"</span> &gt;&gt; <span class="regexp">/root/</span>top.txt</span><br><span class="line">                sleep <span class="number">1</span></span><br><span class="line">        done</span><br></pre></td></tr></table></figure></p><p>判断<code>top.txt</code>大小的脚本<code>checksize.sh</code>如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">#written by ChenShuo @2016-8-15</span><br><span class="line">#Desription:当recordTOP.sh文件大小超过500MB的时候将会重新覆盖</span><br><span class="line">size=$(ls -l | grep top.txt |cut -d <span class="string">" "</span> -f <span class="number">5</span>)</span><br><span class="line"><span class="keyword">if</span> [[ $size -ge <span class="number">536870912</span> ]]</span><br><span class="line">        then</span><br><span class="line">                $(ps -ef|grep recordTOP.sh|grep -v grep|awk <span class="string">'&#123;print $2&#125;'</span>|xargs kill <span class="number">-9</span>)</span><br><span class="line">                $(rm -rf /root/top.txt)</span><br><span class="line">                bash /root/recordTOP.sh &amp;</span><br><span class="line">        fi</span><br></pre></td></tr></table></figure></p><p><code>crontab</code>这一步我就略掉不写了。</p><h2><span id="补充说明">补充说明</span></h2><p>1）top不可以直接重定向，如果是<code>top &gt; 123.txt</code>，它将会不断的导入，因为top就是一个实时更新的命令，所以这里要用<code>top -bn 1|head 12 &gt;&gt; /top.txt</code>；</p><p>2）shell脚本里调用shell，不能采用<code>$()</code>的方法了，因为<code>$()</code>是一个返回值，而.sh是一个不断进行的脚本，所以要用<code>bash +脚本名</code>的方式；</p><p>3）recordTOP.sh这个脚本是可以同时存在多个的，但是如果不小心后台启动多个，用checksize脚本ps -ef语句就会报错，因为获得到的不是一个数字，而是多个数字，没法一波kill掉。同理，直接调用checksize也会报错，因为没有ps -ef的值；</p><p>4）因为是要先关闭原来的top重定向脚本，所以才用了保守的ps -ef，然后kill的方式，这里不可以使用pkill，因为pkill是干掉整个类型程序，比如<code>pkill -9 java</code>，就是干掉所有java的进程。而在linux里，千万不可以<code>pkill -9 sh</code>，可以想象一下，这个命令的结果就是会从ssh上跳出，同时无法登陆，因为整个sh都被你杀死了。那么真的出现了这个结果怎么办？答曰：重启，重启能救命。</p><p>整个执行效果如下，可见top.txt文件是在不断的扩大，由于是测试，我把文件大小调整为20000字节，即大于20000字节就覆盖原文件，当文件大于20000字节的时候，就会把原来的top.txt删除，同时生成一个新的top.txt。<br><img src="/images/top5.png" alt="paradin"></p>]]></content>
    
    <summary type="html">
    
      shell里面调用shell，这是一个坑。
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
      <category term="top" scheme="http://yoursite.com/tags/top/"/>
    
  </entry>
  
  <entry>
    <title>http返回码是000...</title>
    <link href="http://yoursite.com/2018/02/11/http%E8%BF%94%E5%9B%9E%E7%A0%81%E6%98%AF000/"/>
    <id>http://yoursite.com/2018/02/11/http返回码是000/</id>
    <published>2018-02-11T01:51:39.000Z</published>
    <updated>2018-02-11T02:08:46.611Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="正文">正文</span></h2><p>今天开发童鞋在测试往一个网站发请求的时候，发现返回码是000，如图：<br><img src="/images/http0001.png" alt="paradin"></p><p>众所周知，常见的返回码是以下四种：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>XX 成功；</span><br><span class="line"><span class="number">3</span>XX 重定向；</span><br><span class="line"><span class="number">4</span>XX 客户端错误；</span><br><span class="line"><span class="number">5</span>XX 服务器端错误；</span><br></pre></td></tr></table></figure></p><p>但是000是啥玩意？简单的说就是没有有效的http状态码，比如连接被拒绝，连接超时等。</p><p>使用<code>curl -w &quot;%{http_code}\n&quot; -m 5 https://60.191.94.115:38303/cloudSignalling/events/deviceState ; echo &quot;Exit code: $?</code>看一下详细的code，显示如图：<br><img src="/images/http0002.png" alt="paradin"></p><p>可以看到提示：<code>curl: (60) Peer certificate cannot be authenticated with known CA certificates</code>，翻译过来就是<code>对方的证书不能用已知的CA证书验证</code>。但是下面也说了可以用<code>-k</code>或者<code>--insecure</code>来跳过这一步。</p><p>于是我又使用<code>curl -I -k https://60.191.94.115:38303/cloudSignalling/events/deviceState</code>这个命令，效果如图：<br><img src="/images/http0003.png" alt="paradin"></p><p>里面这一下说的就很明白了，405，方法不正确，再搭配一下<code>curl -k -w &quot;%{http_code}\n&quot; -m 5 https://60.191.94.115:38303/cloudSignalling/events/deviceState</code>，看一下：<br><img src="/images/http0004.png" alt="paradin"></p><p>这么上下一结合，明白了GET是不准许的，准许POST。于是反馈给60.191.94.115告诉他们把前后台接口请求方式、参数传递方式都拿回去整改。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="http://www.1987.name/365.html" target="_blank" rel="noopener">http://www.1987.name/365.html</a><br><a href="https://superuser.com/questions/501690/curl-http-code-of-000" target="_blank" rel="noopener">https://superuser.com/questions/501690/curl-http-code-of-000</a></p>]]></content>
    
    <summary type="html">
    
      站好春节前的最后两班岗...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="http" scheme="http://yoursite.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>将redis加入到elk日志系统里</title>
    <link href="http://yoursite.com/2018/02/09/%E5%B0%86redis%E5%8A%A0%E5%85%A5%E5%88%B0elk%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E9%87%8C/"/>
    <id>http://yoursite.com/2018/02/09/将redis加入到elk日志系统里/</id>
    <published>2018-02-09T09:14:18.000Z</published>
    <updated>2018-02-09T09:40:44.505Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>之前在<code>https://rorschachchan.github.io/2018/01/16/记录日志系统ELKB-5-6-4的搭建过程/</code>里面，我画的那个架构图里说了整个架构可以加入redis，但是在文章里我没有写到redis怎么加进去。为了让整个系统更好的分层，是非常建议引入Redis的，毕竟Redis服务器是logstash官方推荐的broker选择。Redis作为一个缓存，能够帮助我们在主节点上屏蔽掉多个从节点之间不同日志文件的差异，负责管理日志端（从节点）的人可以专注于向 Redis 里生产数据，而负责数据分析聚合端的人则可以专注于从Redis内消费数据。所以这一次实验要把redis加进去，同时也要部署一个nginx，让elk再去采集nginx的日志。</p><p>整个架构图图下：<br><img src="/images/elkredis1.png" alt="paradin"></p><h2><span id="部署redis">部署redis</span></h2><p>安装redis的方法请去看<code>http://blog.51cto.com/chenx1242/1793895</code>，我这里使用的redis版本是<code>4.0.6</code>，在执行<code>make test</code>的时候可能会有如下的错误：<br><img src="/images/elkredis2.png" alt="paradin"></p><p>那就安装新一点的<code>tcl</code>吧，方法如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget http:<span class="comment">//downloads.sourceforge.net/tcl/tcl8.6.1-src.tar.gz</span></span><br><span class="line">tar xzvf tcl8<span class="number">.6</span><span class="number">.1</span>-src.tar.gz  -C /usr/local/</span><br><span class="line">cd  /usr/local/tcl8<span class="number">.6</span><span class="number">.1</span>/unix/</span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure></p><p>然后重新去<code>make test</code>就会看到成功的字样，如图：<br><img src="/images/elkredis3.png" alt="paradin"></p><p>现在redis的漏洞比较多，大多数就是因为密码太简单导致的，所以把redis密码改一下，在<code>redis.conf</code>里，改成如下的样子：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bind 内网IP地址 127.0.0.1              ###仅允许内网和本机访问</span><br><span class="line">protected-mode yes                   ###保护模式开启</span><br><span class="line">port 6379                          ###端口默认为6379，按需修改</span><br><span class="line">daemonize yes                        ###守护模式开启</span><br><span class="line">pidfile /usr/local/redis/redis.pid               ###指定pid文件路径和文件名</span><br><span class="line">logfile "/usr/local/redis/redis.log"             ###指定日志文件路径和文件名</span><br><span class="line">dbfilename redis.rdb                     ###指定数据文件RDB文件名</span><br><span class="line">dir /usr/local/redis/                    ###指定数据文件RDB文件的存放路径</span><br><span class="line">requirepass 『YOURPASSWORD』              ###设置访问密码，提升密码强度</span><br></pre></td></tr></table></figure></p><p>保存之后启动redis即可。</p><p>如果redis是主从配置，若master配置了密码则slave也要配置相应的密码参数否则无法进行正常复制的。需要在slave的<code>redis.conf</code>里找到<code>#masterauth  mstpassword</code>，去掉注释，也改成跟master一样的密码，重启一下即可。 </p><p>nginx的安装这里就不写了，直接看<code>http://www.runoob.com/linux/nginx-install-setup.html</code>这个就行了。</p><h2><span id="安装x-pack">安装x-pack</span></h2><p>x-pack是elk官方提供的认证授权插件，安装方法很简单，分别找到下面三个文件，然后后面加上<code>install x-pack</code>即可：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./elasticsearch-plugin install x-pack --batch </span><br><span class="line">./logstash-plugin install x-pack </span><br><span class="line">./kibana-plugin install x-pack</span><br></pre></td></tr></table></figure></p><p>如果要查看已经安装的插件，那就是：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@chen-elk-001 bin]# ./elasticsearch-plugin list</span><br><span class="line">x-pack</span><br><span class="line">[root@chen-elk-001 bin]# ./kibana-plugin list</span><br><span class="line">x-pack@<span class="number">5.6</span><span class="number">.4</span></span><br></pre></td></tr></table></figure></p><p>如果kibana-plugin要卸载x-pack，那就是：<code>./kibana-plugin remove x-pack</code>。</p><p>重启服务即可登录，默认的登录用户名: <code>elastic</code>，密码:<code>changeme</code>。<br><img src="/images/elkredis4.png" alt="paradin"><br><img src="/images/elkredis5.png" alt="paradin"></p><p>这里注意一下，<code>./logstash-plugin install x-pack</code>的时候可能是出现ruby源的错误，如图：<br><img src="/images/elkredis6.png" alt="paradin"></p><p>这是因为中国特色社会主义的网络限制访问<code>https://rubygems.org</code>，一般来说，可以把它更改成阿里的ruby源<code>https://ruby.taobao.org/</code>，不过如果你的服务器无法跨越长城的话，那么更改也是不好使的，所以在这一步，我选择离线安装x-pack。也就是先把<code>https://artifacts.elastic.co/downloads/packs/x-pack/x-pack-5.6.4.zip</code>这个文件下载到本地上传到服务器的root文件夹里，然后安装：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@chen-logstash-001 bin]# ./logstash-plugin install file:///root/x-pack-5.6.4.zip</span><br><span class="line">Installing file: <span class="regexp">/root/</span>x-pack<span class="number">-5.6</span><span class="number">.4</span>.zip</span><br><span class="line">Install successful</span><br></pre></td></tr></table></figure></p><h2><span id="配置filebeat">配置filebeat</span></h2><p>由于这个nginx我们需要先让filebeat把<code>nginx.log</code>和<code>error.log</code>先推到redis存储，然后再由redis推到logstash。配置<code>filebeat.yml</code>的具体信息如下:<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@iZbp10hw6wezxmrvrcjyhlZ filebeat]# grep -iv '#' /etc/filebeat/filebeat.yml | grep -iv '^$'</span><br><span class="line">filebeat.prospectors:</span><br><span class="line">- input_type: log</span><br><span class="line">  paths:</span><br><span class="line">    - <span class="regexp">/usr/</span>local/nginx/logs<span class="comment">/*.log    #这里是nginx的日志文件夹</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">output.redis:                #以下这部分都是新加的</span></span><br><span class="line"><span class="comment">  enabled: true</span></span><br><span class="line"><span class="comment">  hosts: ["127.0.0.1:6379"]</span></span><br><span class="line"><span class="comment">  key: logindexer_list            #与redis配置文件里的key遥相呼应</span></span><br><span class="line"><span class="comment">  password: 『YOURPASSWORD』    #跟上面的密码遥相呼应</span></span><br></pre></td></tr></table></figure></p><p>配置完毕之后，启动filebeat，命令语句：<code>/etc/init.d/filebeat start -c /etc/filebeat/filebeat.yml</code>。</p><h2><span id="配置logstash">配置logstash</span></h2><p>由于这台logstash已经开启了一个logstash进程，那么再收集nginx的日志需要新开一个logstash进程，也需要新写一个conf文件，假设新的conf文件是<code>nginx-logstash.conf</code>，它的写法如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">    redis &#123;</span><br><span class="line">        host =&gt; <span class="string">"10.168.173.181"</span></span><br><span class="line">        type =&gt; <span class="string">"redis-input"</span></span><br><span class="line">        data_type =&gt; <span class="string">"list"</span></span><br><span class="line">        key =&gt; <span class="string">"logindexer_list"</span></span><br><span class="line">        port =&gt; <span class="number">6379</span></span><br><span class="line">        password =&gt; <span class="string">"ChenRedi$"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># filter configration here</span><br><span class="line">output &#123;</span><br><span class="line">     elasticsearch &#123;</span><br><span class="line">        hosts =&gt; [ <span class="string">"10.162.80.192:9200"</span> ]</span><br><span class="line">        user =&gt; elastic</span><br><span class="line">        password =&gt; changeme</span><br><span class="line">        index =&gt; "nginxlogstash-%&#123;+YYYY.MM.dd&#125;"        #这个是新的索引</span><br><span class="line">    &#125;</span><br><span class="line">stdout &#123;</span><br><span class="line">    codec =&gt; rubydebug</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在logstash不支持多个实例共享一个<code>path.data</code>，所以要在在启动不同实例的时候，命令行里增加<code>--path.data PATH</code>，为不同实例指定不同的路径。启动logstash之后，看到显示如下：<br><img src="/images/elkredis7.png" alt="paradin"></p><p>再到nginx的日志看一下，因为logstash里没有做日志的切割，所以是整个一个类似字符串的形式发送了过来：<br><img src="/images/elkredis8.png" alt="paradin"></p><p>果然有这样的日志，可见logstash与nginx的redis已经正确连接。在elasticsearch里，使用<code>curl -u 账号密码 &#39;localhost:9200/_cat/indices?v&#39;</code>查询索引的时候，就会看到那个<code>nginxlogstash</code>，如图：<br><img src="/images/elkredis9.png" alt="paradin"></p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://doc.yonyoucloud.com/doc/logstash-best-practice-cn/input/redis.html" target="_blank" rel="noopener">https://doc.yonyoucloud.com/doc/logstash-best-practice-cn/input/redis.html</a></p>]]></content>
    
    <summary type="html">
    
      整个搭建完毕之后，redis可能key是0，这是正常现象，因为日志量少，直接就消费掉了。
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
      <category term="elk" scheme="http://yoursite.com/tags/elk/"/>
    
      <category term="大数据分析" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Mysql-Atlas从库始终没有建立连接怎么办</title>
    <link href="http://yoursite.com/2018/02/09/Mysql-Atlas%E4%BB%8E%E5%BA%93%E5%A7%8B%E7%BB%88%E6%B2%A1%E6%9C%89%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E6%80%8E%E4%B9%88%E5%8A%9E/"/>
    <id>http://yoursite.com/2018/02/09/Mysql-Atlas从库始终没有建立连接怎么办/</id>
    <published>2018-02-09T05:45:56.000Z</published>
    <updated>2018-02-09T09:29:50.262Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>最近发现阿里云线上环境有一台hls模块的数据库从库一直没有连接，而主库却一直连接不断。在阿里云控制后台看到连接情况如下图：<br><img src="/images/atlas1.png" alt="paradin"></p><p><img src="/images/atlas2.png" alt="paradin"><br>上图是主库的，下面那个是从库的，两者差距很大，可见这样的配置是错误的，因为读库根本没有使用，也就是说读库的那份钱是在浪费！</p><p>来到对应的atlas服务器查看配置，看到atlas 的配置里规定管理接口的用户名和密码是默认的原始套餐，端口被改成了2346，如下面，<br><img src="/images/atlas3.png" alt="paradin"></p><p><img src="/images/atlas4.png" alt="paradin"><br>于是我们就在模块服务器（也就是图里的online-hls-001)上登录这个atlas服务器的管理端口，看一下效果：<br><img src="/images/atlas6.png" alt="paradin"></p><p>发现mysql根本没有反应，可当我们telnet去atlas的2346端口的时候，发现端口是通的：<br><img src="/images/atlas7.png" alt="paradin"></p><p>于是我们返回到atlas 的配置文件，把这台hls模块服务器的ip地址添加到<code>clients-ips</code>这个字段里。<br><img src="/images/atlas8.png" alt="paradin"></p><p>然后再用hls服务器去测试一下atlas的管理端口，<code>mysql -hatlas服务器ip地址 -uuser -ppwd</code>，然后使用<code>select * from backends;</code>,发现里面的两个库一个连接成功，另一个是失败的：<br><img src="/images/atlas9.png" alt="paradin"></p><p>两个库都可以ping通，state却有这样的差别。由此可见这台atlas根本没有连接到从库，导致从库的连接数始终为0。这个时候我们就要检查从库配置的账号密码是否正确，而且在阿里云控制后台给从库开启这个atlas的白名单，然后重新启动这个mysql-proxy进程，再登录atlas管理端口查看，发现从库由down转up了：<br><img src="/images/atlas10.png" alt="paradin"></p><p>但是此时的atlas日志里却出现了很多forbidden的warning的提示：<br><img src="/images/atlas11.png" alt="paradin"></p><p>这时候我们返回atlas的配置文件，把之前的修改过的<code>client-ips</code>这个字段注释掉，让所有合法ip都连接，然后重启atlas，这样这种forbidden ip的警告日志就会消失。</p><p>稍等一会，就会看到从库上也会出现连接数了，至此一切恢复到正常状态，故障排除！<br><img src="/images/atlas12.png" alt="paradin"></p><p>本次故障排除感谢<code>https://highdb.com/?s=atlas</code>这位大神的帮助！</p><h2><span id="文末补充">文末补充</span></h2><p>数据库访问使用了事务的话，从库也会建立连接，只是连接量要小于“非事务访问”，而不是一点连接都没有。</p><p>一般来说，在atlas配置文件里，主库写一个，而从库最好把主库和从库都写进去，如果希望从库承担读的任务多一点的话，可以把权重调高，比如我想从库与主库的读任务比是2：1，那么就可以这么写：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#Atlas后端连接的MySQL主库的IP和端口，可设置多项，用逗号分隔</span><br><span class="line">proxy-backend-addresses = 主库地址:<span class="number">3306</span></span><br><span class="line">#Atlas后端连接的MySQL从库的IP和端口，@后面的数字代表权重，用来作负载均衡，若省略则默认为1，可设置多项，用逗号分隔</span><br><span class="line">proxy-read-only-backend-addresses = 从库地址:<span class="number">3306</span>@<span class="number">2</span>,主库地址:<span class="number">3306</span>@<span class="number">1</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      心已经向家里飞去
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="读写分离中间件" scheme="http://yoursite.com/tags/%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>脚本里添加crontab的方法</title>
    <link href="http://yoursite.com/2018/02/08/%E8%84%9A%E6%9C%AC%E9%87%8C%E6%B7%BB%E5%8A%A0crontab%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2018/02/08/脚本里添加crontab的方法/</id>
    <published>2018-02-08T13:48:37.000Z</published>
    <updated>2018-02-08T13:55:55.951Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>一般来说，增加计划任务都是<code>crontab -e</code>，然后在里面添加内容。但是在一些脚本里，需要自动添加，那么这种情况怎么办？</p><h2><span id="第一种方法">第一种方法</span></h2><p>重定向crontab到其他文件：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">crontab -l &gt; crontab.bak</span><br><span class="line">echo <span class="string">"*/1 * * * * ./yourscript  &gt; /dev/null 2&gt;&amp;1"</span> &gt;&gt; crontab.bak</span><br><span class="line">crontab crontab.bak</span><br></pre></td></tr></table></figure></p><p>如果想删除某个计划任务，就进去<code>crontab -e</code>删除就好，<code>crontab.bak</code>不用管，不用担心内容会自动变成<code>crontab.bak</code>的样子。</p><h2><span id="第二种方法">第二种方法</span></h2><p>如果你觉得使用<code>crontab 文件</code>这种方法心里没有底的话，就选择最妥善的方式，也就是下面这样：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">"*/1 * * * * ./yourscript &gt; /dev/null 2&gt;&amp;1"</span> &gt;&gt; <span class="regexp">/var/</span>spool/cron/root</span><br></pre></td></tr></table></figure></p><p>当crontab突然失效时，可以尝试<code>/etc/init.d/crond restart</code>解决问题。或者查看日志看某个job有没有执行/报错<code>tail -f /var/log/cron</code>。<br><img src="/images/vc15.jpg" alt="paradin" title="半人半神！"></p>]]></content>
    
    <summary type="html">
    
      把脚本作的尽善尽美
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="crontab" scheme="http://yoursite.com/tags/crontab/"/>
    
  </entry>
  
  <entry>
    <title>在百花之中干掉一个杂草连接...</title>
    <link href="http://yoursite.com/2018/02/08/%E5%9C%A8%E7%99%BE%E8%8A%B1%E4%B9%8B%E4%B8%AD%E5%B9%B2%E6%8E%89%E4%B8%80%E4%B8%AA%E6%9D%82%E8%8D%89%E8%BF%9E%E6%8E%A5/"/>
    <id>http://yoursite.com/2018/02/08/在百花之中干掉一个杂草连接/</id>
    <published>2018-02-08T12:43:12.000Z</published>
    <updated>2018-02-08T12:59:06.757Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="正文">正文</span></h2><p>早上接到阿里云的服务器报警，说有一台服务器的流量超标，这个服务器的外网带宽是5M，但是登陆进去使用<code>iftop -i eth1</code>发现里面的流量已经几乎跑满，如图：<br><img src="/images/tcpkill1.png" alt="paradin"></p><p>我这个服务器的名称叫online-mts-001，为啥会有一个mail25.u.tsender.com，这个是什么鬼？莫非是通过我的服务器去连接这个“邮箱”域名？于是我就ping了一下这个mail25.u.tsender.com，结果如图：<br><img src="/images/tcpkill2.png" alt="paradin"></p><p>看到这个域名对应的ip地址是115.29.177.8，嗯，115.29.177.8，哎？这个ip地址好熟悉啊，卧槽，这特么不是这个<code>online-mts-001</code>的外网ip么？<br><img src="/images/tcpkill3.png" alt="paradin"></p><p>也就是说我这个机器在我不知道的情况下被人绑定了一个域名！但是我这个服务器不是网页服务器，上面那个tsender.com的域名打不开，我检查了服务器一番，发现这个机器没有被人入侵的痕迹，只能说是被人有意/无意（无意的可能性更大，比如看错了阿拉伯数字）绑定了域名。</p><p>被人绑定了域名就好比被人起了外号一样，一旦非本人操作就不太好往下摘了，查了很多资料都没有办法，毕竟主动权不在我这里了。</p><p>但是回头过来，我们的重心是要解决那个占据了3M带宽的连接，<code>netstat</code>看了一下，发现这个连接的具体信息如下：<br><img src="/images/tcpkill4.png" alt="paradin"></p><p>仅仅是干掉连接的话，方法有很多，关闭网卡再重开或者关闭相应的服务都可以，但是现在的问题是这台服务器是生产环境的服务器，它主要是给用户提供视频拉流，通过抓包分析得知，这位183.228.128.188的用户合法通过外网连接到了这台视频服务器，而且拉取的是高清视频，所以才占据了这么大的带宽。不过我们还是决定先断开这位用户的连接同时不动其他用户的连接，这位183.228.128.188的用户在客户端虽然会发觉视频断开，但是有缓存和人为刷新的客观因素，实际的体验不会差太多，至少不会投诉400…</p><p>那么如何干掉一个established连接同时保证其他连接呢？请使用<code>tcpkill</code>。</p><p>tcpkill的下载比较有说法，下面是安装步骤：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget http:<span class="comment">//rpm.repo.onapp.com/ramdisk-hv/centos6/dsniff/libnids-1.24-1.el6.x86_64.rpm</span></span><br><span class="line">wget http:<span class="comment">//rpm.repo.onapp.com/ramdisk-hv/centos6/dsniff/libnet-1.1.5-1.el6.x86_64.rpm</span></span><br><span class="line">wget http:<span class="comment">//rpm.repo.onapp.com/ramdisk-hv/centos6/dsniff/dsniff-2.4-0.14.b1.el6.x86_64.rpm</span></span><br><span class="line">yum install libICE libSM libXmu -y</span><br><span class="line">rpm -ivh libnet<span class="number">-1.1</span><span class="number">.5</span><span class="number">-1.</span>el6.x86_64.rpm</span><br><span class="line">rpm -ivh libnids<span class="number">-1.24</span><span class="number">-1.</span>el6.x86_64.rpm </span><br><span class="line">rpm -ivh  dsniff<span class="number">-2.4</span><span class="number">-0.14</span>.b1.el6.x86_64.rpm</span><br></pre></td></tr></table></figure></p><p>请按顺序操作，不然的话dsniff就会报错：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">warning: dsniff<span class="number">-2.4</span><span class="number">-0.14</span>.b1.el6.x86_64.rpm: Header V3 RSA/SHA256 Signature, key ID <span class="number">0608</span>b895: NOKEY</span><br><span class="line">error: Failed dependencies:</span><br><span class="line">libnet.so<span class="number">.1</span>()(<span class="number">64</span>bit) is needed by dsniff<span class="number">-2.4</span><span class="number">-0.14</span>.b1.el6.x86_64</span><br><span class="line">libnids.so<span class="number">.1</span><span class="number">.24</span>()(<span class="number">64</span>bit) is needed by dsniff<span class="number">-2.4</span><span class="number">-0.14</span>.b1.el6.x86_64</span><br></pre></td></tr></table></figure></p><p>安装完毕之后，就会生成<code>tcpkill</code>命令，如图：<br><img src="/images/tcpkill5.png" alt="paradin"></p><p>然后断开上面那个大带宽连接的命令是：<code>./tcpkill -i eth0 src port 9132 and dst port 9595 and src host 115.29.177.8 dst host 183.228.128.188</code>或者<code>./tcpkill -s 115.29.177.8:9132 -d 183.228.128.188:9595</code>。</p><p>但是要注意一下！<font color="red">tcpkill一定要运行在能接收到应答包的主机上在，最好运行在连接或半连接存在的一端主机上，因为tcpkill会发现这个连接里有数据传输进而感知并且干掉</font>。而且tcpkill默认情况下是只能干掉established状态的连接，对于假死连接（连接在，但是数据不传输）或者半连接（由于tcp keeplive没打开而又没有数据向对端发送，导致一直无法感知次连接其实已经断开）是无法断开的。</p><p>如果遇到上述所说的假死连接和半连接就需要手动更改tcpkill的源码，更改原理在<code>https://yq.aliyun.com/articles/59308</code>。</p><p>如果使用的系统是ubuntu or debian，还可以使用cutter命令，<code>apt-get install cutter</code>下载即可。使用方法：<code>http://www.cyberciti.biz/tips/cutting-the-tcpip-network-connection-with-cutter.html</code>。</p><p>至于第一个问题，怎么把这台服务器上的域名撤除，我倒要好好想想了…</p><h2><span id="参考资料">参考资料</span></h2><p><a href="http://www.cyberciti.biz/howto/question/linux/kill-tcp-connection-using-linux-netstat.php" target="_blank" rel="noopener">http://www.cyberciti.biz/howto/question/linux/kill-tcp-connection-using-linux-netstat.php</a><br><a href="http://www.gnutoolbox.com/tcpkill-command/" target="_blank" rel="noopener">http://www.gnutoolbox.com/tcpkill-command/</a></p>]]></content>
    
    <summary type="html">
    
      记得这篇文章是在《人民的名义》热播的时候写的
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="运维" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Zabbix里item取值超时怎么办？</title>
    <link href="http://yoursite.com/2018/02/08/Zabbix%E9%87%8Citem%E5%8F%96%E5%80%BC%E8%B6%85%E6%97%B6%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F/"/>
    <id>http://yoursite.com/2018/02/08/Zabbix里item取值超时怎么办？/</id>
    <published>2018-02-08T03:02:53.000Z</published>
    <updated>2018-02-08T03:16:27.622Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="正文">正文</span></h2><p>开发同学新开发了一个模块，需要运维监控一下<code>8683\8682\9002</code>这三个端口，于是我就在zabbix里把这三个端口进行了监控，但是却无法返回值，如图：<br><img src="/images/item1.png" alt="paradin"></p><p>可见其他的自定义监控项是好使的，偏偏三个监控端口的项都是<code>not-supported</code>。我就进去到item里看看，<code>type of information</code>和<code>data type</code>都是正常的，而且每三十秒一次更新，应该是没有什么问题的。<br><img src="/images/item2.png" alt="paradin"></p><p>于是我就去zabbix的server使用<code>zabbix-get</code>去试试，到底是怎么回事儿，使用结果如图：<br><img src="/images/item3.png" alt="paradin"></p><p>可见使用<code>zabbix_get</code>是可以取到值的，而且取值都正确，三个正常的端口反馈都是1，而不存在的端口（9002）的反馈是0。可是,我发现使用<code>zabbix_ge</code>t取值pid是结果秒出，而取值<code>net.tcp.listen</code>则是等了几乎5秒钟才获得结果。那么问题就出在这里了。</p><p>调整<code>zabbix_agentd.conf</code>里的<code>Timeout</code>值，把其设定为10，然后重启zabbix进程就OK了。</p><h2><span id="补充">补充</span></h2><p>1）<a href="https://www.xiaomastack.com/2015/07/03/zabbix_net-tcp-listen/comment-page-1/#comment-319，很多时候端口监听会出错，于是就用自定义键值的方法，但是小马哥博客里的这个方法在centos里是无法启动，zabbix会报语法错误。由于公司的zabbix是2.2版本，等我有时间需要细化一下这个语法。" target="_blank" rel="noopener">https://www.xiaomastack.com/2015/07/03/zabbix_net-tcp-listen/comment-page-1/#comment-319，很多时候端口监听会出错，于是就用自定义键值的方法，但是小马哥博客里的这个方法在centos里是无法启动，zabbix会报语法错误。由于公司的zabbix是2.2版本，等我有时间需要细化一下这个语法。</a></p><p>2）调整<code>unsupport items</code>检查时间的方法是：在<code>Adiministration</code>里选择<code>General</code>然后在右侧下拉菜单里选择<code>Other</code>，然后修改<code>Refresh unsupported items (in sec)</code>的值，这个值得意思是“每多少秒去重新检查一下那些<code>not_supported</code>的值”。<br><img src="/images/item4.png" alt="paradin"></p><p>3)这种长时间获取key的行为，很容易导致<code>zabbix unreachable poller processes more than 75 busy</code>这个错误，所以尽可能的不要添加这样的监控，而换用其它的方式。导致<code>zabbix unreachable poller processes more than 75 busy</code>这个错误的另一个原因就是可能有某台<code>zabbix-agent</code>死机了。</p>]]></content>
    
    <summary type="html">
    
      开发同学的这个模块一旦启动，会很快的速度建立50000多个连接，zabbix发消息给端口肯定会有延迟，所以就会导致zabbix取端口值困难。而一旦模块停止，取值就会秒取。
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="zabbix" scheme="http://yoursite.com/tags/zabbix/"/>
    
      <category term="运维监控" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>十六年，九个队，一份爱</title>
    <link href="http://yoursite.com/2018/02/07/%E5%8D%81%E5%85%AD%E5%B9%B4%EF%BC%8C%E4%B9%9D%E4%B8%AA%E9%98%9F%E4%BC%8D%EF%BC%8C%E4%B8%80%E4%BB%BD%E7%88%B1/"/>
    <id>http://yoursite.com/2018/02/07/十六年，九个队伍，一份爱/</id>
    <published>2018-02-07T03:21:27.000Z</published>
    <updated>2018-02-08T01:49:52.590Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>原文地址：<a href="https://www.theplayerstribune.com/caron-butler-retiring/" target="_blank" rel="noopener">https://www.theplayerstribune.com/caron-butler-retiring/</a></p><p>我妈第一次坐飞机的时候可真心把她吓得不行，我想她那时候肯定对Pat Riley有一些悄悄的不满。</p><p>那是2002年NBA选秀后的一天，我们乘Pat Riley派来的球队机飞翔在30000英尺的高空，从威斯康辛出发到佛罗里达的迈阿密热火队报到。我现在一闭上眼也能想起当时我妈妈Mattie坐在一个宽敞的椅子里，时而看看我时而看看窗外，前后张望的样子。她的脸上交织出坐飞机的恐惧，但又很自豪的复杂表情。</p><p>“这整个飞机只为我们几个服务的么?”她简直难以置信，要知道整个飞机上的乘客只有我、我的家人和两个热火队的工作代表。</p><p>我其实也是觉得如此的不可思议，但是我要管理好自己的神态，让自己显得比较酷。我坐在的位置上，平复自己的心情，保持正常的呼吸。球队代表给我展示了属于Alonzo Mourning和LaPhonso Ellis的专位，这看上去太梦幻了。</p><p>我对我母亲说“这一切太梦幻了”。</p><p>我一直在告诉我自己，现在我已经是热火队的一份子了。不是我吹牛，我也曾经在康大的时候也坐过飞机去打比赛，但是从来没做过头等舱，这在那个时刻我就坐在这架专机比头等舱还要牛逼的地方。那是Pat Riley级别的仓位。我一直让自己尝试冷静，“Caron，冷静，你很棒，你是个爷们，你要表现的就像以前那样从容。”</p><p>当我回忆起来当时的情景，觉得实在太滑稽了。我一直试图去安抚我那位紧张的老妈，而其实我内心的紧张不比她少多少。</p><p>这就是16年前我去迈阿密热火队报到的情景，从此开始了我的NBA生涯。如果那时候你跟我说我要在十多年的职业生涯里为9个队伍打球，我想我的表情会跟当时飞机上我的老妈一样。</p><p>但是事情就这么发生了，顺其自然，这16年真是一段棒极了的旅行。而今天，我宣布正式从NBA退役。</p><p>你知道，我其实很想写一封信给年轻时候的自己，不过我想12岁的我应该压根不会理会这封穿越时空的信。如果他发现信封里没有钞票，可能就会直接把它扔进垃圾桶里。然后会嘲笑我现在的光头并且补上一刀“哥们，你真老”。</p><p>但我现在就想告诉你那些让我NBA梦成真的人和故事。而这一切的一切都要从当时热火队总裁Pat Riley开始。</p><p>我出生在威斯康星州的拉辛，在18岁之前我没有踏出过那里半步，不过我有听说过芝加哥，也见过有人在迈阿密的海滩上放风筝。除了康涅狄格州那两年，拉辛就是我的全部。大城市？我只有在电影和电视里看到他们的样子。</p><p>然后就是参加NBA选秀，不久我就接到Pat Riley总裁的电话，然后我成了迈阿密的一份子，那一切的一切彷佛是发生在我身体之外的。我觉得我可牛逼了，你知道么？我那时候简直是全世界最幸福的人，我准备把人生最好的青春时光投身于职业篮球，我要让家族骄傲，要让整个拉辛骄傲。</p><p>但我第一天踏进热火队训练馆的时候迎接我的不是派对，生活也不想在海边抽雪茄那么潇洒，迎接我的是“你的更衣间在这里，你迟到了，你应该早来一个小时的，明天开始训练，对了，你叫啥来着？”</p><p>这就是我到训练馆听到的第一句话，这就是热火给我的第一感觉。它让我停止了“从专机到专车，全家在迈阿密的豪华旅行，每个人都以我为豪”的感觉，开始了真刀真枪的训练—-我看到Pat Riley就站在训练场场边，他手上带着总冠军戒指，他很正经的跟你说，马上去好好训练或者从训练馆出去。</p><p>迈阿密的纸醉金迷让很多年轻人迷失，不过那种夜生活对我没有什么侵蚀力。我14岁的时候就有了我第一个儿子，我年少的时候可没少蹲过号子，记得我16岁的时候，警察曾经在我学校的储物柜里搜出来了毒品和手枪，我也被拘留了一段时间。我出自黑人街头，小时候经历了很多哥们朋友死掉。所以我没有期待过什么幸福温暖的日子，那时候，篮球是我唯一守护的东西。我尽力的不让那些声色犬马去分散我的注意力。</p><p>不过那时候我毕竟还是一个小孩，虽然我心态还算端正，但是我却不知道如何百分百的把精力都投入到训练里去。</p><p>最开始的几个月对于我整个职业生涯来说是非常重要的，热火队从一开始培养我的比赛观和胜负观，你把它想像成是一个称之为愿望也好，意志力也好，反正就是一个坚定的信念，我想正是这个信念让我能在NBA待这么久。我们为热火队打球，为Pat Riley总裁和Stan Van教练卖命。他俩教会了我如何正确的身体训练，正确的战术训练，叮嘱我们正确的去准备比赛，告诫我们细节决定成败。而这些都是你每晚在TNT直播中看那些NBA球员时所看不见的。</p><p>幸运的是，我很早就领悟到“天赋并没有你想象的那么重要”这个道理，当然，有天赋肯定很赞，但是如果你在比赛里倾尽所有、全力以赴，哪怕你的对手比你能跳能跑，但是你也有很大的几率赢球。钻研，不断地打磨技术，这才是赢球的不二法则。如果有人说“在NBA这么高水平的比赛里，基本功并不是重要”，这话简直就是痴人说梦。</p><p>Pat Riley教练会以各种不同的方式教我事情，我永远不会忘记他会在我的更衣柜上留下字条，我会在训练前看到这些字条，上面有些写的是我技术上缺陷和需要进步的地方，有些写的是励志的话语。那虽然只是简单的一两句话的便条，但是每一句话都对我有着绝大的影响，这就是我跟我篮球教父之前所建的秘密联系通道—用我们自己的语言去彼此沟通，正是这每一张字条让我成为了一个更好的篮球选手。多年之后，我转会去了雷霆队。我开始效仿当年Pat Riley给我留字条那样的给Kevin Durant留字条，KD是我的小兄弟。我很惊讶和感激在他的MVP的获奖演讲里他特别提到了这个事儿。但是我看来，我只是做了我的篮球恩师Pat Riley做的事情。</p><p>第二年，当我得知被交易去湖人队的时候，我很受伤，我以为Pat Riley跟我在篮球层面的之间是有特殊关系的。我的意思是说，如果我当时在Pat Riley的位置上也会把自己拿去交易Shaq的。如果你看着镜子中自己，然后说你比Shaq对这个队伍更有价值，那我无话可说，因为我实在不想打击你的自尊心。</p><p>不过那种失落并没有持续很久啦，这就是在联盟里生存的学费。就像我前面说的，我在拉辛住了十多年，我也希望终老迈阿密。我还记得跟D-Wade、Brian Grant、Eddie Jones、Alonzo这些家伙一起打球的日子，那是一段令人难以置信的学习经历，我会永远记得和那些家伙一起玩的开心时光。但是这就是生意，不久后我就动身出发去洛杉矶报到，身边的人从Dwyane Wade变成了Kobe Bryant，Dwyane Wade是我的铁哥们，但是这个世界也没几个人会拒绝跟Kobe联手。当我到了洛杉矶也就大约一周的时间吧，当初到迈阿密的紧张感觉被我忘个干净。</p><p>我仅仅在湖人效力了一个球季就被交易去了华盛顿奇才，有趣的是，那个交易对我来说没什么伤害。我认为那是一个很好的决定，当时的奇才队有很多年轻的充满天赋的选手，我很高兴有机会成为他们的一员。</p><p>华盛顿的六年是我一生中最棒的时光，在奇才队我两次入选全明星赛。我和Antawn Jamison、Brendan Haywood、以及当时还没有称呼自己是“Hibachi”的Gilbert Arenas在东部打出了一片天,我永远记得华盛顿人民是多么的热爱那支奇才队。纵然迈阿密和洛杉矶都是超级大城市，但是华盛顿却是我职业生涯效力时间最长的地方，那是我第二个篮球之家。<br><img src="/images/caron1.jpg" alt="paradin"></p><p>交易帮助我学习到了篮球生意的真相，我不论到哪个球队，都试图在训练里做一个榜样，就用当初在迈阿密学到的那套。我在健身房里专注训练，总是要求自己做的更好，总是要求自己记住细节。在每一支队伍里我都与队友们打成一片，我的意思是，换做是你整天跟这帮队友们泡在一起，如果你不是太拘谨的话，会很容易融入这个集体的。</p><p>不过我毕竟辗转了九个城市，这漂泊的生活对我的家庭来说是很困难的。要知道，我那时仅仅在菲尼克斯就待了一个月左右的时间，我的妻子Andrea又不得不收拾行李搬家去下一站，所以我的孩子们总是在不停的转学转学。我妈–她一直以我为荣，即使我不是比赛中的MVP，但是只要我命中投篮但是没有拿下比赛最佳球员她都会在场边不爽（谢谢你，老妈）。但我也深知，为了我的篮球生涯，其实我的家庭牺牲了很多。</p><p>我现在感谢上苍，我依旧活着，这简直是一个奇迹。我现在想谈谈生与死，上周，我回拉辛去参加一个葬礼，那是一个26岁的小伙子，从他的车上逃离的时候被警察连开数枪。我本人不认识他，但是我理解那种感觉。因为我和那些在拉辛长大的朋友，我们都知道死亡随时都降临的恐惧感。我深深地理解被困在那里是一种什么滋味，我很幸运我走出来了。我知道那些被杀或者误入歧途的人没有离开那座城市。我参加过很多个葬礼，那很难受。不过很奇怪，在生活中你会像我一样已经达到了一定的高度，当周围人告诉你你已经挺过来了，你也会想“我真的做到了”，就是这样，但是并不是那么简单。我想我还是回回到家乡来看看的，以后也常回来。</p><p>对于现在的我来说那些拉辛的孩子就跟曾经的我一样，我也出生在这里，我也曾经是拉辛的孩子，我也做过各式各样的蠢事。但是我从中交了学费，要知道从教训里学习的确不是一个容易的事儿，我花的时间比我母亲期望的时间要长，但是我最终还收获了经验。一旦我有一个目标，就要付出全部，我不想让那些相信我的人失望。我能拥有如此多的东西，我已经很知足了。</p><p>文章的最后我想说几个人，这可能会像是一连串名单，毕竟我在联盟里摸爬滚打了这么多年，肯定有很多人要去感谢，如果我忘记了提到某人，那请准许我提前道歉。</p><p>在我开始第一场NBA比赛之前，我的妻子就对我说无论我去哪里她都会跟着，这么些年，她一直信守当初的承诺。这辈子讨到她做老婆真是我的福气，无论是现在还是将来她都会是我生命里最棒的那部分。</p><p>感谢BJ Evans、Rob Wilson、Tim Donovan、Andy Elisberg、Jay Sabol、Marjie Kates、Shivani Desai、Tim Grover 和整个Arison家族在我职业生涯初期给我的帮助。</p><p>我要感谢Buss 家族、Mitch Kupchak、Magic Johnson、Alison Bogli和Eugenia Chow在洛杉矶给我的支持。</p><p>感谢Ernie Grunfeld、Milt Newton、Tommy Amaker、Sashia Jones、Candace、Susan O’Malley在华盛顿给我的帮助。</p><p>感谢老板Mark Cuban和主教练Rick Carlisle在达拉斯给我的帮助。</p><p>还有我在快船队的队友们：Blake Griffin、DeAndre Jordan、CP3–正是你们让我从重伤中走出来，重获新生。<br><img src="/images/caron2.jpg" alt="paradin"></p><p>Matt Barnes、Lamar Odom、Chauncey Billups还有我的偶像Grant Hill，我不会忘记跟你们一起的那段日子。</p><p>我一直都梦想能穿着雄鹿队的队服打球，感谢John Hammond和Senator Kohl，你们圆了我的梦，说实话在家乡打球的感觉真好！谢谢你们。</p><p>在雷霆队，我要感谢总经理Sam Presti、KD和Russell Westbrook。</p><p>在活塞队，我要感谢Tom Gores，而且在底特律能跟Stan Van重聚，并且与我的哥们Andre Drummond、Reggie Jackson和Caldwell-Pope一起打球。</p><p>Vlade Divac，是你在2016年给那个躺在沙发里以为生涯到此结束了的我打了电话，让我再去国王队跟Rajon Rondo和DeMarcus Cousins打了一年球。</p><p>还有一个需要特别说的，那就是刚刚去世的我永远的哥们Rasual Butler，我俩同一年进入联盟。像我一样，Rasual Butler也是一个辗转多队的浪人，但他身上有我敬佩的一切特征—勤奋、专业、积极、体育精神。他是一个人民交口称赞的好队友。哥们，NBA的家人们会想你的。</p><p>我的粉丝们，你永远不会知道你们曾经带给我的快乐。谢谢你们的支持!我希望每当你想到Caron Butler这个名字的时候，你会记得我曾经是多么的热爱和尊重比赛，我也希望你们会记住我付出所有时的那个形象。我知道这是一个陈词滥调，但那个形象对我来说要比比赛还要重要–这让我可以去面对一个严峻的未来。</p><p>我现在仍然会深深地回想起2002年那次飞往迈阿密的情景，当时我和我的家人在热火队的飞机上—不是因为昂贵或奢侈，也不是因为我第一次去海边。而是因为那是我一生中第一次真的感觉要去某个地方。</p><p>在NBA打球是我的梦想，我和所有这些伟大的教练和队友们一起度过了这16年，那是一段比我想象的要好的时光。我虽然身体已经不适合打NBA的比赛，但是篮球依旧在我的生活里，我会以另外的一种形式继续跟它在一起。</p><p>我只想让你们都知道我拥有我自己的生命，但正是有了你们的帮助，这个生命才活的如此多姿多彩。<br><img src="/images/caron3.png" alt="paradin"></p>]]></content>
    
    <summary type="html">
    
      再见，Caron Butler，祝你退役快乐！
    
    </summary>
    
      <category term="坠乱花天" scheme="http://yoursite.com/categories/%E5%9D%A0%E4%B9%B1%E8%8A%B1%E5%A4%A9/"/>
    
    
      <category term="NBA" scheme="http://yoursite.com/tags/NBA/"/>
    
  </entry>
  
  <entry>
    <title>记录Uwsgi与Django成功勾搭的始末</title>
    <link href="http://yoursite.com/2018/02/07/%E8%AE%B0%E5%BD%95Uwsgi%E4%B8%8EDjango%E6%88%90%E5%8A%9F%E5%8B%BE%E6%90%AD%E7%9A%84%E5%A7%8B%E6%9C%AB/"/>
    <id>http://yoursite.com/2018/02/07/记录Uwsgi与Django成功勾搭的始末/</id>
    <published>2018-02-07T02:15:09.000Z</published>
    <updated>2018-02-07T02:37:09.169Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="环境说明">环境说明</span></h2><p>Uwsgi版本：<code>2.0.14</code>(yum install安装）<br>django版本：<code>1.10.6</code>（pip install安装）<br>python版本：<code>2.7.5</code>(阿里云 centos 7自带）<br>nginx版本：<code>1.10.2</code>（yum install安装）</p><h2><span id="正文">正文</span></h2><p>在<code>https://rorschachchan.github.io/2018/02/02/Uwsgi的安装和简单使用/</code>里面，我们已经实现了网页打开出现”good bye,logan”的效果，可见<code>Web Client &lt;===&gt; uWSGI &lt;===&gt; Python</code>是通畅的，现在我们要调整看看django与uwsgi是否是通畅的。</p><p>首先，我们在/django这个目录下，<code>django-admin.py startproject logan</code>，建立了一个叫logan的project，然后在/django/logan/logan里会有一个自动生成的<code>wsgi.py</code>，打开一看，里面的内容如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">WSGI config for logan project.</span></span><br><span class="line"><span class="string">It exposes the WSGI callable as a module-level variable named ``application``.</span></span><br><span class="line"><span class="string">For more information on this file, see</span></span><br><span class="line"><span class="string">https://docs.djangoproject.com/en/1.10/howto/deployment/wsgi/</span></span><br><span class="line"><span class="string">"</span><span class="string">""</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> django.core.wsgi <span class="keyword">import</span> get_wsgi_application</span><br><span class="line">os.environ.setdefault(<span class="string">"DJANGO_SETTINGS_MODULE"</span>, <span class="string">"logan.settings"</span>)</span><br><span class="line">application = get_wsgi_application()</span><br></pre></td></tr></table></figure></p><p>我们原来的目标就是测试django跟uwsgi的链接是否正常，那么返回到/django/logan，使用<code>python manage.py runserver 0.0.0.0:8000</code>启动django，然后打开浏览器，在地址栏里输入<code>外网ip:8000</code>，看到了如下的界面：<br><img src="/images/ud1.png" alt="paradin"></p><p>可见django已经启动成功，但是前面说过了，这种方法只能测试环境里小规模的玩玩，完全不推荐拿去生产化境里。所以现在我们用uwsgi在8000来启动一下django。</p><p>首先，先停止了原来我们启动的django。</p><p>然后，使用命令<code>uwsgi --http :8000 --wsgi-file logan.py</code>,反馈错误信息如下：<br><img src="/images/ud2.png" alt="paradin"></p><p>出现这个错误，那就<code>yum install uwsgi-plugin-python</code>，同时使用<code>uwsgi --plugin python --http-socket :8001 --wsgi-file /django/logan/logan/wsgi.py</code>，这样却又出了一个新错误：<br><img src="/images/ud3.png" alt="paradin"></p><p>提示说：<code>ImportError: No module named logan.settings</code>。可是当我使用python客户端单独测试的时候，这个语句是可以使用的，如图：<br><img src="/images/ud4.png" alt="paradin"></p><p>很多人都卡在了这种情况，这个时候我们需要换一个命令：<code>uwsgi --plugin python --http-socket :8001 --chdir /django/logan/ --wsgi-file /django/logan/logan/wsgi.py</code>。然后我们在浏览器地址栏里输入<code>外网地址：8001</code>就可以看到如下网页：<br><img src="/images/ud5.png" alt="paradin"></p><p>可见，我们已经通过uwsgi启动了原本已经关闭了的django，这样就达到了<code>Web Client &lt;===&gt; uWSGI &lt;===&gt; Django</code>的目的。</p><p>如果过程中出现了端口被占用的情况，比如8002端口已经被使用了：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">probably another instance <span class="keyword">of</span> uWSGI is running on the same address (:<span class="number">8002</span>).</span><br><span class="line">bind(): Address already <span class="keyword">in</span> use [core/socket.c line <span class="number">764</span>]</span><br></pre></td></tr></table></figure></p><p>那么就可以使用<code>lsof -i:8002</code>，然后把对应的进程干掉就好了。</p><p>最后附赠python脚本一个，这个脚本可以显示python的path，内容如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">print <span class="string">'===== sys.path / PYTHONPATH ====='</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> sorted(os.environ.keys()):</span><br><span class="line">    v = os.environ[k]</span><br><span class="line">    print (<span class="string">'%-30s %s'</span> % (k,v[:<span class="number">70</span>]))</span><br></pre></td></tr></table></figure></p><h2><span id="参考资料">参考资料</span></h2><p><a href="http://www.python88.com/topic/101/" target="_blank" rel="noopener">http://www.python88.com/topic/101/</a><br><a href="http://www.nowamagic.net/academy/detail/1330334" target="_blank" rel="noopener">http://www.nowamagic.net/academy/detail/1330334</a></p>]]></content>
    
    <summary type="html">
    
      这一步是搭建框架的import key，在这里面你能感受到python版本的恶心...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="uwsgi" scheme="http://yoursite.com/tags/uwsgi/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins与钉钉机器人实现手机端获取当前服务日志</title>
    <link href="http://yoursite.com/2018/02/06/Jenkins%E4%B8%8E%E9%92%89%E9%92%89%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%90%AD%E9%85%8D%E6%89%8B%E6%9C%BA%E7%AB%AF%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%9C%8D%E5%8A%A1%E6%97%A5%E5%BF%97/"/>
    <id>http://yoursite.com/2018/02/06/Jenkins与钉钉机器人搭配手机端获取当前服务日志/</id>
    <published>2018-02-06T12:56:33.000Z</published>
    <updated>2018-02-06T15:10:43.721Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>马上要过年了，各位运维们除了因为买不到回家的火车票而嚎嚎大哭之外也开始扩容服务器和提前调整监控值，目的就是为了过一个消停的春节。可是这毕竟十天左右不在公司，要是模块真出了什么意外肯定没法第一找到日志分析问题，毕竟这几天都在串门拜年和醉生梦死中度过，走到哪都要再背一个笔记本实在太不方便了。</p><p>那么这个时候，我就琢磨使用手机端来启动服务器里脚本，让这个脚本可以去获取当前的日志，然后再把结果返回到手机端。这样就不用到哪里都带那个一看就很扫兴的公司笔记本电脑了。</p><p>使用手机端启动服务器里脚本？我又不会开发android和ios，那么肯定就要使用第三方工具，我条件反射的想到了jenkins，因为jenkins是用手机可以登录的，那么在手机端得到结果用什么呢？在微信公众号和钉钉机器人里，我选择了钉钉机器人。</p><h2><span id="创造钉钉机器人">创造钉钉机器人</span></h2><p>我的钉钉版本是4.2.6.37，首先在左上角头像的三角菜单有一个<code>机器人管理</code>，如图：<br><img src="/images/dingding1.png" alt="paradin"></p><p>然后选择自定义机器人，给它起个名又换一个图标之后，添加到一个群聊里，如图：<br><img src="/images/dingding2.png" alt="paradin"></p><p>添加的时候，这个机器人会生成一个<code>webhook</code>，它的结构应该是：<code>https://oapi.dingtalk.com/robot/send?access_token=XXX</code>，后面的XXX是标识符，不同的标识符代表不同的机器人，这个标识符如果丢了，可以在机器人头像点击一下然后选择<code>机器人设置</code>重新看到。</p><h2><span id="编写机器人脚本">编写机器人脚本</span></h2><p>机器人的官方说明网址就是<code>https://open-doc.dingtalk.com/docs/doc.htm?spm=a219a.7629140.0.0.zZIvnt&amp;treeId=257&amp;articleId=105735&amp;docType=1</code>，这里面已经把使用方法写的够清楚了。我这里的这个python脚本是用json的格式，如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/python</span></span><br><span class="line">#coding: utf-8</span><br><span class="line"><span class="keyword">import</span> json,urllib2</span><br><span class="line"></span><br><span class="line">#这里是机器人对应的Webhook地址</span><br><span class="line">url = <span class="string">"https://oapi.dingtalk.com/robot/send?access_token=这里输入你机器人的标识符</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#这里是头，原样复制就好</span></span><br><span class="line"><span class="string">header = &#123;</span></span><br><span class="line"><span class="string">    "</span>Content-Type<span class="string">": "</span>application/json<span class="string">",</span></span><br><span class="line"><span class="string">    "</span>charset<span class="string">": "</span>utf<span class="number">-8</span><span class="string">"</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#这里是传送的消息</span></span><br><span class="line"><span class="string">data = &#123;</span></span><br><span class="line"><span class="string">    "</span>msgtype<span class="string">": "</span>text<span class="string">",</span></span><br><span class="line"><span class="string">       "</span>text<span class="string">": &#123;</span></span><br><span class="line"><span class="string">           "</span>content<span class="string">": "</span>这里是消息正文！<span class="string">"</span></span><br><span class="line"><span class="string">      &#125;,</span></span><br><span class="line"><span class="string">   "</span>at<span class="string">": &#123;</span></span><br><span class="line"><span class="string"> "</span>atMobiles<span class="string">": [</span></span><br><span class="line"><span class="string">           "</span>A的手机号<span class="string">",</span></span><br><span class="line"><span class="string">"</span>B的手机号<span class="string">"</span></span><br><span class="line"><span class="string">]， </span></span><br><span class="line"><span class="string">           "</span>isAtAll<span class="string">":False   #这里True代表要发给所有人，False的话，要代表消息只发给A和B这两个人</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">   &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">sendData = json.dumps(data)</span></span><br><span class="line"><span class="string">request = urllib2.Request(url,data = sendData,headers = header)</span></span><br><span class="line"><span class="string">urlopen = urllib2.urlopen(request)</span></span><br><span class="line"><span class="string">print urlopen.read()</span></span><br></pre></td></tr></table></figure></p><p>直接执行这个脚本，就会看到我刚新建的钉钉机器人在群聊里说话了。<br><img src="/images/dingding3.png" alt="paradin"></p><h2><span id="机器人搭配nginx">机器人搭配nginx</span></h2><p>上面那个脚本已经可以初步实现我们的目的，但是有一个缺点，就是正文内容不能过长。但是我想多打印一点日志，至少50行，怎么办？我想了想，可以把日志放进nginx的一个网页里，然后用钉钉机器人反馈这个网页地址啊，这样内容想写多少就可以写多少了。</p><p>假设我现在获取到的日志的文件写进一个叫<code>chairmanmao.html</code>里，在浏览器打开看是这样的：<br><img src="/images/dingding4.png" alt="paradin"></p><p>那么上面那个机器人的python脚本就要改成这样：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/python</span></span><br><span class="line">#coding: utf-8</span><br><span class="line"><span class="keyword">import</span> json,urllib2,commands</span><br><span class="line"></span><br><span class="line">commands.getstatusoutput('echo -e "THIS IS TEST MESSAGE！ \n" &gt; /路径/chairmantail.html')#这里可以给网页加一个标题</span><br><span class="line">commands.getstatusoutput('cat /路径/chairmanmao.txt &gt;&gt;  /路径/chairmanmao.html')#这里就是把诗词写进html文件里</span><br><span class="line"></span><br><span class="line">#这里是机器人的webhook地址</span><br><span class="line">url = <span class="string">"https://oapi.dingtalk.com/robot/send?access_token=这里输入你机器人的标识符"</span></span><br><span class="line"></span><br><span class="line">header = &#123;</span><br><span class="line">    <span class="string">"Content-Type"</span>: <span class="string">"application/json"</span>,</span><br><span class="line">    <span class="string">"charset"</span>: <span class="string">"utf-8"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">     <span class="string">"msgtype"</span>: <span class="string">"link"</span>,</span><br><span class="line">        <span class="string">"link"</span>: &#123;</span><br><span class="line">                <span class="string">"text"</span>: <span class="string">"点击网址就可获取到本次日志查询的结果"</span>,</span><br><span class="line">                <span class="string">"title"</span>: <span class="string">"日志查询结果已经生成！"</span>,</span><br><span class="line">                "picUrl": "http://p1x3hd2at.bkt.clouddn.com/nanshen.jpg",#这里可以加一个缩略图片</span><br><span class="line">                <span class="string">"messageUrl"</span>: <span class="string">"http://服务器外网IP地址/chairmanmao.html"</span></span><br><span class="line">    &#125;,</span><br><span class="line">     <span class="string">"at"</span>: &#123;</span><br><span class="line">            "isAtAll":True   # at为非必须</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">sendData = json.dumps(data)</span><br><span class="line">request = urllib2.Request(url,data = sendData,headers = header)</span><br><span class="line">urlopen = urllib2.urlopen(request)</span><br><span class="line">print urlopen.read()</span><br></pre></td></tr></table></figure></p><p>执行这个脚本可以看到机器人发送的信息如下：<br><img src="/images/dingding5.png" alt="paradin"></p><p>然后打开这个网址，就看到完整的网页信息：<br><img src="/images/dingding6.png" alt="paradin"></p><p>到时候把毛主席诗词换成实际的日志文件就好了，不用一口气打印所有的日志出来，<code>tail -n 50 日志文件名</code>，50行足够用了。</p><h2><span id="配置jenkins">配置Jenkins</span></h2><p>脚本写完了，机器人也写完了，这个时候就要添加“启动端”。安装Jenkins的步骤我这里就不写了，直接可以去看<code>https://rorschachchan.github.io/2018/02/05/Jenkins安装与创建简单任务/</code>。现在去登录Jenkins的网页，去添加一个新的Job，比如我这个Job就叫“获取模块日志”，如图：<br><img src="/images/dingding7.png" alt="paradin"></p><p>如果是要在Jenkins上去读取其他服务器的日志，就可以在<code>构建project</code>的时候选择<code>参数化构建过程</code>，然后配置参数ip，到时候把这些ip传递给目标脚本。如果觉得这样hold不住，可以不用jenkins的这个功能，把ip写到脚本里去，一了百了：<br><img src="/images/dingding8.png" alt="paradin"></p><p>在<code>构建</code>那一步，选择<code>Execute Shell</code>，然后里面写上具体的shell命令，如果在上面使用了参数，那么参数就可以在这里使用，我的脚本里是没有ip这个参数的，在图里写<code>$ip</code>就是做一个例子讲解一下用法而已：<br><img src="/images/dingding9.png" alt="paradin"></p><p>在<code>构建后操作</code>这一步可以选择<code>E-mail Notification</code>，这样如果失败了会发送邮件通知。如果用不着就什么都不用选。然后就是保存好这个project，点击左侧菜单栏的<code>立即构建</code>，就会看到下面<code>Build History</code>会多一个<code>#1</code>出来，同时钉钉机器人也在群里发消息，这个<code>#1</code>就是构建的记录，这个纪录多了的话，新纪录会覆盖掉老的记录。<br><img src="/images/dingding10.png" alt="paradin"></p><p>点击这个<code>#1</code>，选择<code>控制台输出</code>，就能看到具体的操作结果了，跟在shell界面里执行的效果差不多的。可见操作成功，目的已经达到了！<br><img src="/images/dingding11.png" alt="paradin"></p><p>以后需要调用脚本，就在手机端浏览器里登陆jenkins，然后构建一下这个project，同时就可以看到钉钉里机器人有反馈了。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://xu3352.github.io/linux/2017/05/01/jenkins-restart-remote-server-tomcat" target="_blank" rel="noopener">https://xu3352.github.io/linux/2017/05/01/jenkins-restart-remote-server-tomcat</a><br><a href="https://github.com/typ431127/zabbix_dingding" target="_blank" rel="noopener">https://github.com/typ431127/zabbix_dingding</a></p>]]></content>
    
    <summary type="html">
    
      钉钉机器人要是能发送参数到服务器里然后执行脚本就太好了！
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="jenkins" scheme="http://yoursite.com/tags/jenkins/"/>
    
      <category term="钉钉" scheme="http://yoursite.com/tags/%E9%92%89%E9%92%89/"/>
    
  </entry>
  
  <entry>
    <title>一次官网打不开的经历</title>
    <link href="http://yoursite.com/2018/02/06/%E4%B8%80%E6%AC%A1%E5%AE%98%E7%BD%91%E6%89%93%E4%B8%8D%E5%BC%80%E7%9A%84%E7%BB%8F%E5%8E%86/"/>
    <id>http://yoursite.com/2018/02/06/一次官网打不开的经历/</id>
    <published>2018-02-06T06:10:12.000Z</published>
    <updated>2018-02-06T06:32:46.175Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>今天有人反映官网在登陆的时候，chrome浏览器不能正常打开页面，反而会出现一个下载框。我使用IE浏览器尝试登录官网，页面也不是正常的页面，而是下面的内容：<br><img src="/images/guanwang1.png" alt="paradin"></p><p>由于官网的域名跳转是在阿里云的域名解析的地方配置的，于是就登陆到阿里云的域名解析地方，查看了一下发现，这里的配置是<code>www.lechange.com</code>会302跳转到<code>home.lechange.com</code>，而ping一下<code>home.lechange.com</code>得到的ip地址是一个负载均衡的地址，然后在阿里云的控制台查询这个负载均衡的情况，发现这个负载均衡后面挂载的是两台服务器A和B。</p><p>于是我在浏览器里面直接输入负载均衡的ip地址，发现还是像上面那样错误的php界面，而浏览器地址栏使用两个服务器的外网ip却是正常可以打开的。这个时候初步怀疑是SLB的问题，而我当时就觉得就凭上面这一点就去跟阿里撕逼不太妥当，但是事实告诉我们事情不是那么简单的。</p><p>我检查一下slb的端口配置情况，分别是<code>http 80转8080</code>和<code>https 443转80</code>，可见这个网站有两个协议，一个是http的而一个是https的，我们刚才虽然在浏览器里直接使用A和B的外网ip访问是可以正常打开页面，只能说明http协议是OK的，我们还要测试一下https协议访问的效果。</p><p>我就在浏览器地址栏里进一步尝试，发现使用<code>A外网ip：8080</code>访问是OK的，而使用<code>B外网ip：8080</code>访问就是PHP的文字界面。于是基本问题定位到B服务器里有文件的配置错误。</p><p>登陆到B服务器里，在nginx的conf文件夹里发现一个多余的文件，打开内容如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">server </span><br><span class="line">&#123; </span><br><span class="line">       listen       <span class="number">8080</span>; </span><br><span class="line">       server_name  www.lechange.com (file:<span class="comment">//www.lechange.com/) www.lechangebuy.com (file://www.lechangebuy.com/); </span></span><br><span class="line">       index index.html index.htm index.php; </span><br><span class="line">       root  /data/www/ecstore; </span><br><span class="line">       add_header  pos <span class="string">'web2'</span>; </span><br><span class="line">#       location / &#123; </span><br><span class="line">#               rewrite ^/(.*)$ https://www.lechangebuy.com/$1; </span><br><span class="line">#       &#125; </span><br><span class="line">       location /public &#123; </span><br><span class="line">               root  /data/www/ecstore; </span><br><span class="line">       &#125; </span><br><span class="line">       access_log /data/logs/nginx/access.log; </span><br><span class="line">#access_log off; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而原来nginx是有正常的conf文件，现在又多余了一个这个文件，可见是因为没有无法正常解析.php的文件，两个文件都在占用8080端口时出现了冲突，所以就导致这样php download界面的情况。删除这个多余的文件后，重启nginx，清除浏览器缓存，再重新尝试就正常打开页面了。</p><p>为什么会多一个这样的文件，后来把各位运维人员严刑拷打一顿才知道，原来有一次某运维小弟在B服务器里面做跳转的测试，测试完毕之后忘记了把这个多余的文件删除，原本这一切是没有问题的，但是可能服务器nginx经历了重启，于是就加载了这两个conf文件，就把这个隐藏的问题暴露了。</p>]]></content>
    
    <summary type="html">
    
      想要说平时工作千万别留坑，不然害的就是自己啊
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>往github里上传代码</title>
    <link href="http://yoursite.com/2018/02/05/%E5%BE%80github%E9%87%8C%E4%B8%8A%E4%BC%A0%E4%B8%80%E4%B8%AA%E4%BB%A3%E7%A0%81/"/>
    <id>http://yoursite.com/2018/02/05/往github里上传一个代码/</id>
    <published>2018-02-05T14:40:22.000Z</published>
    <updated>2018-02-06T02:14:59.815Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>说来惭愧，使用hexo博客这么久了，但是真正使用github保存代码却是第一次。因为要打算自己搞一个jenkins试试自动化部署，所以就打算把我那些不堪入目的代码放在github上，然后用jenkins去执行。今天这篇文章就是来记录如何把本地的代码文件上传到github上的过程，本次过程是在windows下操作的。</p><h2><span id="建立远端仓库">建立远端仓库</span></h2><p>首先登录github的界面，然后建立一个新的仓库（repository），如图：<br><img src="/images/github3.png" alt="paradin"></p><p>在建立仓库的时候，要注意最好选择一下<code>Initialize this repository with a README</code>这个选项，这样可以省去一些麻烦，如图：<br><img src="/images/github4.png" alt="paradin"></p><p>在这里就用我刚建立的仓库—<code>chentest</code>。</p><h2><span id="建立本地仓库">建立本地仓库</span></h2><p>首先我们先去<code>http://windows.github.com/</code>上下载git工具，在安装的时候你还可以顺便登陆，如果没有github账号的话这一步可以跳过的。<br><img src="/images/github1.png" alt="paradin"></p><p>安装完毕你的鼠标右键应该多了一个功能<code>Git Bash Here</code>，此时，可以在电脑找一个文件夹，这个文件夹不推荐安装在C盘，假设我就在E盘根目录下叫<code>chentest</code>的文件夹，这个文件夹名称应该与我们刚刚建立的github仓库名称相同。不然的话，可能在git pull的时候爆<code>fatal: refusing to merge unrelated histories</code>这个错误。</p><p>在这个chentest的空文件夹空白处，右键鼠标，然后选择<code>Git Bash Here</code>，就会出现一个类似dos的命令行窗口，此时需要输入<code>git init</code>，这个时候发现chentest文件夹里多一个隐藏文件叫<code>.git</code>，这就代表本地仓库已经创建成功了。</p><h2><span id="配置公私钥">配置公私钥</span></h2><p>然后就是建立一个SSH key，以后你上传任何东西到远端仓库的时候都要输入这个key，那么在命令窗口输入<code>ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot;</code>，此时会让你输入一个文件路径，这个路径就是存放SSH key公钥和私钥的地方，由于我这个电脑已经在默认的<code>/c/user/33664/.git/id_rsa</code>已经存放了hexo博客的上传密钥了，于是我就手动把路径改成了<code>/c/user/33664/.git/id_rsa-github</code>，如图：<br><img src="/images/github2.png" alt="paradin"></p><p>这里注意！<font color="red">如果你也之前有一个git id_rsa密钥的话，我个人强烈推荐这个密钥跟之前的id_rsa密钥是一样的。</font></p><p>在浏览器里返回到github的<code>settings</code>主页，在<code>SSH and GPG keys</code>里点击<code>New SSH key</code>，然后就把刚刚生成密钥的pub版输入进去，这个公钥是可以告诉别人的，但是私钥要保密好。如图：<br><img src="/images/github5.png" alt="paradin"></p><p>再命令行里输入<code>ssh -T git@github.com</code>，这时候会让你输入一下<code>/c/user/33664/.git/id_rsa</code>的密钥，由于我刚刚把id_rsa-github密钥和id_rsa密钥内容是一样的，所以就输入正确了。如图：<br><img src="/images/github6.png" alt="paradin"></p><h2><span id="进一步配置">进一步配置</span></h2><p>此时，再在命令行里输入如下的语句：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"your name"</span></span><br><span class="line">git config --global user.email <span class="string">"your_email@youremail.com"</span></span><br><span class="line">git remote add origin git@github.com:用户名/Git仓库名称.git#我这个例子里就是chentest.git</span><br><span class="line">git config branch.master.remote origin  </span><br><span class="line">git config branch.master.merge refs/heads/master</span><br></pre></td></tr></table></figure></p><p>一个项目可以同时拥有好几个远端仓库为了能够区分，通常会起不同的名字。通常主远端仓库被称为origin。</p><p>加完之后进入<code>.git</code>，打开<code>config</code>，这里会多出一个<code>remote “origin”</code>内容，这就是刚才添加的远程地址，也可以直接修改config来配置远程地址。如图：<br><img src="/images/github7.png" alt="paradin"></p><h2><span id="下载与上传">下载与上传</span></h2><p>由于这次是我们第一次上传，那么按照惯例，我们需要先下载一下，使用<code>git pull origin master --allow-unrelated-histories</code>，然后输入<code>id_rsa密钥</code>，看见chentest就多了那个<code>README.md</code>文件了。把这个<code>README.md</code>文件改成这样：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># chentest</span><br><span class="line">这是一个做测试的仓库，做好了之后，就先尝试把代码传上去，然后结合Jenkins来搞！</span><br></pre></td></tr></table></figure></p><p>同时也写一个新的代码，比如这个文件就叫<code>test1.md</code>，里面内容是：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#/bin/bash</span><br><span class="line">echo <span class="string">"hello,chrisChan!"</span></span><br><span class="line">echo <span class="string">"this is your first git"</span></span><br><span class="line">ifconfig</span><br></pre></td></tr></table></figure></p><p>这个shell脚本内容就是输出两个废话，然后打印ip地址。保存<code>test1.md</code>，然后在命令行里输入如下的内容：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add README.md</span><br><span class="line">git commit -m "提交注释"#这个注释内容是会在网站上体现出来的</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure></p><p><code>git push</code>命令会将本地仓库推送到远程服务器，而之前说过的<code>git pull</code>命令则相反。同样的输入<code>id_rsa密钥</code>，然后就会看到文件成功上传了！如图：<br><img src="/images/github8.png" alt="paradin"></p><p>来到github网站里一看，果然刚刚写的那个<code>test1.md</code>出现了，如图：<br><img src="/images/github9.png" alt="paradin"></p><h2><span id="结语">结语</span></h2><p>通过刚才的操作，我想各位应该对github操作有一点初步的了解。其实Git命令行是一个版本控制工具，Github是一个用Git做版本控制的项目托管平台。形象解释的话Git相当于是弓，GitHub是靶，你的代码是箭，弓把箭射到靶上。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://www.jianshu.com/p/0fce531dba31" target="_blank" rel="noopener">https://www.jianshu.com/p/0fce531dba31</a><br><a href="http://blog.csdn.net/zhangmingbao2016/article/details/73478899" target="_blank" rel="noopener">http://blog.csdn.net/zhangmingbao2016/article/details/73478899</a><br><a href="http://www.cnblogs.com/findingsea/archive/2012/08/27/2654549.html" target="_blank" rel="noopener">http://www.cnblogs.com/findingsea/archive/2012/08/27/2654549.html</a></p>]]></content>
    
    <summary type="html">
    
      学习了github就更像一个程序员了
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="github" scheme="http://yoursite.com/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins与Github组合成持续集合环境</title>
    <link href="http://yoursite.com/2018/02/05/Jenkins%E4%B8%8EGithub%E7%BB%84%E5%90%88%E6%88%90%E6%8C%81%E7%BB%AD%E9%9B%86%E5%90%88%E7%8E%AF%E5%A2%83/"/>
    <id>http://yoursite.com/2018/02/05/Jenkins与Github组合成持续集合环境/</id>
    <published>2018-02-05T09:12:22.000Z</published>
    <updated>2018-02-05T13:55:52.766Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="生成token码">生成Token码</span></h2><p>首先登录github，在首页选择<code>settings</code>，如图：<br><img src="/images/jenkins12.png" alt="paradin"></p><p>然后点击最下面的<code>Developer settings</code>，点击<code>Personal access tokens</code>，最后点击<code>Generate new token</code>，如图：<br><img src="/images/jenkins13.png" alt="paradin"></p><p>输入名称和权限，权限选择<code>repo</code>和<code>admin:repo_hook</code>这俩，如图：<br><img src="/images/jenkins14.png" alt="paradin"></p><p>然后就会生成一个<code>token密码</code>，这个<code>token密码</code>请妥善保存，丢失或者删除就GG了。<br><img src="/images/jenkins15.png" alt="paradin"></p><h2><span id="将token码配置到jenkins">将Token码配置到Jenkins</span></h2><p>浏览器返回到Jenkins界面，在首页里点击<code>系统管理</code>，然后选择<code>系统配置</code>，在系统配置里面添加一个<code>GitHub Servers</code>，在<code>Add Credentials</code>这一步的时候，要把<code>kind</code>改成<code>Secret text</code>，如图：<br><img src="/images/jenkins17.png" alt="paradin"></p><p>这里<code>Secret</code>的地方就是填写刚刚生成的Token码。</p><p>保存之后，点击一下<code>test connection</code>，如果出现<code>Credentials verified for user xxx, rate limit: xxx</code>的字样就是成功了，如图：<br><img src="/images/jenkins19.png" alt="paradin"></p><h2><span id="设置webhooks">设置webhooks</span></h2><p>在github里找一个源码库，选择<code>settings</code>，然后点击小菜单栏里的<code>Webhooks</code>，再点击右边的<code>Add Webhook</code>即可，如图：<br><img src="/images/jenkins16.png" alt="paradin"></p>]]></content>
    
    <summary type="html">
    
      这样就与Github紧密相连了
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Jenkins" scheme="http://yoursite.com/tags/Jenkins/"/>
    
      <category term="持续集成" scheme="http://yoursite.com/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins的安装与创建简单任务</title>
    <link href="http://yoursite.com/2018/02/05/Jenkins%E5%AE%89%E8%A3%85%E4%B8%8E%E5%88%9B%E5%BB%BA%E7%AE%80%E5%8D%95%E4%BB%BB%E5%8A%A1/"/>
    <id>http://yoursite.com/2018/02/05/Jenkins安装与创建简单任务/</id>
    <published>2018-02-05T03:23:04.000Z</published>
    <updated>2018-02-05T09:31:07.519Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="安装与启动">安装与启动</span></h2><p>环境：<code>CentOS 7.0</code> + <code>java 1.8</code></p><p>安装方式：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yum install yum-fastestmirror -y  #安装自动选择最快源的插件</span><br><span class="line">#添加Jenkins源:</span><br><span class="line">sudo wget -O /etc/yum.repos.d/jenkins.repo http:<span class="comment">//jenkins-ci.org/redhat/jenkins.repo</span></span><br><span class="line">sudo rpm --<span class="keyword">import</span> http:<span class="comment">//pkg.jenkins-ci.org/redhat/jenkins-ci.org.key</span></span><br><span class="line">yum install jenkins               #安装jenkins</span><br></pre></td></tr></table></figure></p><p>启动方式：<code>sudo service jenkins start</code>，如果没有java是无法启动的。</p><p>Jenkins默认端口是<code>8080</code>，如果要更改端口，需要先<code>vim /etc/sysconfig/jenkins</code>，然后修改<code>JENKINS_PORT=&quot;8080&quot;</code>为自己想要的端口号即可。</p><p>访问方式：浏览器输入<code>http://your server ip:8080/</code>，然后会看到这样的一个界面，打开这个文件，输入里面的key就可以访问jenkins了。<br><img src="/images/jenkins1.png" alt="paradin"></p><p>然后就是让你安装插件，如果是新手的话，可以安装系统推荐的插件，如果插件安装失败不要怕，可以日后手动补上。<br><img src="/images/jenkins2.png" alt="paradin"></p><p>插件安装完毕之后，就是自己创建一个管理员账号和密码，输入之后，点击右下角<code>保存并完成</code>。<br><img src="/images/jenkins3.png" alt="paradin"></p><p>然后就可以看到Jenkins初始化的首页。<br><img src="/images/jenkins4.png" alt="paradin"></p><h2><span id="创建任务">创建任务</span></h2><p>假设现在要创建一个Job(任务)，这个任务就是输出当前服务器的外网IP地址，那么就点击首页里的<code>新建任务</code>，然后输入任务名，补充一句，生产环境里的Job名最好不用中文，不做死就不会死，然后选择<code>构建一个自由风格的软件项目</code>，如图：<br><img src="/images/jenkins5.png" alt="paradin"></p><p>在<code>源码管理</code>的地方，我们暂时选择<code>None</code>，待日后把jenkins与github相关联之后，就可以通过github来配置源码了。在<code>构建触发器</code>的地方，我们选择<code>Poll SCM</code>，这里说一下这几个触发器选项的意思：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Build after other projects are built：</span><br><span class="line">Build periodically ： 周期进行项目构建（它不关心源码是否发生变化），可以配置如下：<span class="number">0</span> <span class="number">2</span> * * *（每天<span class="number">2</span>:<span class="number">00</span> 必须build一次源码）</span><br><span class="line">Build when a change is pushed to GitHub： 只要github上有提交了，jenkins没有自动检测到并构建，这设置之后在github中也需要设置才能生效</span><br><span class="line">Poll SCM：定时检查源码变更（根据SCM软件的版本号），如果有更新就checkout最新code下来，然后执行构建动作。可以配置如下：*<span class="regexp">/10 * * * *  （每5分钟检查一次源码变化）</span></span><br></pre></td></tr></table></figure></p><p><img src="/images/jenkins6.png" alt="paradin"></p><p><code>构建步骤</code>这里有很多的选项，我们选择<code>Execute Shell</code>，里面可以写shell命令也可以写shell脚本，这里我就写入一个很简单的ifconfig命令去查看一下IP地址，如图：<br><img src="/images/jenkins7.png" alt="paradin"></p><p><code>构建后操作</code>这里也有很多的选项，这里我选择<code>E-mail Notification</code>，然后输入自己的邮箱地址，这样如果构建失败了，就可以发邮件提醒。如图：<br><img src="/images/jenkins8.png" alt="paradin"></p><p>配置完毕之后，点击左下角<code>保存</code>即可。</p><h2><span id="查看任务效果">查看任务效果</span></h2><p>返回到Jenkins的首页，我们看到多了那个刚才新建的任务，然后点击任务名旁边的小三角，选择<code>立即构建</code>，如图：<br><img src="/images/jenkins9.png" alt="paradin"></p><p>然后就会看到构建的历史，点击任意历史记录的<code>控制台输出</code>，就会看到效果，的确是操作了<code>ifconfig</code>命令的效果：<br><img src="/images/jenkins10.png" alt="paradin"><br><img src="/images/jenkins11.png" alt="paradin"></p>]]></content>
    
    <summary type="html">
    
      为了自动化部署和持续集成
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Jenkins" scheme="http://yoursite.com/tags/Jenkins/"/>
    
      <category term="持续集成" scheme="http://yoursite.com/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper集群的搭建与配置</title>
    <link href="http://yoursite.com/2018/02/05/Zookeeper%E9%9B%86%E7%BE%A4%E7%9A%84%E6%90%AD%E5%BB%BA%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2018/02/05/Zookeeper集群的搭建与配置/</id>
    <published>2018-02-05T02:15:21.000Z</published>
    <updated>2018-02-05T02:59:42.207Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>Zookeeper的下载地址：<code>https://github.com/apache/zookeeper/archive/master.zip</code><br>zkclient的下载地址：<code>https://github.com/sgroschupf/zkclient</code></p><p>至于zookeeper的作用和原理我这里就不多赘述了，大家有兴趣可以去查查，这里主要就是动手操作。</p><h2><span id="搭建集群">搭建集群</span></h2><p>首先先看一下本次zk实验服务器的名称和IP情况，这里我们选择了三台服务器作zkserver，因为三台是标配，一台的话就只有leader没有follower，不是很稳定的结构，当然啦如果你的公司土豪的话是可以玩三十台：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dvl-mrszk<span class="number">-001</span><span class="number">10.117</span><span class="number">.0</span><span class="number">.125</span></span><br><span class="line">dvl-mrszk<span class="number">-002</span><span class="number">10.117</span><span class="number">.1</span><span class="number">.158</span></span><br><span class="line">dvl-mrszk<span class="number">-003</span><span class="number">10.168</span><span class="number">.152</span><span class="number">.227</span></span><br></pre></td></tr></table></figure></p><p>对这三台服务器都要进行如下的步骤:</p><p>1)先把zookeeper.zip传到linux里，然后解压到<code>/usr</code>文件夹下；</p><p>2)进入<code>/usr/zookeeper/conf</code>文件夹，<code>vim zoo.cfg</code>，在最下面补充上面的三个zkserver，见图：<br><img src="/images/zook1.png" alt="paradin"></p><p>3)再来到<code>/usr/zookeeper/data</code>文件夹，如果里面有文件就清空所有文件，如果是1号zkserver就<code>echo 1 &gt; myid</code>，如果当前机器是2号zkserver就<code>echo 2 &gt; myid</code>，依次类推，这里一定要注意，不可以都写一样。</p><p>4)<code>vim /etc/hosts</code>，还要把这三台机器的ip地址和名字都写进去，如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> localhost</span><br><span class="line">::<span class="number">1</span>         localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br><span class="line"><span class="number">10.117</span><span class="number">.0</span><span class="number">.125</span> dvl-mrszk<span class="number">-001</span></span><br><span class="line"><span class="number">10.117</span><span class="number">.1</span><span class="number">.158</span> dvl-mrszk<span class="number">-002</span></span><br><span class="line"><span class="number">10.168</span><span class="number">.152</span><span class="number">.227</span> dvl-mrszk<span class="number">-003</span></span><br></pre></td></tr></table></figure></p><p>5)再来<code>/usr/zookeeper/bin</code>文件夹，<code>./zkServer.sh start</code>启动zk，然后再<code>./zkServer.sh status</code>查看进程情况，如图看见第一台和第三台zkserver的身份是<code>follower</code>，第二台是<code>leader</code>：<br><img src="/images/zook2.png" alt="paradin"></p><p><img src="/images/zook3.png" alt="paradin"></p><p><img src="/images/zook4.png" alt="paradin"></p><p>至此整个zk集群就搭建并且启动完成了。</p><font color="red">注意：zookeeper集群时，zookeeper要求半数以上的机器可用，zookeeper才能提供服务。</font><p>如果这里有启动失败的情况，比如<code>Error contacting service. It is probably not running.</code>这样的字样，那么有这么几种可能：</p><p>1）data文件夹下的<code>myid</code>有数字重复或者是数字漏写的情况；</p><p>2）<code>zoo.cfg</code>里的指定日志文件夹没有手动创建；</p><p>3）<code>/etc/hosts</code>下的名字与zoo.cfg里的server字段不相符，注意一下，/etc/hosts里的127.0.0.1的名字不要与本ip后面的名字一模一样，不然zk也无法识别！</p><p>4）<code>/etc/hosts</code>名字使用了中文，java系对中文是很不友好的。</p><h2><span id="配置文件详解">配置文件详解</span></h2><p>1.<code>tickTime</code>：这个时间是作为 Zookeeper 服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个 tickTime 时间就会发送一个心跳。<br>2.<code>dataDir</code>：顾名思义就是 Zookeeper 保存数据的目录，默认情况下，Zookeeper 将写数据的日志文件也保存在这个目录里。<br>3.<code>clientPort</code>：这个端口就是客户端连接 Zookeeper 服务器的端口，Zookeeper 会监听这个端口，接受客户端的访问请求。<br>4.<code>initLimit</code>：这个配置项是用来配置 Zookeeper 接受 客户端（这里所说的客户端不是用户连接 Zookeeper 服务器的客户端，而是 Zookeeper 服务器集群中连接到 Leader 的 Follower 服务器）初始化连接时最长能忍受多少个心跳时间间隔数。当已经超过 5个心跳的时间（也就是 tickTime）长度后 Zookeeper 服务器还没有收到客户端的返回信息，那么表明这个客户端连接失败。总的时间长度就是 5<em>2000=10秒。<br>5.<code>syncLimit</code>：这个配置项标识 Leader 与 Follower 之间发送消息，请求和应答时间长度，最长不能超过多少个 tickTime 的时间长度，总的时间长度就是2</em>2000=4秒。<br>6.<code>server.A=B：C：D</code>：其中 A 是一个数字，表示这个是第几号服务器；B 是这个服务器的 ip 地址；C 表示的是这个服务器与集群中的 Leader 服务器交换信息的端口；D 表示的是万一集群中的 Leader 服务器挂了，需要一个端口来重新进行选举，选出一个新的 Leader，而这个端口就是用来执行选举时服务器相互通信的端口。如果是伪集群的配置方式，由于 B 都是一样，所以不同的 Zookeeper 实例通信端口号不能一样，所以要给它们分配不同的端口号。</p><h2><span id="验证成果">验证成果</span></h2><p>Zookeeper的配置工具叫<code>Zooinspector</code>，下载地址是：<code>https://issues.apache.org/jira/secure/attachment/12436620/ZooInspector.zip</code>，下载完直接解压缩就可以在windows里使用。</p><p>我们实验的这三台服务器只有内网，但是如果要连接zooinspector，还是需要通过外网权限连接的，这里可以配一个iptables转发规则，配iptables的步骤在这里：<a href="http://chenx1242.blog.51cto.com/10430133/1875950" target="_blank" rel="noopener">http://chenx1242.blog.51cto.com/10430133/1875950</a> ，照葫芦画瓢即可，但是要注意，zk的端口是<code>2181</code>。</p><p>当然，如果不想费事的话，就直接给zkserver配一个外网IP，直接连接。</p><p>成功连接到<code>zooinspector</code>，就会看到这样的内容，这里的lcconfig是手动添加的，右击鼠标，选择<code>add node</code>，然后直接写上<code>lcconfig</code>就行，这个名字是根据实际需要填写的：</p><p><img src="/images/zook5.png" alt="paradin"></p><p>上面我们已经配置了zkserver集群而且还启动zkserver进程，现在还需要zkclient，zkclient就是请求发起的一方，然后我们可以在各个的模块服务器上部署zkclient服务，通过启动zkclient服务，来让这些模块统一从zooinspector里取值，这样就达到了批量配置，同时保证一致性的效果。</p><p>zk的模板文件是<code>_tpl.properties</code>为结尾的文件，我这里模块的名字叫mrs，那么在实验里这个模板文件就是<code>mrs_tpl.properties</code>，这个<code>mrs_tpl.properties</code>里有这样的一个字段，如图：</p><p><img src="/images/zook6.png" alt="paradin"></p><p>而我们在zooinspector里对应就这么填写：</p><p><img src="/images/zook7.png" alt="paradin"></p><p>保存zooinspector，然后从windows返回到linux，启动zkclient服务和对应的模块进程，如果配置都正常的话，那么程序就会正常启动，<code>ps -ef|grep java</code>就会看到一个叫<code>lczk.AppServerDaemon</code>的进程。这个时候在去看一下mrs的配置文件：</p><p><img src="/images/zook8.png" alt="paradin"></p><p>可以看到areaAk取得值就是zk里面<code>data_center</code>里面<code>access_key</code>里面的ak的值，其他的几个值也是同理。可见整个zk已经配置成功，模块都进行了统一配置，而且这些配置既然能被一个接受，同时也会被其他相同的模块服务器所接受。这样就达到了批量配置的效果。</p><h2><span id="拓展阅读">拓展阅读</span></h2><p><a href="http://ibruce.info/2014/10/23/zookeeper/" target="_blank" rel="noopener">http://ibruce.info/2014/10/23/zookeeper/</a></p>]]></content>
    
    <summary type="html">
    
      纵然你的身子骨是铁打的，我想你也需要了解一款“实现同步服务，配置维护和命名服务”的东西吧。
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="运维技术" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4%E6%8A%80%E6%9C%AF/"/>
    
      <category term="zookeeper" scheme="http://yoursite.com/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>Uwsgi的安装和简单使用</title>
    <link href="http://yoursite.com/2018/02/02/Uwsgi%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/02/02/Uwsgi的安装和简单使用/</id>
    <published>2018-02-02T10:41:29.000Z</published>
    <updated>2018-02-02T10:50:19.673Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="正文">正文</span></h2><p>运维平台的搭建已经提上日程，而我选用了大家比较常用的<code>Uwsgi+nginx+django</code>的架构，这里先记录一下安装Uwsgi的过程。</p><p>这里解释一下<code>Uwsgi+nginx+django</code>，我们整个流程如下图：<br><img src="/images/uwsgi1.png" alt="paradin"></p><p>这里我们可以看出，web server是无法与我们的app（django等等）进行直接对话，他需要通过uwsgi这个桥梁，这个桥梁很重要，虽然我们使用django的<code>runserver</code>功能也会打开一个页面，但是这个页面是很脆弱的，小规模使用还好，要是放在网络上供很多人点击的话，根本就是脆不经风。</p><p>uwsgi是啥，请查看文末的参考资料，写的已经非常好了。我这里就简单说下：</p><blockquote><p>uwsgi 实际上也是一个http服务器，只不过它只面向python网络应用程序。虽然uwsgi也是http服务器，但是却不能直接使用它部署python web应用程序，否则会出错。</p><p>在本文中，uwsgi所扮演的的角色是后端http服务器，nginx扮演的角色是前端http服务器，<code>hello.py</code>是客户端应用程序。用户从网页浏览器中发出请求，nginx服务器收到请求后，会通过它的uwsgi模块将用户的请求转发给uwsgi服务器，uwsgi服务器处理完毕后将结果返回给 nginx，浏览器将最终的结果展现给用户。</p></blockquote><p>Uwsgi的安装比较简单，推荐使用<code>yum install Uwsgi</code>直接下载使用，而不推荐用<code>pip install uwsgi</code>，因为pip安装的话，虽然也能成功（如下图红框），是没有<code>uwsgi.ini</code>文件的，其实没有这个<code>uwsgi.ini</code>是无足轻重的，因为这个文件可以自己写，但是对于生手来说，没有这个文件可能会心里发毛，就无法按照攻略继续下去，所以我更推荐用yum安装，如图：<br><img src="/images/uwsgi2.png" alt="paradin"></p><p>为了纪念我们的金刚狼同志，我们就写一个叫<code>logan.py</code>，里面的内容是这样的：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def application(env, start_response):</span><br><span class="line">       start_response(<span class="string">'200 OK'</span>, [(<span class="string">'Content-Type'</span>,<span class="string">'text/html'</span>)])</span><br><span class="line">       <span class="keyword">return</span> <span class="string">"good bye,Logan..."</span></span><br></pre></td></tr></table></figure></p><p>然后我们就可以启动这个<code>uwsgi</code>看看效果，使用<code>uwsgi --http :8001 --wsgi-file logan.py</code>，把端口设定为<code>8001</code>，同时指定协议是<code>http</code>，然后加载的文件就是<code>logan.py</code>，启动之后，如图：<br><img src="/images/uwsgi3.png" alt="paradin"></p><p>遇到这种情况，你就<code>yum install uwsgi-plugin-python</code>，然后把命令做一点点修改，改成：<code>uwsgi --plugin python --http-socket :8001 --wsgi-file logan.py</code>。</p><p>屏幕会出现一大堆文字，然后提示，uwsgi已经启动成功了。在浏览器输入<code>服务器外网地址:8001</code>看一下效果，如图：<br><img src="/images/uwsgi4.png" alt="paradin"></p><p>我们在root目录下再写一个测试的文件，这次我们写一个比较老实的python脚本来测试，这个脚本就叫<code>test.py</code>，里面的内容如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/python</span></span><br><span class="line">#coding=utf-8</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">def application(environ, start_response):</span><br><span class="line">       status = <span class="string">'200'</span></span><br><span class="line">       output = <span class="string">'this is a test for uwsgi,HOHO~'</span></span><br><span class="line">       response_headers = [(<span class="string">'Content-type'</span>, <span class="string">'text/plain'</span>),(<span class="string">'Content-Length'</span>, str(len(output)))]</span><br><span class="line">       start_response(status, response_headers)</span><br><span class="line">       <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure></p><p>还是用刚才的方法，依旧可以打开网页，其实上面这个简单的<code>uWSGI</code>程序更好理解整个套路，只需要实现一个名为<code>application</code>的函数就可以了，该函数有两个参数，<code>environ</code>为包含有<code>http</code>请求的环境变量，<code>start_response</code>为一个函数，用来设置http头。在这个函数里，我们只需要调用一次<code>start_response</code>函数，设置一下<code>HTTP</code>返回头，再<code>return</code>一个<code>HTTP body</code>即可。</p><p>至此，整个uwsgi就安装成功了。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="http://xiaorui.cc/2017/02/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3uwsgi%E5%92%8Cgunicorn%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E4%B8%8A/" target="_blank" rel="noopener">http://xiaorui.cc/2017/02/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3uwsgi%E5%92%8Cgunicorn%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E4%B8%8A/</a><br><a href="http://uwsgi-docs.readthedocs.io/en/latest/tutorials/Django_and_nginx.html" target="_blank" rel="noopener">http://uwsgi-docs.readthedocs.io/en/latest/tutorials/Django_and_nginx.html</a></p>]]></content>
    
    <summary type="html">
    
      Uwsgi+nginx+django，光搭建一个框架就要了我的老命...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="django" scheme="http://yoursite.com/tags/django/"/>
    
      <category term="uwsgi" scheme="http://yoursite.com/tags/uwsgi/"/>
    
  </entry>
  
</feed>
