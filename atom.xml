<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chris Chan&#39;s BLOG</title>
  
  <subtitle>那些在阳光下挥洒青春的日子啊！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-11T14:27:24.311Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Chris Chan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于HTTP-Alive应该知道的事</title>
    <link href="http://yoursite.com/2018/03/11/%E5%85%B3%E4%BA%8EHTTP-Alive%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8B/"/>
    <id>http://yoursite.com/2018/03/11/关于HTTP-Alive应该知道的事/</id>
    <published>2018-03-11T03:23:08.000Z</published>
    <updated>2018-03-11T14:27:24.311Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="总体概述">总体概述</span></h2><p>七层协议是一个广为人知的协议，<code>tcp</code>协议是在传输层，<code>http</code>协议是在应用层，也就是说客户端与服务器端先建立<code>tcp</code>连接，然后在<code>tcp</code>连接的基础上传送<code>http</code>报文。</p><p><code>http</code>协议是一个<code>请求-应答</code>的模式，也就是当没有启动<code>keep-alive</code>的时候，每一次建立<code>http</code>连接都是<code>现用现建立，用完就断开</code>的工作样式。而如果开启了<code>keep-alive</code>模式的话，客户端和服务器之间<code>http</code>连接就会被保持，不会断开（超过<code>Keep-Alive</code>规定的时间，意外断电等情况除外），当客户端发送另外一个请求时，就使用这条已经建立的连接。</p><p><code>Keep-Alive</code>的规定时间在客户端（浏览器里）是如何确定的呢？例如<code>Keep-Alive: timeout=5, max=100</code>，表示这个<code>TCP</code>通道可以保持5秒，<code>max=100</code>表示这个长连接最多接收100次请求就断开。</p><p><code>Keep-alive</code>在<code>http 1.1</code>版本里是默认开启的，只有加入<code>Connection: close</code>才会关闭，现在大部分浏览器都是使用<code>http 1.1</code>协议，所以说在客户端已经是默认发起<code>keep-alive</code>的连接请求。但是能否会完成一个完整的<code>keep-alive</code>还要看服务器端的具体配置情况。</p><p>在<code>nginx</code>里就直接支持<code>keepalive_timeout</code>指令，其使用0值来停用<code>keep-alive</code>，举例配置如下:<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">location /XXX/ &#123;   </span><br><span class="line">    alias /url/<span class="keyword">var</span>/www/html/;   </span><br><span class="line">    keepalive_timeout  75;  #这个值跟浏览器的timeout取最小值是超时值</span><br><span class="line">    expires <span class="number">5</span>m;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">使用长连接之后，客户端、服务端怎么知道本次传输结束呢？两部分：1. 判断传输数据是否达到了`</span>Content-Length<span class="string">`指示的大小，这个是最简单的最傻瓜的，普遍应用于静态的图片或者页面；2. 往往动态生成的文件没有`</span>Content-Length<span class="string">`，它是分块传输`</span>（chunked）<span class="string">`，这时候怎么办呢？就要根据`</span>chunked<span class="string">`编码来判断，`</span>chunked<span class="string">`编码的数据在最后有一个空`</span>chunked<span class="string">`块，表明本次传输数据结束，这种情况更多应用于动态的页面。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 进一步的说chunked ##</span></span><br><span class="line"><span class="string">HTTP请求报文的格式是这样的：</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line">&lt;method&gt; &lt;request-URL&gt; &lt;version&gt;#状态行</span><br><span class="line">&lt;headers&gt;#请求头</span><br><span class="line"></span><br><span class="line">&lt;entity-body&gt;#消息主体</span><br></pre></td></tr></table></figure></p><p>其中在请求头的地方有一个叫<code>Content-Length</code>的字段，如果没有这个字段那么就会有叫<code>Transfer-encoding</code>的字段，它用来表示<code>http</code>报文的传输格式，这个字段的取值有很多，但是真正有意义的只有一个—<code>chunked</code>。</p><p>如果一个<code>HTTP</code>消息（请求消息或应答消息）的<code>Transfer-Encoding</code>消息头的值为<code>chunked</code>，那么，消息体由数量未定的块组成，并以最后一个大小为0的块为结束。</p><p>每一个非空的块都以该块包含数据的字节数（字节数以十六进制表示）开始，跟随一个<code>CRLF</code>（回车及换行），然后是数据本身，最后块<code>CRLF</code>结束。在一些实现中，块大小和<code>CRLF</code>之间填充有白空格（0x20）。</p><p>最后一块是单行，由块大小（0）、一些可选的填充白空格、以及<code>CRLF</code>组成。最后一块不再包含任何数据，但是可以发送可选的尾部，包括消息头字段。消息最后以<code>CRLF</code>结尾。</p><p>注意1.<code>chunked</code>和<code>multipart</code>两个名词在意义上有类似的地方，不过在<code>HTTP</code>协议当中这两个概念则不是一个类别的。<code>multipart</code>是一种<code>Content-Type</code>，标示<code>HTTP</code>报文内容的类型，而<code>chunked</code>是一种传输格式，标示报头将以何种方式进行传输；</p><p>注意2.<code>chunked</code>传输不能事先知道内容的长度，只能靠最后的空<code>chunk</code>块来判断，因此对于下载请求来说，是没有办法实现进度的。在浏览器和下载工具中，偶尔我们也会看到有些文件是看不到下载进度的，即采用<code>chunked</code>方式进行下载；</p><p>注意3.<code>chunked</code>的优势在于，服务器端可以边生成内容边发送，无需事先生成全部的内容。<code>HTTP/2</code>不支持<code>Transfer-Encoding: chunked</code>，因为<code>HTTP/2</code>有自己的<code>streaming</code>传输方式；</p><h2><span id="http-keep-alive与tcp-keep-alive">http keep-alive与tcp keep-alive</span></h2><p>http的<code>keep-alive</code>与tcp的<code>keep-alive</code>可不是同一回事，意图也不一样。http的<code>keep-alive</code>是为了让tcp活得更久一点，以便在同一个连接上传送多个http，提高<code>socket</code>的效率。而tcp的<code>keep-alive</code>是tcp的一种检测tcp连接状况的保鲜机制。tcp的<code>keep-alive</code>是一个保鲜定时器，支持三个系统内核配置参数：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="number">1800</span> &gt; <span class="regexp">/proc/</span>sys/net/ipv4/tcp_keepalive_time</span><br><span class="line">echo <span class="number">15</span> &gt; <span class="regexp">/proc/</span>sys/net/ipv4/tcp_keepalive_intvl</span><br><span class="line">echo <span class="number">5</span> &gt; <span class="regexp">/proc/</span>sys/net/ipv4/tcp_keepalive_probes</span><br></pre></td></tr></table></figure></p><p><code>keepalive</code>是TCP保鲜定时器，当网络两端建立了tcp连接之后，闲置idle（双方没有任何数据流发送往来）了<code>tcp_keepalive_time</code>后，服务器内核就会尝试向客户端发送侦测包，来判断TCP连接状况(有可能客户端崩溃、强制关闭了应用、主机不可达等等)。如果没有收到对方的回答(ack包)，则会在<code>tcp_keepalive_intvl</code>后再次尝试发送侦测包，直到收到对对方的<code>ack</code>,如果一直没有收到对方的<code>ack</code>,一共会尝试<code>tcp_keepalive_probes</code>次，每次的间隔时间在这里分别是<code>15s、30s、45s、60s、75s</code>。如果尝试<code>tcp_keepalive_probe</code>s,依然没有收到对方的ack包，则会丢弃该TCP连接。TCP连接默认闲置时间是2小时，一般设置为30分钟足够了。</p><p>也就是说，仅当<code>nginx</code>的<code>keepalive_timeout</code>值设置高于<code>tcp_keepalive_time</code>，并且距此tcp连接传输的最后一个<code>http</code>响应，经过了<code>tcp_keepalive_time</code>时间之后，操作系统才会发送侦测包来决定是否要丢弃这个TCP连接。一般不会出现这种情况，除非你需要这样做。</p><h2><span id="keep-alive与time_wait">keep-alive与TIME_WAIT</span></h2><p>使用http的<code>keep-alive</code>，可以减少服务端<code>TIME_WAIT</code>数量(因为由服务端<code>httpd</code>守护进程主动关闭连接)。道理很简单，相较而言，启用<code>keep-alive</code>，建立的<code>tcp</code>连接更少了，自然要被关闭的<code>tcp</code>连接也相应更少了。</p><h2><span id="补充">补充</span></h2><p>建议在服务器提供Web站点服务时(一个页面除了动态内容，还包含非常多的JS、图片、css文件等)开启keep-alive。在“服务器提供的是一个接口服务，除了动态内容，几乎没有引用任何静态内容”这样的场景，不建议开启<code>keep-alive</code>。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="http://www.cnblogs.com/skynet/archive/2010/12/11/1903347.html" target="_blank" rel="noopener">http://www.cnblogs.com/skynet/archive/2010/12/11/1903347.html</a><br><a href="https://hit-alibaba.github.io/interview/basic/network/HTTP.html" target="_blank" rel="noopener">https://hit-alibaba.github.io/interview/basic/network/HTTP.html</a><br><a href="http://51write.github.io/2014/04/09/keepalive/" target="_blank" rel="noopener">http://51write.github.io/2014/04/09/keepalive/</a><br><a href="http://www.nowamagic.net/academy/detail/23350305" target="_blank" rel="noopener">http://www.nowamagic.net/academy/detail/23350305</a></p>]]></content>
    
    <summary type="html">
    
      HTTP是一个无状态协议，这意味着每个请求都是独立的，Keep-Alive 没能改变这个结果。
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="大牛之路" scheme="http://yoursite.com/tags/%E5%A4%A7%E7%89%9B%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="http协议" scheme="http://yoursite.com/tags/http%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>ssh连接port22:Socket error Event:32 Error:10053</title>
    <link href="http://yoursite.com/2018/03/07/ssh%E8%BF%9E%E6%8E%A5port22-Socket-error-Event-32-Error-10053/"/>
    <id>http://yoursite.com/2018/03/07/ssh连接port22-Socket-error-Event-32-Error-10053/</id>
    <published>2018-03-07T10:51:31.000Z</published>
    <updated>2018-03-07T11:41:48.711Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>今天遇到了一个奇怪的现象，据开发人员反馈，有一台阿里云服务器在控制台重启了之后，发现无法登陆了。我先使用阿里云的控制台打算远程登陆到这台机器发现，远程登陆总是显示密码错误。然后我使用xshell登陆对应的外网IP和22端口的时候发现爆出如下的错误：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Connecting to X.X.X.X:<span class="number">22.</span>..</span><br><span class="line">Connection established.</span><br><span class="line">To <span class="built_in">escape</span> to local shell, press <span class="string">'Ctrl+Alt+]'</span>.</span><br><span class="line"></span><br><span class="line">Socket error Event: <span class="number">32</span> <span class="built_in">Error</span>: <span class="number">10053.</span></span><br><span class="line">Connection closing...Socket close.</span><br><span class="line"></span><br><span class="line">Connection closed by foreign host.</span><br></pre></td></tr></table></figure></p><p>这种情况很罕见，google了一下也没有对于我有用的处理办法，于是我就只好给阿里云后台发了一下工单。授权给阿里云让他们登陆一下这台机器看一下里面发生了什么，阿里云的售后人员过了一会打过电话过来说，发现这台机器里面有人操作了<code>chmod -R 777 /</code>，破坏了比如<code>/etc/passwd</code>和<code>/etc/shadow</code>的权限，所以会爆出这样的错误。如图：<br><img src="/images/7771.png" alt="paradin"></p><p>阿里的售后说他们也把几个跟登陆有关的文件暂时恢复权限，这样这个机器就可以成功登陆了，如图：<br><img src="/images/7772.png" alt="paradin"></p>]]></content>
    
    <summary type="html">
    
      刚上的堡垒机，有点磨合是肯定的...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="ssh" scheme="http://yoursite.com/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>孤儿进程和僵尸进程</title>
    <link href="http://yoursite.com/2018/03/07/%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/03/07/孤儿进程和僵尸进程/</id>
    <published>2018-03-07T08:07:35.000Z</published>
    <updated>2018-03-08T14:55:08.182Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="原理与定义">原理与定义</span></h2><p>首先要知道，<code>linux</code>有父进程和子进程这样的说法。那父进程如何创建子进程呢？<code>fork</code>。</p><p>子进程的进行和父进程的进行是异步的，但是父进程就像父母一样对自己的小孩也有一定的控制欲，这个控制欲就表现在如果子进程如果结束了，它释放了之前占用的资源、内存、文件等等，但是它还保留了一点信息：进程号PID、退出状态、运行时间等等。而这些残留信息是父进程通过<code>wait/waitpid</code>来获取，如果父进程一直不获取，那么子进程就会一直保留这些信息直到海枯石烂。</p><p><strong>孤儿进程</strong>：父进程退出，子进程继续进行，那么此时子进程就是孤儿进程。这个时候<code>init</code>进程（进程号为1）来作为子进程的监护人，发出<code>wait/waitpid</code>来完成状态收集工作；<br><img src="/images/jiangshi.png" alt="paradin" title="这个nginx的worker process就成了孤儿进程"></p><p><strong>僵尸进程</strong>：父进程没有退出，但是它迟迟不发出<code>wait/waitpid</code>来回收子进程的资源。就好比儿子死了，当爹的不给收尸，这个儿子就成了孤魂野鬼成了僵尸。</p><h2><span id="影响与危害">影响与危害</span></h2><p>孤儿进程是没有什么大的危害，虽然他虽然没有了亲生父亲，但是也有<code>init</code>进程来通过循环的<code>wait()</code>来处理它的善后工作，所以迟早会把占用的资源释放掉。</p><p>甚至有的用户可以把进程弄成孤儿进程，以使之与用户会话脱钩，并转至后台运行。这一做法常应用于启动需要长时间运行的进程，也即守护进程。另外，<code>nohup</code>命令也可以完成这一操作。</p><p>但是僵尸进程不一样，要是父进程对子进程一直不使用<code>wait/waitpid</code>，那么<code>pid</code>就会不回收，可是系统内的pid总是是有限的，这样久而久之就是对pid的一个霸占，新的进程也无法生成，这就是僵尸进程的危害。</p><h2><span id="如何处理僵尸进程">如何处理僵尸进程</span></h2><p>僵尸进程是杀不死的，怎么办？杀他爹，把父进程杀掉了，那么这些僵尸就成了孤儿进程，然后再由init收养，最后入土为安。</p><p>查看当前服务器僵尸进程的方法：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -A -o stat,ppid,pid,cmd | grep -e <span class="string">'^[Zz]'</span></span><br></pre></td></tr></table></figure></p><p>如果服务器上的僵尸进程不是出自一个父进程之手，那么就用下面这个命令批量解决：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -A -o stat,ppid,pid,cmd | grep -e <span class="string">'^[Zz]'</span> | awk <span class="string">'&#123;print $2&#125;'</span> | xargs kill <span class="number">-9</span></span><br></pre></td></tr></table></figure></p><p>但是如果父进程是init进程，那么这样的僵尸进程怎么办？答案，不用刻意管他，相信<code>init</code>的能力，它迟早会被<code>init</code>回收的，成为僵尸进程也是暂时的。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://zh.wikipedia.org/wiki/%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B</a><br><a href="https://zh.wikipedia.org/wiki/%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B</a><br><a href="http://blog.csdn.net/YuZhiHui_No1/article/details/53011390" target="_blank" rel="noopener">http://blog.csdn.net/YuZhiHui_No1/article/details/53011390</a><br><img src="/images/perfume.jpg" alt="paradin"></p>]]></content>
    
    <summary type="html">
    
      面试的时候，我在回答“僵尸进程和孤儿进程”的时候回答的很不好，于是下午就赶紧拿出来这块的资料来看，认真总结一下。
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>蚂蚁金服运维面试全纪录</title>
    <link href="http://yoursite.com/2018/03/07/%E8%9A%82%E8%9A%81%E9%87%91%E6%9C%8D%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E5%85%A8%E7%BA%AA%E5%BD%95/"/>
    <id>http://yoursite.com/2018/03/07/蚂蚁金服运维面试全纪录/</id>
    <published>2018-03-07T03:33:01.000Z</published>
    <updated>2018-03-07T11:27:12.721Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>早上接到蚂蚁金服的运维面试电话，有点突然袭击，下面是整个的面试记录。</p><p>首先，面试官先向我讲述了一下他们平时运维的工作内容，然后结合我的简历开始提问。</p><p>1）都用过我们的什么产品？<br>这一阶段老老实实、正常回答工作中所用到的阿里云产品和使用情景。</p><p>2）VPC网络有哪些好处？<br>我就答出来更加安全…面试官说其他方面呢，我就不知道了。<br>【事后补充】VPC网路的灵活性更高，可以自由定义网段划分、IP地址和路由网络。</p><p>3)一个vpc的服务器如何与外网交互？<br>我说可以改写路由或者通过<code>iptables</code>转发。</p><p>4）iptables里PREROUTING和POSTROUTING都是啥？<br><code>PREROUTING</code>处理刚到达本机并在路由转发前的数据包；<code>POSTROUTING</code>处理即将离开本机的数据包。</p><p>5）问：RDS在什么操作下会CPU飙升，任举一例？<br>答：在我实际工作中，比较明显的是在数据同步的时候会飙升。</p><p>6）RDS为什么会在DTS的时候有飙升的现象？<br>这个我答的不好，有点东拉西扯…（尴尬）</p><p>7）mysql备份的时候使用过什么参数？<br>答：<code>--skip-opt</code> 防止运行中的MYSQL锁库<br>加速数据备份的参数是什么？<br><code>-q</code> 提高导出性能<br><code>-e</code> 提高导入性能，使用包括几个<code>VALUES</code>列表的多行<code>INSERT</code>语法；<br><code>--max_allowed_packet=XXX</code> 客户端/服务器之间通信的缓存区的最大大小；<br><code>--net_buffer_length=XXX</code> TCP/IP和套接字通信缓冲区大小，创建长度达到<code>net_buffer_length</code>的行；</p><p>注意！<code>max_allowed_packet</code>和<code>net_buffer_length</code>在mysql里有参数值，不能超过参数值！<br>查看方法：<code>show variables like &#39;max_allowed_packet&#39;;</code></p><p>8）cache和buffer有什么区别？<br><code>cache</code>是缓存，弥补高速设备与低速设备的鸿沟引入的中间层，达到数据快取的目的；<br><code>buffer</code>是缓冲区，用户流量整形，把大量的小的io整理一个平稳的大io，减少磁盘响应次数；</p><p>9）他俩的调用有什么区别？<br>我问是要说“块读取”什么的么，面试官说是。我就蒙说cache是块读取，buffer我不清楚…（尴尬 again）<br>【事后补充】</p><p>10）谈一谈time_wait和close_wait，各自在什么情况下出现？<br><code>time_wait</code>和<code>close_wai</code>t都是出现在“四次挥手”的环节里，<code>time_wait</code>是服务器接收到客户端发来的断开TCP连接的请求，并且服务器发送确认断开的包给客户端，此时服务器处于<code>time_wait</code>状态，如果服务器等待两个<code>msl</code>的话，就会默认断开连接，如果想修改<code>msl</code>可以通过修改<code>/etc/systl.conf</code>文件；<br><code>close_wait</code>是客户端已经发送了断开TCP请求，但是服务器端没有接收到，也就是<code>time_wait</code>的上一步，此时这个资源就一直被程序霸占。</p><p>11）为什么time_wait需要等待两个msl?1.99行不行？2.01行不行？<br>我当时说防止上一次连接中的包，迷路后重新出现，影响新连接。面试官好像觉得不是很满意…（尴尬 again）<br>【事后补充】</p><p>12）说出一个你使用过的python库。<br>我说我前两天用<code>matpoltlib</code>画图，就谈了谈这个画图的库。</p><p>13）python装饰器了解么？<br>没什么深入的了解，就没敢答，怕被问死。</p><p>14）僵尸进程和孤儿进程，了解么？<br>马蛋，这个让我给说反了…(闹心啊啊啊啊啊啊啊)<br>【事后补充】孤儿进程：父进程退出，而它的一个或者多个子进程还在运行，这些子进程就叫孤儿进程，孤儿进程被init进程收养，由init进程对它们完成状态收集工作；<br>僵尸进程：一个进程用fork创建了子进程，然后这个子进程退出了，而父进程并没有调用wait或者waitpid去获取子进程的状态信息，那么这个子进程的进程描述符还在系统中，这种进程叫僵尸进程；</p><p>孤儿进程不怕，由于孤儿虽然没有父母，但是有民政局（init进程）收养，孤儿进程退出后也有init做一切善后工作；而僵尸进程会一直霸占其PID号，但是系统总共的PID是有限的，这样就会让可用的PID越来越少，所以僵尸进程是要避免的。</p>]]></content>
    
    <summary type="html">
    
      呼~~不晓得会不会有下一轮...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="大牛之路" scheme="http://yoursite.com/tags/%E5%A4%A7%E7%89%9B%E4%B9%8B%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper的选举原理</title>
    <link href="http://yoursite.com/2018/03/05/Zookeeper%E7%9A%84%E9%80%89%E4%B8%BE%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2018/03/05/Zookeeper的选举原理/</id>
    <published>2018-03-05T13:30:10.000Z</published>
    <updated>2018-03-05T16:38:51.584Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="前言">前言</span></h2><p><code>Zookeeper</code>是一款比较常见的式应用程序协调服务软件，如果配置了多台<code>zookeeper</code>自然要选择一个头头，这个头头就是<code>leader</code>，很明显不能所有的<code>zookeeper</code>都是<code>leader</code>，那样就失控了；也不能所有的<code>zookeeper</code>都是<code>follower</code>，那就群龙无首无法协调。</p><p>插播一句，这种<code>一老大N跟班</code>的模式是过去分布式软件里很常见的工作模式，而最近比较火热的区块链不同，它是一种<code>去中心化</code>的工作模式，大家人人都当节点，然后放在一起整合，有点原始社会的意思。所以说，算法有时候来自于人类学，也会在一定程度反过来上影响人类。</p><p>选举<code>leader</code>的方式是一种叫<code>FastLeaderELection</code>的算法，以<code>3.4.6</code>版本为例，它被保存在<code>/usr/zookeeper/src/java/main/org/apache/zookeeper/server/quorum/</code>这个文件夹下。</p><h2><span id="选举的中心思想">选举的中心思想</span></h2><p>实际上<code>FastLeaderELection</code>说的中心思想无外乎以下几个关键点：</p><ol><li><p>全天下我最牛！在我没有发现比我牛的推荐人的情况下，我就一直推举我当<code>leader</code>，第一次投票那必须推举我自己当<code>leader</code>。</p></li><li><p>每当我接收到其它的被推举者，我都要回馈一个信息，表明我还是不是推举我自己。如果被推举者没我大，我就一直推举我当<code>leader</code>，是我是我还是我！</p></li><li><p>我有一个票箱， 和我属于同一轮的投票情况都在这个票箱里面。一人一票重复的或者过期的票，我都不接受。</p></li><li><p>一旦我不再推举我自己了（这时我发现别人推举的人比我推荐的更牛），我就把我的票箱清空，重新发起一轮投票（这时我的票箱一定有两票了，都是选的我认为最牛的人）。</p></li><li><p>一旦我发现收到的推举信息中投票轮要高于我的投票轮，我也要清空我的票箱。并且还是投当初我觉得最牛的那个人（除非当前的人比我最初的推荐牛，我就顺带更新我的推荐）。</p></li><li><p>不断的重复上面的过程，不断的告诉别人“我的投票是第几轮”、“我推举的人是谁”。直到我的票箱中“我推举的最牛的人”收到了不少于<code>N/2 + 1</code>的推举投票。这也回答了为什么<code>zookeeper</code>在少于<code>N/2 + 1</code>的节点处于工作状态的情况下会崩溃了。因为，无论怎么选也没有任何节点能够获得<code>N/2 + 1</code>的票数。</p></li><li><p>这时我就可以决定我是<code>flower</code>还是<code>leader</code>了（如果至始至终都是我最牛，那我就是<code>leader</code>咯，其它情况就是<code>follower</code>咯）。并且不论随后收到谁的投票，都向它直接反馈“我的结果”。</p></li></ol><h2><span id="判断依据">判断依据</span></h2><p>上面第二步里说了，如果接收到其他被推举者的消息，而且判断出这个被推举者比我牛，我就要推举他，那么判断依据是啥呢？答案是依次比较<code>epoch</code>、<code>zxid</code>、<code>serverid</code>。</p><p>先说说啥是<code>epoch</code>、<code>zxid</code>、<code>serverid</code>：</p><ul><li><code>epoch</code>: 表示选举轮数。</li><li><code>zxid</code>: 事务zxid包含了本地数据的最后更新时间相关的信息。</li><li><code>serverid</code>: 当前<code>server</code>的 ID, 通过配置文件指定(<code>echo &#39;1&#39; &gt; myid</code>)。</li></ul><p>具体的判断过程是：接收到的消息中，有<code>epoch</code>比我大的，则选<code>epoch</code>大的消息中确定的<code>server</code>；如果<code>epoch</code>相等，则选<code>zxid</code>最大的<code>server</code>；如果<code>zxid</code>也相等，则选<code>serverid</code>最大的<code>server</code>(有的节点生来就是当<code>leader</code>的）。</p><p>为什么要有<code>epoch</code>呢？这样是为了防止中途有选举者掉线，他们错过了选举，再次连上来的时候，他们发现自己的投票轮已经小于现有的投票轮了，那么他们比如要清空自己的投票箱然后无条件的改为推荐接收到的最新选举中大家推荐的最牛的那个人（如果没有人比我牛，那还是推荐我自己）。由于有最后一条<code>serverid</code>大的最后压阵，而且<code>serverid</code>又不能重复，所以基本上都能最后选出一台作为<code>leader</code>。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="http://blog.csdn.net/yinwenjie/article/details/47613309" target="_blank" rel="noopener">http://blog.csdn.net/yinwenjie/article/details/47613309</a><br><a href="https://mozillazg.com/2017/03/zookeeper-fastleader-elect-leader.html" target="_blank" rel="noopener">https://mozillazg.com/2017/03/zookeeper-fastleader-elect-leader.html</a></p><p><img src="/images/messifreekick.gif" alt="paradin" title="八倍镜狙击模式开启"></p>]]></content>
    
    <summary type="html">
    
      zookeeper的选举是没有“仲裁者”的，就是看投票
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="运维技术" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4%E6%8A%80%E6%9C%AF/"/>
    
      <category term="zookeeper" scheme="http://yoursite.com/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>从韩国民主电影三部曲浅谈我对民主的认识</title>
    <link href="http://yoursite.com/2018/03/04/%E9%9F%A9%E5%9B%BD%E6%B0%91%E4%B8%BB%E7%94%B5%E5%BD%B1%E4%B8%89%E9%83%A8%E6%9B%B2/"/>
    <id>http://yoursite.com/2018/03/04/韩国民主电影三部曲/</id>
    <published>2018-03-04T13:07:08.000Z</published>
    <updated>2018-03-04T15:51:39.772Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>这个周末周五晚上看了《出租车司机》，周六下午看了《1987：黎明到来的那一天》，再加上之前就在B站看过又被下架的《辩护人》，韩国民主运动三部曲都看完了。</p><p>韩国民主运动电影还有一部叫《华丽的假期》，这个片子是2007年公映的，也是讲光州事件，但是这部片从电影角度上不如上面这三者，所以影响力和传播程度相对有限。</p><p>一直以来我对韩国的政治采取一种“黑”的态度，因为他们的总统基本没有好下场，哪怕是我个人比较喜欢的卢武铉总统也是以自杀结束了自己的一生，而且他们的演艺圈和体育圈也是以各种“黑”和“潜规则”出名。但是我不得不佩服韩国正直电影人的精神以及韩国正直记者们的精神，他们坚持了自己的操守而且履行了自己的职责，用骨气和勇气记录了他们能接触到的真相并且在日后拍成电影反思历史。</p><p>论民主化运动，韩国可以说是亚洲里第一档的存在，大型示威的次数加起来比越南、缅甸、柬埔寨加起来还要多，远超于同样是发达国家的日本。韩国民主化运动主要集中在1980-1987年全斗焕执政那一段时间，那时韩国人民虽然经历了初期经济水平腾飞的甜蜜，但是对后期经济调控不力和政府打压言论表示不满和愤怒。暴动的人民反抗意识比较强，不仅有大规模游行，甚至有这几部电影里没有提到的抢劫军火库的行为。而这些抢劫军火的行为日后也成了全斗焕在法庭上力图脱罪的一个辩控点。</p><p>这几部电影虽然被部分人影评“有明显的韩国特色，会导致审美疲劳”，但是并不耽误它们一次又一次的刷新票房记录，可见参与政治追求民主和公平其实是公民的一种本能。但是说实话，截止至今，光州事件虽然被平反但是没有得到彻底的清算。新闻说现任韩国总统文在寅先后观看了《出租车司机》和《1987：黎明到来的那一天》，会不会重审当年的光州罪犯，我们拭目以待。</p><p>民主可能本身不是一个效率很高的政治制度，因为它要坚持“少数服从多数”的原则，在具体条款颁布和施行的时候，由于不同人看待事物的水平和深度有高有低，以及侧重面的不同，那么肯定会有一些不一样的声音。而独裁的“一言堂”则相对效率很快，从历史来看，独裁政府甚至有战争上打败民主政府的先例，而且独裁政府挑头并且通过集权形式搞经济的话，在国家原有经济非常落后的前提下，的确可以快速进步，但是这种进步并不是那种“可持续发展”式的，而且中后期会由于民众监督不力，导致政府腐败的先例数不胜数。所以说集权就是一个春药，服用肯定会上瘾，但是也只会用暂时的爽换来将来的无穷尽的苦。独裁无论是理论还是事实都已经被当今社会唾弃，只有民主化才是迟早的选择，因为它至少可以守得住下限。</p><p>而且我个人认为，民主是一个持续的过程而不是一个简单的结果。绝对意义上的民主和拖沓低效的民主只会害了广大的底层百姓，极力避免的同时，也要最小程度的限制人滥用民主，这些就需要政府工作的透明化和规范化。</p><p>不过韩国的民主也有它的独特性，主要就是它有特殊的外界因素—-既不能得罪美国人，又不能惹毛了朝鲜（这一点跟台湾很像），所以无论是强权政府还是抗议民众都没有把事情搞得太过火。其次还有韩国中产阶级在抗议中也扮演了“理性和保守的一面”：他们是经济发展的受益者，对秩序有相当的敏感性，一旦社会民主斗争极端化，中产阶级便会退出民主运动，这是其保守性的表现。除此之外，还有比如基督教的传播代替了原有的儒家思想更追求自由等等因素，我这里水平有限，就不展开了。</p><p>最后补充一句，各位都知道《辩护人》里宋康昊的原型是卢武铉总统，据说片里宋康昊parter的原型就是韩国现在的总统—文在寅。</p><p><img src="/images/koreaD.png" alt="paradin"></p>]]></content>
    
    <summary type="html">
    
      我们生而为人，对自由与光明的向往，都如出一辙。
    
    </summary>
    
      <category term="坠乱花天" scheme="http://yoursite.com/categories/%E5%9D%A0%E4%B9%B1%E8%8A%B1%E5%A4%A9/"/>
    
    
      <category term="政治" scheme="http://yoursite.com/tags/%E6%94%BF%E6%B2%BB/"/>
    
      <category term="亚洲民主" scheme="http://yoursite.com/tags/%E4%BA%9A%E6%B4%B2%E6%B0%91%E4%B8%BB/"/>
    
      <category term="影评" scheme="http://yoursite.com/tags/%E5%BD%B1%E8%AF%84/"/>
    
  </entry>
  
  <entry>
    <title>动手做一个网络简历并且保存成PDF</title>
    <link href="http://yoursite.com/2018/03/02/%E5%8A%A8%E6%89%8B%E5%81%9A%E4%B8%80%E4%B8%AA%E7%BD%91%E7%BB%9C%E7%AE%80%E5%8E%86%E5%B9%B6%E4%B8%94%E4%BF%9D%E5%AD%98%E6%88%90PDF/"/>
    <id>http://yoursite.com/2018/03/02/动手做一个网络简历并且保存成PDF/</id>
    <published>2018-03-02T05:36:51.000Z</published>
    <updated>2018-03-02T17:43:57.745Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="环境说明">环境说明</span></h2><p>服务器:<code>nginx</code><br>浏览器:<code>firefox</code></p><h2><span id="制作网页简历过程">制作网页简历过程</span></h2><p>首先先下载简历的模板文件，过程如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget http:<span class="comment">//labfile.oss.aliyuncs.com/courses/624/cv-template.zip</span></span><br><span class="line">unzip cv-template</span><br><span class="line">mv cv-template<span class="comment">/* .</span></span><br><span class="line"><span class="comment">rm -rf cv-template* __MACOSX*</span></span><br></pre></td></tr></table></figure></p><p>然后在浏览器里的地址栏里输入<code>服务器外网IP</code>，就可看到下面的界面，如图：<br><img src="/images/jianli.png" alt="paradin"></p><p>我们发现这个界面是可以编辑的，于是就在前人的基础上修改即可，这里感谢前人栽树！！！</p><p>但是修改了并不是就保存了，如果你刷新这个界面发现又变成了初始的界面。所以这个时候我们要把修改过的网页的前端代码拷贝下来。</p><p>在firefox浏览器的<code>配置</code>里选择<code>WEB开发者</code>，如图：<br><img src="/images/jianli5.png" alt="paradin"></p><p>然后选择<code>查看器</code>：<br><img src="/images/jianli1.png" alt="paradin"></p><p>这个时候在页面就出现了整个网页的代码，选择<code>复制</code>—<code>HTML外面</code>：<br><img src="/images/jianli2.png" alt="paradin"></p><p>然后把这个html代码拷贝到nginx服务器里的<code>index.html</code>里覆盖原有的内容，再重新刷新浏览器，就会成为已经保存过的界面了！<br><img src="/images/jianli6.png" alt="paradin"></p><h2><span id="将网页保存成pdf">将网页保存成PDF</span></h2><p>在浏览器里的<code>配置</code>里选择<code>打印</code>，然后现在<code>页面设置</code>里的勾选<code>打印背景（颜色和图片）</code>再修改一下<code>页眉和页脚</code>。再点击打印，默认情况就会保存成<code>PDF</code>文件了。<br><img src="/images/jianli4.png" alt="paradin"><br><img src="/images/jianli3.png" alt="paradin"></p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://segmentfault.com/a/1190000006820290" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006820290</a></p><p><img src="/images/guangmei1.gif" alt="paradin"></p>]]></content>
    
    <summary type="html">
    
      跳槽的高峰期，你需要一个帅气时尚的简历！
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>Linux运维工程师笔试题第十五套</title>
    <link href="http://yoursite.com/2018/03/01/Linux%E8%BF%90%E7%BB%B4%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%AC%94%E8%AF%95%E9%A2%98%E7%AC%AC%E5%8D%81%E4%BA%94%E5%A5%97/"/>
    <id>http://yoursite.com/2018/03/01/Linux运维工程师笔试题第十五套/</id>
    <published>2018-03-01T05:50:16.000Z</published>
    <updated>2018-03-07T03:35:44.952Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="正文">正文</span></h2><p>1.粘包是什么意思？<code>TCP</code>和<code>UDP</code>是否会出现粘包？出现了粘包如何处理？<br>[我的答案]粘包就是当客户端连续不断的往服务端发送数据包的时候，服务端接收的数据会出现两个数据包粘在一起的情况；UDP（非面向连接）是不会出现粘包的，因为UDP协议是基于报文的，UDP首部采用了16bit来指示UDP数据报文的长度，因此在应用层能很好的将不同的数据报文区分开，从而避免粘包和拆包的问题。而TCP（面向连接）是基于字节流的，它无法识别包的长度，所以会出现粘包的现象。</p><p>解决办法主要有以下三种：<br>1）发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了，有较高的效率而且少冗余，但是编程较复杂；<br>2）发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来，编程简单但是效率一般甚至很低；<br>3）可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开；</p><p>2.<code>time_wait</code>是什么情况？如果出现了过多的<code>close_wait</code>可能是什么原因？<br>[我的答案]<code>TIME_WAIT</code>是主动关闭连接的一方保持的状态，在保持这个状态2MSL<code>max segment lifetime</code>时间之后，彻底关闭回收资源。遇到<code>TIME_WAIT</code>数过大导致的服务器异常，很容易解决，修改下<code>/etc/sysctl.conf</code>就ok了。</p><p>如果一直保持在<code>CLOSE_WAIT</code>状态，那么只有一种情况，就是在对方关闭连接之后服务器程序自己没有进一步发出<code>ack</code>信号。换句话说，就是在对方连接关闭之后，程序里没有检测到，或者程序压根就忘记了这个时候需要关闭连接，于是这个资源就一直被程序占着。这个情况多半是代码的问题，在服务器端是无能为力的，要检查代码。</p><p>3.<code>epoll</code>和<code>select</code>的区别？边缘触发和水平触发的区别？<br>[我的答案]<code>select</code>查询速度较慢，因为他每次产生<code>fd</code>时候会有整体<code>fdset</code>的拷贝，而且每次有回送，<code>select</code>要查询整个<code>fdset</code>；<code>epoll</code>查询速度较快，因为他为每个<code>fd</code>都<code>regist</code>了一个单独的回调函数。</p><p>水平触发(LT)：当<code>epoll</code>检测到其上有事件发生并通知应用程序时，应用程序可以不立即处理，这样当应用程序再次调用<code>epoll</code>中调用函数时，<code>epoll</code>会再次通知应用程序此事件,直到被处理。</p><p>边沿触发(ET)：当<code>epoll</code>检测到其上有事件发生并通知应用程序时，应用程序必须立即处理，并且下一次的<code>epoll</code>调用，不会再向应用程序通知此事件。</p><p>所以<code>ET</code>模式大大得降低了同一个<code>epoll</code>事件被重复触发的次数，因此<code>ET</code>模式工作效率比<code>LT</code>模式更高。<code>select</code>、<code>poll</code>、<code>epoll</code>的默认工作模式都是水平触发(<code>LT</code>)模式，但是epoll是支持边沿触发(<code>ET</code>)模式的。 </p><p>4.<code>varchar</code>和<code>char</code>的区别是什么？utf8字符集下<code>varchar</code>最多存多少个字符？<br>[我的答案]前面那个问题去看<a href="http://blog.51cto.com/chenx1242/1742467，这里说后面那个。" target="_blank" rel="noopener">http://blog.51cto.com/chenx1242/1742467，这里说后面那个。</a><br>在<code>utf-8</code>状态下的<code>varchar</code>，最大只能到 <code>(65535 - 2) / 3 = 21844 余 1</code>。<br>在<code>gbk</code>状态下的<code>varchar</code>, 最大只能到 <code>(65535 - 2) / 2 = 32766 余 1</code>。</p><p>5.<code>primary key</code>和<code>unique</code>的区别？<br>[我的答案]首先先说明<code>primary key = unique +  not null</code>，其次<code>Unique Key</code>可以可以是空，可以在一个表里的一个或多个字段定义，也就是爱有几个有几个，同时存在也可以；但是<code>Primary Key</code>不能为空不能重复，而其一个表里只能有一个<code>Primary Key</code>。</p><p>6.乐观锁是啥，悲观锁是啥？<br>[我的答案]悲观锁<code>Pessimistic Lock</code>, 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会<code>block</code>直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</p><p>乐观锁<code>Optimistic Lock</code>, 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于<code>write_condition</code>机制的其实都是提供的乐观锁。</p><p>两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适。</p><p>7.如何在python的三引号里添加变量？<br>[我的答案]<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">~$ python</span><br><span class="line">Python <span class="number">2.7</span><span class="number">.3</span> (<span class="keyword">default</span>, Jan  <span class="number">2</span> <span class="number">2013</span>, <span class="number">16</span>:<span class="number">53</span>:<span class="number">07</span>) </span><br><span class="line">[GCC <span class="number">4.7</span><span class="number">.2</span>] on linux2</span><br><span class="line">Type <span class="string">"help"</span>, <span class="string">"copyright"</span>, <span class="string">"credits"</span> or <span class="string">"license"</span> <span class="keyword">for</span> more information.</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; context = <span class="string">""</span><span class="string">"Here is an example block template:</span></span><br><span class="line"><span class="string">...     name: %(name)s</span></span><br><span class="line"><span class="string">...     age: %(age)d</span></span><br><span class="line"><span class="string">...     job: %(job)s</span></span><br><span class="line"><span class="string">... "</span><span class="string">""</span></span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; print context % dict(name=<span class="string">"Tim Wang"</span>, age=<span class="number">45</span>, job=<span class="string">"Coder"</span>)</span><br><span class="line">Here is an example block template:</span><br><span class="line">    name: Tim Wang</span><br><span class="line">    age: <span class="number">45</span></span><br><span class="line">    job: Coder</span><br><span class="line"> &gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p><p>8.<code>redis</code>满了会怎么样？<br>[我的答案]默认情况下<code>redis</code>满了就不会存储新的数据了，不过这个可以调整，<code>redis</code>在达到指定内存的时候可以通过设定的策略来做不同的动作，常见策略如下：<br>1）<code>noeviction</code>:返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但DEL和几个例外）<br>2）<code>allkeys-lru</code>: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。<br>3）<code>volatile-lru</code>: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。<br>4）<code>allkeys-random</code>: 回收随机的键使得新添加的数据有空间存放。<br>5）<code>volatile-random</code>: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。<br>6）<code>volatile-ttl</code>: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。</p><p>9.啥是“脏读”、“不可重复读”、“幻读”？<br>[我的答案]<code>脏读</code>又称无效数据的读出，是指在数据库访问中，事务T1将某一值修改，然后事务T2读取该值，此后T1因为某种原因撤销对该值的修改，这就导致了T2所读取到的数据是无效的。</p><p><code>不可重复读</code>是指在数据库访问中，一个事务范围内两个相同的查询却返回了不同数据。这是由于查询时系统中其他事务修改的提交而引起的。比如事务T1读取某一数据，事务T2读取并修改了该数据，T1为了对读取值进行检验而再次读取该数据，便得到了不同的结果。</p><p><code>幻读</code>是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的“全部数据行”。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入“一行新数据”。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。</p><p>10.ext2、ext3、ext4的区别是啥？<br>[我的答案]<code>ext3</code>和<code>ext2</code>的主要区别在于，<code>ext3</code>引入<code>Journal</code>。<br><code>ext2</code>和<code>ext3</code>的格式完全相同，只是在<code>ext3</code>硬盘最后面有一部分空间用来存放<code>Journal</code>（日志）的记录；<br>在<code>ext2</code>中，写资料到硬盘中时，先将资料写入缓存中，当缓存写满时才会写入硬盘中；<br>在<code>ext3</code>中，写资料到硬盘中时，先将资料写入缓存中，待缓存写满时系统先通知<code>Journal</code>，再将资料写入硬盘，完成后再通知<code>Journal</code>，资料已完成写入工作；<br>在<code>ext3</code>中，也就是有<code>Journal</code>机制里，系统开机时检查<code>Journal</code>的资料，来查看是否有错误产生，这样就快了很多；</p><p><code>ext4</code>和<code>ext3</code>的主要区别在于:首先<code>ext4</code>与<code>ext3</code>兼容,<code>ext3</code>只支持32,000个子目录，而额<code>ext4</code>支持无限数量的子目录;<code>ext3</code>所支持的16TB文件系统和最大的2TB的文件，而<code>ext4</code>分别支持1EB（1,048,576TB，1EB=1024PB，1PB=1024TB）的文件系统，以及16TB的文件;<code>ext3</code>的数据块分配策略是尽快分配，而<code>ext4</code>是尽可能地延迟分配，直到文件在<code>cache</code>中写完才开始分配数据块并写入磁盘;<code>ext4</code>允许关闭日志，以便某些有特殊需求的用户可以借此进一步提升性能等等等等。</p><p>11.简述一下A记录与NS记录的区别<br>1.A记录是名称解析的重要记录，它用于将特定的主机名映射到对应主机的IP地址上。你可以在DNS服务器中手动创建或通过DNS客户端动态更新来创建。<br>2.NS记录此记录指定负责此DNS区域的权威名称服务器。<br>3.A记录和NS记录的区别是，A记录直接给出目的IP，NS记录将DNS解析任务交给特定的服务器，NS记录中记录的IP即为该特定服务器的IP地址。<br>4.NS记录优先于A记录，A记录优先于CNAME记录 </p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://blog.insanecoder.top/tcp-packet-splice-and-split-issue/" target="_blank" rel="noopener">https://blog.insanecoder.top/tcp-packet-splice-and-split-issue/</a><br><a href="http://blog.csdn.net/tiandijun/article/details/41961785" target="_blank" rel="noopener">http://blog.csdn.net/tiandijun/article/details/41961785</a><br><a href="http://www.redis.cn/topics/lru-cache.html" target="_blank" rel="noopener">http://www.redis.cn/topics/lru-cache.html</a><br><a href="http://blog.csdn.net/d_guco/article/details/53166722" target="_blank" rel="noopener">http://blog.csdn.net/d_guco/article/details/53166722</a><br><a href="http://www.hollischuang.com/archives/934" target="_blank" rel="noopener">http://www.hollischuang.com/archives/934</a><br><a href="http://zhaodedong.leanote.com/post/Linux%EF%BC%9AExt2-Ext3-Ext4%E7%9A%84%E5%8C%BA%E5%88%AB" target="_blank" rel="noopener">http://zhaodedong.leanote.com/post/Linux%EF%BC%9AExt2-Ext3-Ext4%E7%9A%84%E5%8C%BA%E5%88%AB</a></p>]]></content>
    
    <summary type="html">
    
      大牛之路，如此辛苦
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="面试经验" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/"/>
    
      <category term="大牛之路" scheme="http://yoursite.com/tags/%E5%A4%A7%E7%89%9B%E4%B9%8B%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>调用阿里云api获取阿里云数据同步服务（DTS）并且作图发送邮件的整个流程</title>
    <link href="http://yoursite.com/2018/02/28/%E8%B0%83%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91api%E8%8E%B7%E5%8F%96%E9%98%BF%E9%87%8C%E4%BA%91%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E6%9C%8D%E5%8A%A1%EF%BC%88DTS%EF%BC%89%E5%B9%B6%E4%B8%94%E4%BD%9C%E5%9B%BE%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E7%9A%84%E6%95%B4%E4%B8%AA%E6%B5%81%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/02/28/调用阿里云api获取阿里云数据同步服务（DTS）并且作图发送邮件的整个流程/</id>
    <published>2018-02-28T15:00:20.000Z</published>
    <updated>2018-02-28T15:27:54.743Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="前言">前言</span></h2><p>在<a href="https://rorschachchan.github.io/2018/02/24/阿里云获取DTS服务延迟的脚本/" target="_blank" rel="noopener">https://rorschachchan.github.io/2018/02/24/阿里云获取DTS服务延迟的脚本/</a> 文章里已经说了“领导要求每天查看阿里云dts同步的延迟情况和同步速率情况”，并且在<a href="https://rorschachchan.github.io/2018/02/27/使用matplotlib画图的一个脚本/" target="_blank" rel="noopener">https://rorschachchan.github.io/2018/02/27/使用matplotlib画图的一个脚本/</a> 里面也放了一个使用<code>python matplotlib</code>画图的demo，这篇文章的目的就是把整个过程实现，并且把dts图形以每日邮件的形式发送给领导的效果！</p><h2><span id="实现需求的思路">实现需求的思路</span></h2><p>本次需求有四个动作，分别是<code>获取一天以内的DTS延迟和同步速率</code>、<code>将获取到的DTS值做成PNG图像</code>、<code>将生成的PNG图像上传到阿里云云存储OSS</code>、<code>把图片展示到邮件里并发送给相关领导</code>。由于第一步<code>获取一天以内的DTS延迟和同步速率</code>需要将这个脚本每小时执行一次，执行24次，才可以执行<code>生成png图像</code>这一步，所以后三个其实可以写成一个大脚本。不过在本文为了表述的清楚，就把各自不同用途写成了不同的脚本。</p><h2><span id="获取阿里云dts延迟和同步速率的脚本">获取阿里云DTS延迟和同步速率的脚本</span></h2><p>这个脚本之前写过了，这里再拿出来晒一遍：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line">#coding=utf-8</span><br><span class="line">#这个脚本是用来获取dts延迟数字的</span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore <span class="keyword">import</span> client</span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore.acs_exception.exceptions <span class="keyword">import</span> ClientException</span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore.acs_exception.exceptions <span class="keyword">import</span> ServerException</span><br><span class="line"><span class="keyword">import</span> time,json,sys</span><br><span class="line">sys.path.append('/解压缩路径/aliyunsdkdts/request/v20160801/')#这里看不懂去看https://rorschachchan.github.io/2018/02/24/阿里云获取DTS服务延迟的脚本/</span><br><span class="line"><span class="keyword">import</span> DescribeSynchronizationJobStatusRequest</span><br><span class="line"></span><br><span class="line"># 创建 Client 实例</span><br><span class="line">clt = client.AcsClient(<span class="string">'这里填写ak'</span>,<span class="string">'这里填写sk'</span>,<span class="string">'cn-shenzhen'</span>)</span><br><span class="line"></span><br><span class="line"># 创建 request，并设置参数</span><br><span class="line">request = DescribeSynchronizationJobStatusRequest.DescribeSynchronizationJobStatusRequest()</span><br><span class="line">request.set_SynchronizationJobId(<span class="string">"这里填写DTS的ID号"</span>)</span><br><span class="line"></span><br><span class="line">response = clt.do_action_with_exception(request)</span><br><span class="line"></span><br><span class="line">delay = json.loads(response)</span><br><span class="line">rate = str(delay["Performance"]["FLOW"])[0:4]#由于同步速率默认是带单位的，这里就取前四位</span><br><span class="line"></span><br><span class="line">#用A.txt来存储延迟时长</span><br><span class="line">fd = open(<span class="string">"/存储路径/A.txt"</span>,<span class="string">"a"</span>)</span><br><span class="line">fd.write(str(delay[<span class="string">"DataSynchronizationStatus"</span>][<span class="string">"Delay"</span>]))</span><br><span class="line">fd.write(<span class="string">'\n'</span>)</span><br><span class="line">fd.close()</span><br><span class="line"></span><br><span class="line">#用B.txt来存储同步速率</span><br><span class="line">fr = open(<span class="string">"/存储路径/rate.txt"</span>,<span class="string">"a"</span>)</span><br><span class="line">fr.write(rate)</span><br><span class="line">fr.write(<span class="string">'\n'</span>)</span><br><span class="line">fr.close()</span><br></pre></td></tr></table></figure></p><h2><span id="将获取到的值做成图片的脚本">将获取到的值做成图片的脚本</span></h2><p>由于脚本执行环境是无图像的阿里云服务器，系统是<code>centos 7</code>，<code>ps.slow</code>这一步会爆错<code>RuntimeError: could not open display</code>，所以只能采取把生成的PNG图像文件保存到本地路径里的方法。脚本内容如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line">mpl.use('Agg')#在无法生成图像的环境下要添加了上面两句话</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pylab <span class="keyword">as</span> pl</span><br><span class="line"></span><br><span class="line">x=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>,<span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span>,<span class="number">24</span>]</span><br><span class="line">#横坐标的内容</span><br><span class="line">labels=[<span class="string">'10'</span>,<span class="string">'11'</span>,<span class="string">'12'</span>,<span class="string">'13'</span>,<span class="string">'14'</span>,<span class="string">'15'</span>,<span class="string">'16'</span>,<span class="string">'17'</span>,<span class="string">'18'</span>,<span class="string">'19'</span>,<span class="string">'20'</span>,<span class="string">'21'</span>,<span class="string">'22'</span>,<span class="string">'23'</span>,<span class="string">'24'</span>,<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>,<span class="string">'6'</span>,<span class="string">'7'</span>,<span class="string">'8'</span>,<span class="string">'9'</span>]</span><br><span class="line"></span><br><span class="line">#y1是delay延迟时长</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'/存储路径/A.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    y1 = []</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        lst = line.split('\n')#增加一个换行符，不然数字是不换行的</span><br><span class="line">        y1.append(float(lst[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">#y2是rate同步速率</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'/存储路径/B.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    y2 = []</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        lst = line.split(<span class="string">'\n'</span>)</span><br><span class="line">        y2.append(float(lst[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">#输入对应的坐标，后面是颜色</span><br><span class="line">plot1,=pl.plot(x,y1,<span class="string">'r'</span>)</span><br><span class="line">plot2,=pl.plot(x,y2,<span class="string">'b'</span>)</span><br><span class="line"></span><br><span class="line">pl.xticks(x,labels)</span><br><span class="line"></span><br><span class="line">pl.title('这里写标题',size=20)#中文会显示乱码，推荐还是英文</span><br><span class="line">pl.xlabel(<span class="string">'这里是X轴标题'</span>, size=<span class="number">14</span>)</span><br><span class="line">pl.ylabel(<span class="string">'这里写Y轴标题'</span>, size=<span class="number">14</span>)</span><br><span class="line">pl.ylim(<span class="number">0.0</span>,<span class="number">5.0</span>)</span><br><span class="line"></span><br><span class="line">#曲线对应注释</span><br><span class="line">pl.legend([plot1,plot2],(<span class="string">'Delay'</span>,<span class="string">'Sync rate'</span>),<span class="string">'best'</span>,numpoints=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">#开启网格</span><br><span class="line">pl.grid()</span><br><span class="line"></span><br><span class="line">#图片保存路径</span><br><span class="line">plt.savefig(<span class="string">'/保存路径/图片名称.png'</span>, format=<span class="string">'png'</span>)</span><br></pre></td></tr></table></figure></p><h2><span id="将生成的图片上传到阿里云oss的脚本">将生成的图片上传到阿里云OSS的脚本</span></h2><p>由于不想让“领导去手动点开附件查看图像”，所以我们干脆把图片作为邮件的正文展示出来，那么就在html里就需要<code>img src=图片的网络地址</code>的方法。于是就把刚刚生成的图片上传到阿里云OSS里，这样就可以获得图片的网络地址。而且阿里云OSS是“相同文件名会覆盖”，所以不用再去删除。整个脚本内容如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">import</span> oss2</span><br><span class="line"></span><br><span class="line">access_key_id = os.getenv(<span class="string">'OSS_TEST_ACCESS_KEY_ID'</span>, <span class="string">'这里填写ak'</span>)</span><br><span class="line">access_key_secret = os.getenv(<span class="string">'OSS_TEST_ACCESS_KEY_SECRET'</span>, <span class="string">'这里填写sk'</span>)</span><br><span class="line">bucket_name = os.getenv(<span class="string">'OSS_TEST_BUCKET'</span>, <span class="string">'这里填写bucket名称'</span>)</span><br><span class="line">endpoint = os.getenv(<span class="string">'OSS_TEST_ENDPOINT'</span>, <span class="string">'这里填写内网end-point'</span>)</span><br><span class="line"></span><br><span class="line"># 确认上面的参数都填写正确了</span><br><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> (access_key_id, access_key_secret, bucket_name, endpoint):</span><br><span class="line">    assert <span class="string">'&lt;'</span> not <span class="keyword">in</span> param, <span class="string">'请设置参数：'</span> + param</span><br><span class="line"></span><br><span class="line"># 创建Bucket对象，所有Object相关的接口都可以通过Bucket对象来进行</span><br><span class="line">bucket = oss2.Bucket(oss2.Auth(access_key_id, access_key_secret), endpoint, bucket_name)</span><br><span class="line">bucket.put_object_from_file(<span class="string">'上传到OSS的图片名称.png'</span>, <span class="string">'/服务器保存路径/图片名称.png'</span>)</span><br></pre></td></tr></table></figure></p><h2><span id="将图片作为内容发邮件的脚本">将图片作为内容发邮件的脚本</span></h2><p>整个脚本内容如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line"><span class="keyword">import</span> os,time,re,smtplib,logging</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.header <span class="keyword">import</span> Header</span><br><span class="line"></span><br><span class="line">def send_mail(to_list, cc_list, html, sub):</span><br><span class="line">    me = mail_user</span><br><span class="line">    msg = MIMEText(html, _subtype='html', _charset='utf-8')  # 格式化邮件内容为html，编码为utf-8</span><br><span class="line">    msg['Subject'] = sub    # 邮件主题</span><br><span class="line">    msg['From'] = me    # 发件人</span><br><span class="line">    msg['To'] = ";".join(to_list)  # 收件人，将列表转换为字符串</span><br><span class="line">    msg['Cc'] = ";".join(cc_list)  # 抄送人，将列表转换为字符串</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        send_smtp = smtplib.SMTP()    # 实例化</span><br><span class="line">        send_smtp.connect(mail_host)    # 连接smtp服务器</span><br><span class="line">        send_smtp.login(mail_user, mail_pass)    # 使用定义的账号密码进行登录</span><br><span class="line">        send_smtp.sendmail(me, to_list+cc_list, msg.as_string())    # 发送邮件</span><br><span class="line">        send_smtp.close()    # 关闭连接</span><br><span class="line">        <span class="keyword">return</span> True</span><br><span class="line">    except Exception, <span class="attr">e</span>:</span><br><span class="line">        logging.basicConfig(filename=<span class="string">'logger.log'</span>, level=logging.DEBUG)</span><br><span class="line">        logging.debug(e)</span><br><span class="line">        print (<span class="string">"ERROR!!!!"</span>)</span><br><span class="line">        <span class="keyword">return</span> False</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">   mail_host = <span class="string">'mail.dahuatech.com'</span></span><br><span class="line">   mail_user = <span class="string">'这里填写发件人地址'</span></span><br><span class="line">   mail_pass = <span class="string">'填写对应的密码'</span></span><br><span class="line">   mailto_list = [<span class="string">'收件人邮箱地址'</span>]</span><br><span class="line">   mailcc_list = [<span class="string">'抄送人1的邮箱地址'</span>，<span class="string">'抄送人2的邮箱地址'</span>]</span><br><span class="line">   html = <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">               &lt;body&gt; </span></span><br><span class="line"><span class="string">                &lt;br&gt;&lt;img src="</span>这里填写的是图片的http地址<span class="string">"&gt;&lt;/br&gt;</span></span><br><span class="line"><span class="string">               &lt;table color="</span>CCCC33<span class="string">" width="</span><span class="number">800</span><span class="string">" border="</span><span class="number">1</span><span class="string">" cellspacing="</span><span class="number">0</span><span class="string">" cellpadding="</span><span class="number">5</span><span class="string">" text-align="</span>center<span class="string">"&gt;</span></span><br><span class="line"><span class="string">                       &lt;tr&gt;</span></span><br><span class="line"><span class="string">                     &lt;td test-align="</span>center<span class="string">"&gt;上图是阿里云深圳VPC区数据同步过去24小时的情况。&lt;br /&gt;</span></span><br><span class="line"><span class="string">                     注意事项 1:dts的延迟时间是5秒计算一次，api请求会取到最新的延迟时间，而控制台是每隔20秒才刷新一次；</span></span><br><span class="line"><span class="string">                     注意事项 2:api在延迟时间取值为整数，即1.x显示为2，请知悉; </span></span><br><span class="line"><span class="string">                     注意事项 3:此邮件是系统自动发出，如果有任何疑问请联系运维人员；</span></span><br><span class="line"><span class="string">                       &lt;/tr&gt;&lt;/br&gt;</span></span><br><span class="line"><span class="string">               &lt;/table&gt;</span></span><br><span class="line"><span class="string">               &lt;/body&gt; "</span><span class="string">""</span></span><br><span class="line"></span><br><span class="line">    sub = <span class="string">"阿里云深圳VPC数据同步情况"</span></span><br><span class="line">    <span class="keyword">if</span> send_mail(mailto_list,mailcc_list,html,sub):</span><br><span class="line">        logging.debug(<span class="string">"Send mail succed!"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        logging.debug(<span class="string">"Send mail failed"</span>)</span><br></pre></td></tr></table></figure></p><p>上面四个脚本整个执行下来，效果如下，至此大功告成！<br><img src="/images/dts3.png" alt="paradin"></p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://github.com/aliyun/aliyun-oss-python-sdk/blob/master/examples/object_basic.py" target="_blank" rel="noopener">https://github.com/aliyun/aliyun-oss-python-sdk/blob/master/examples/object_basic.py</a><br><a href="https://hk.saowen.com/a/fe355cb5cc3ab17dbc84e9489621d2ab31da72b511092839832bc9e89d63bf71" target="_blank" rel="noopener">https://hk.saowen.com/a/fe355cb5cc3ab17dbc84e9489621d2ab31da72b511092839832bc9e89d63bf71</a><br><a href="http://blog.csdn.net/baoli1008/article/details/47980779" target="_blank" rel="noopener">http://blog.csdn.net/baoli1008/article/details/47980779</a><br><a href="https://www.digglife.net/articles/html-mail-with-inline-images-python-perl.html" target="_blank" rel="noopener">https://www.digglife.net/articles/html-mail-with-inline-images-python-perl.html</a></p>]]></content>
    
    <summary type="html">
    
      整个流程就一点不是很完美，就是matplotlib的中文显示是乱码
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>一个监控挂载盘的python脚本</title>
    <link href="http://yoursite.com/2018/02/27/%E4%B8%80%E4%B8%AA%E7%9B%91%E6%8E%A7%E6%8C%82%E8%BD%BD%E7%9B%98%E7%9A%84python%E8%84%9A%E6%9C%AC/"/>
    <id>http://yoursite.com/2018/02/27/一个监控挂载盘的python脚本/</id>
    <published>2018-02-27T15:08:09.000Z</published>
    <updated>2018-02-27T15:19:48.450Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="前言">前言</span></h2><p>公司产品线有一个公用的挂载盘，主要是用来方便各位开发人员去放置他们自己的一些工作材料，比如异常的日志或者<code>tcpdump</code>的抓包等等杂七杂八的东西，但是这个挂载盘由于使用人众多，容量自然要有监控，于是就有了写这个脚本的动机。</p><p>在这里我写了两个脚本，上面这个是用来监控磁盘容量，然后通过<code>df -h</code>的排序生成前十名占容量最大的文件夹，把这个文件夹的名字和对应的大小重定向到一个叫<code>alarm.txt</code>这个文件里，这个文件就是邮件正文。然后在确定他们的主人，统一加上公司邮箱后缀来得到他们主人的邮箱地址，最后对应他们各自的邮箱地址用下面那个脚本来发送文件夹容量过高的邮件。</p><h2><span id="监控挂载盘的脚本">监控挂载盘的脚本</span></h2><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line"># coding=utf-8</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> AutoMail</span><br><span class="line"><span class="keyword">import</span> commands</span><br><span class="line"></span><br><span class="line">#设定变量判断是否挂载和挂载盘的容量</span><br><span class="line">mount = commands.getoutput(<span class="string">"mount | grep ':.*nfs'|wc -l"</span>)</span><br><span class="line">size = commands.getoutput(<span class="string">"df -h | grep share | awk '&#123;print $5&#125;' | cut -d '%' -f 1"</span>)</span><br><span class="line"> </span><br><span class="line">##建立发邮件的文本文件</span><br><span class="line">def Createalarm():</span><br><span class="line">    <span class="keyword">if</span> os.path.exists(<span class="string">'/root/chenscript/alarm.txt'</span>) == True:</span><br><span class="line">        os.system(<span class="string">"python /root/chenscript/weixin_sharealarm.py"</span>)</span><br><span class="line">        print (<span class="string">"微信告警已经发送！"</span>)</span><br><span class="line">        os.system(<span class="string">"cd /root/chenscript; echo 'share盘容量大于80%，现在将调出容量排名前十位的文件夹名字及对应的容量，请各位处理一下不需要的文件！' &gt;/root/chenscript/alarm.txt"</span>)</span><br><span class="line">       os.system(<span class="string">"cd /挂载盘名称 ;du -s * --exclude='不想要计算在内的文件夹' --exclude='不想要计算在内的文件夹' --exclude='不想要计算在内的文件夹'|sort -nr |head &gt;&gt;/root/chenscript/alarm.txt"</span>)</span><br><span class="line">        os.system(<span class="string">"echo '\n' &gt;&gt; /root/chenscript/alarm.txt"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(<span class="string">'/root/chenscript/alarm.txt'</span>) == False:</span><br><span class="line">        os.system(<span class="string">"cd /root/chenscript;touch alarm.txt"</span>)</span><br><span class="line"></span><br><span class="line">def Sendmail():</span><br><span class="line">        fp = open(<span class="string">'/root/chenscript/alarm.txt'</span>, <span class="string">'r'</span>)</span><br><span class="line">        content = fp.read()</span><br><span class="line">        AutoMail.send_mail(<span class="string">'share挂载盘容量大于80%！收到邮件的各位请整理自己对应的文件夹！'</span>, content)</span><br><span class="line"> </span><br><span class="line">#将邮件的文件刷新</span><br><span class="line">def Dellist():</span><br><span class="line">        os.system(<span class="string">"cd /root/chenscript/;rm -f alarm.txt;touch alarm.txt"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> mount == <span class="string">'1'</span> and size &gt;= <span class="string">'80'</span>:</span><br><span class="line">        print (<span class="string">"挂载盘存在！"</span>)</span><br><span class="line">        print (<span class="string">"share盘容量大于80%..."</span>)</span><br><span class="line">        Createlist()</span><br><span class="line">        Sendmail()</span><br><span class="line">        Dellist()</span><br><span class="line">elif mount == <span class="string">'1'</span> and size &lt; <span class="string">'80'</span>:</span><br><span class="line">        print (<span class="string">"挂载盘存在！"</span>)</span><br><span class="line">        print (<span class="string">"share盘容量正常..."</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">       print (<span class="string">"挂载盘不存在，现在重新挂载..."</span>)</span><br><span class="line">       os.system(<span class="string">"mount -t nfs -o acl,rw,intr,soft,nolock,rsize=8192,wsize=8192 10.160.43.172:/share /share "</span>)</span><br></pre></td></tr></table></figure></code></pre><h2><span id="发送告警邮件脚本">发送告警邮件脚本</span></h2><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line">#coding=utf-8</span><br><span class="line">#这个脚本的用途是用来发送邮件</span><br><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"><span class="keyword">from</span> email.mime.multipart <span class="keyword">import</span> MIMEMultipart</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.mime.application <span class="keyword">import</span> MIMEApplication</span><br><span class="line"></span><br><span class="line">mailto_list=[]    #这里为空list，会从list.txt里一行一行的当做元素添加进来</span><br><span class="line"></span><br><span class="line">#生成list.txt</span><br><span class="line"><span class="keyword">if</span> os.path.exists(<span class="string">'/root/chenscript/list.txt'</span>) == True:</span><br><span class="line">        os.system(<span class="string">"cd /挂载盘名称;du -s * --exclude='不想要计算在内的文件夹' --exclude='不想要计算在内的文件夹' --exclude='不想要计算在内的文件夹'|sort -nr |head|awk \'&#123;print $2\"@dahuatech.com\"&#125;\'  &gt;&gt;/root/chenscript/list.txt"</span>)</span><br><span class="line"><span class="keyword">if</span> os.path.exists(<span class="string">'/root/chenscript/list.txt'</span>) == False:</span><br><span class="line">        os.system(<span class="string">"cd /root/chenscript/;rm -f list.txt;echo '本人的邮箱地址'&gt;list.txt"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'/root/chenscript/list.txt'</span>,<span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f=f.readlines()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> f:</span><br><span class="line">        i=i.strip(<span class="string">'\n'</span>)</span><br><span class="line">        mailto_list.append(i)</span><br><span class="line">mail_host=<span class="string">"这里填写邮箱主机"</span></span><br><span class="line">mail_user=<span class="string">"这里填写发送人的邮箱地址"</span></span><br><span class="line">mail_pass=<span class="string">"发送人的邮箱密码"</span></span><br><span class="line">mail_postfix=<span class="string">"dahuatech.com"</span></span><br><span class="line">mail_sender=<span class="string">"与mail_host内容相同"</span></span><br><span class="line">def send_mail(sub, content):</span><br><span class="line">    me=mail_sender</span><br><span class="line">    msg = MIMEMultipart()</span><br><span class="line">    msg[<span class="string">'Subject'</span>] = sub</span><br><span class="line">    msg[<span class="string">'From'</span>] = me</span><br><span class="line">    msg[<span class="string">'To'</span>] = <span class="string">";"</span>.join(mailto_list)</span><br><span class="line">    content1 = MIMEText(str(content), <span class="string">'plain'</span>, <span class="string">'utf-8'</span>)</span><br><span class="line">    msg.attach(content1)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        s = smtplib.SMTP()</span><br><span class="line">        s.connect(mail_host)</span><br><span class="line">        s.login(mail_user,mail_pass)</span><br><span class="line">        s.sendmail(me, mailto_list, msg.as_string())</span><br><span class="line">        print(<span class="string">'发送成功！\n'</span>)</span><br><span class="line">        s.close()</span><br><span class="line">    except Exception <span class="keyword">as</span> e: print(str(e))</span><br><span class="line"></span><br><span class="line">os.system(<span class="string">"cd /root/chenscript/;rm -f list.txt;echo '我本人的邮件地址'&gt;list.txt"</span>)</span><br></pre></td></tr></table></figure></code></pre><p>执行的效果如下：<br><img src="/images/gaojingmail1.png" alt="paradin"></p><h2><span id="隐藏的知识点">隐藏的知识点</span></h2><p>1）<code>du -s</code>是按照字节来统计，<code>--exclude=&#39;yunwei&#39;</code>是在排序的时候忽略掉<code>yunwei</code>这个文件夹，容后再用<code>sort -nr|head</code>是得到从大到小前10名，如果得到后10名就是<code>sort -nr|tail</code>；<br>2）如果使用的是<code>import commands</code>，那么<code>commands.getoutpu</code>t得到的是字符串！<br>3）用<code>mount | grep &#39;:.*nfs&#39;</code>来判断挂载盘是否存在是一个很简单的方式，如果挂了多个，就用<code>ip in</code>的方式来进一步判断；<br>4）python要一行一行的读取文件，就<code>readline</code>；<br>5）python按行读取文件，去掉换行符<code>\n</code>的方法：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> file.readlines():</span><br><span class="line">    line=line.strip(<span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure></p><p>6）<code>import Automail</code>的时候，就已经把<code>Automail.py</code>这个脚本固定住了，这时候<code>mailto_list</code>已经不能变化了，所以要把添加<code>list.txt</code>放到这个脚本里。<br><img src="/images/gaojingmail2.png" alt="paradin"></p><p>发了邮件，连吼带骂一顿，终于把share盘容量下降到了69这样一个美妙的数字…</p>]]></content>
    
    <summary type="html">
    
      将监控进行到无死角
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>使用matplotlib画图的一个脚本</title>
    <link href="http://yoursite.com/2018/02/27/%E4%BD%BF%E7%94%A8matplotlib%E7%94%BB%E5%9B%BE%E7%9A%84%E4%B8%80%E4%B8%AA%E8%84%9A%E6%9C%AC/"/>
    <id>http://yoursite.com/2018/02/27/使用matplotlib画图的一个脚本/</id>
    <published>2018-02-27T10:50:24.000Z</published>
    <updated>2018-02-27T13:33:18.045Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="准备工作">准备工作</span></h2><p>之前在<a href="https://rorschachchan.github.io/2018/02/24/阿里云获取DTS服务延迟的脚本/" target="_blank" rel="noopener">https://rorschachchan.github.io/2018/02/24/阿里云获取DTS服务延迟的脚本/</a> 里已经可以获取到阿里云DTS服务的延迟时长和同步速率。下一步就是把这些值以24小时为周期作一个图像，然后每天在固定时间发送到领导们的邮件里。</p><p>python作图的第三方工具叫<code>matplotlib</code>，安装步骤如下：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pip install matplotlib#画图模块</span><br><span class="line">pip install numpy#依赖的库</span><br><span class="line">pip install scipy#又一个依赖的库</span><br><span class="line">yum install -y Tkinter#如果是python3，那么就是yum install -y tkinter</span><br></pre></td></tr></table></figure></p><h2><span id="脚本内容">脚本内容</span></h2><p>由于我是在<code>centos 7</code>里进行脚本操作，而linux服务器有没有安装图像，所以在执行<code>import matplotlib.pyplot as plt</code>的时候可能会爆错：<code>RuntimeError: could not open display</code>，这个时候需要在前面改成如下样式（注意先后顺序）：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line">mpl.use(<span class="string">'Agg'</span>)</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure></p><p>举一个简单的脚本例子如下，就是给予（x,y）然后连成曲线图的效果，脚本里数字的部分不加引号也是可以识别的，当然使用变量也可以。<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line">mpl.use(<span class="string">'Agg'</span>)</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line"><span class="keyword">import</span> pylab <span class="keyword">as</span> pl  </span><br><span class="line"> </span><br><span class="line">x=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>,<span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span>,<span class="number">24</span>]</span><br><span class="line">#横坐标的内容</span><br><span class="line">labels=[<span class="string">'10'</span>,<span class="string">'11'</span>,<span class="string">'12'</span>,<span class="string">'13'</span>,<span class="string">'14'</span>,<span class="string">'15'</span>,<span class="string">'16'</span>,<span class="string">'17'</span>,<span class="string">'18'</span>,<span class="string">'19'</span>,<span class="string">'20'</span>,<span class="string">'21'</span>,<span class="string">'22'</span>,<span class="string">'23'</span>,<span class="string">'24'</span>,<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>,<span class="string">'6'</span>,<span class="string">'7'</span>,<span class="string">'8'</span>,<span class="string">'9'</span>]</span><br><span class="line"></span><br><span class="line">a = <span class="string">'1'</span></span><br><span class="line">b = <span class="string">'2'</span></span><br><span class="line">c = <span class="string">'3'</span></span><br><span class="line">d = <span class="string">'4'</span></span><br><span class="line"></span><br><span class="line">#y1是延迟</span><br><span class="line">y1=[<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'5'</span>,<span class="string">'4'</span>,<span class="string">'2'</span>,<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'5'</span>,<span class="string">'4'</span>,<span class="string">'2'</span>,<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'5'</span>,<span class="string">'4'</span>,<span class="string">'2'</span>,<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'5'</span>]</span><br><span class="line"></span><br><span class="line">#y2是同步速率</span><br><span class="line">y2=[a,b,c,d,<span class="number">0.13</span>,<span class="number">0.12</span>,<span class="number">0.14</span>,<span class="number">0.14</span>,<span class="number">0.14</span>,<span class="number">0.16</span>,<span class="number">0.15</span>,<span class="number">0.13</span>,<span class="number">0.12</span>,<span class="number">0.14</span>,<span class="number">0.14</span>,<span class="number">0.14</span>,<span class="number">0.16</span>,<span class="number">0.15</span>,<span class="number">0.13</span>,<span class="number">0.12</span>,<span class="number">0.14</span>,<span class="number">0.22</span>,<span class="number">0.18</span>,<span class="number">0.11</span>]</span><br><span class="line"></span><br><span class="line">#输入对应的坐标，后面是颜色</span><br><span class="line">plot1,=pl.plot(x,y1,'r')#这里是有逗号的，用于参数解包</span><br><span class="line">plot2,=pl.plot(x,y2,<span class="string">'b'</span>)  </span><br><span class="line">pl.xticks(x,labels)</span><br><span class="line"></span><br><span class="line">#图片的标题以及对应的字号大小</span><br><span class="line">pl.title(<span class="string">'The DTS status of Shenzhen VPC'</span>,size=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">#X轴的标题和字号大小</span><br><span class="line">pl.xlabel(<span class="string">'Time'</span>, size=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line">#Y轴的标题，字号大小和长度</span><br><span class="line">pl.xlabel(<span class="string">'Time'</span>, size=<span class="number">14</span>)</span><br><span class="line">pl.ylim(<span class="number">0.0</span>,<span class="number">5.0</span>)</span><br><span class="line"></span><br><span class="line">#曲线对应注释</span><br><span class="line">pl.legend([plot1,plot2],(<span class="string">'Delay'</span>,<span class="string">'Sync rate'</span>),<span class="string">'best'</span>,numpoints=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">#图片保存路径</span><br><span class="line">plt.savefig(<span class="string">'/tmp/dts.png'</span>, format=<span class="string">'png'</span>)</span><br></pre></td></tr></table></figure></p><p>脚本执行效果之后，会在对应的路径里生成一个图片文件，然后把这个图片转移到windows，打开就看到效果了，如图：<br><img src="/images/dts.png" alt="paradin"></p><p>这个图是全英文的，如果是中文的话，就会出现乱码，研究了半天也没搞明白，这一点让我很郁闷。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="http://python.jobbole.com/81182/" target="_blank" rel="noopener">http://python.jobbole.com/81182/</a><br><a href="https://absentm.github.io/2017/03/18/Python-matplotlib-数据可视化/" target="_blank" rel="noopener">https://absentm.github.io/2017/03/18/Python-matplotlib-数据可视化/</a><br><a href="https://liam0205.me/2014/09/11/matplotlib-tutorial-zh-cn/" target="_blank" rel="noopener">https://liam0205.me/2014/09/11/matplotlib-tutorial-zh-cn/</a><br><a href="https://morvanzhou.github.io/tutorials/data-manipulation/plt/1-1-why/" target="_blank" rel="noopener">https://morvanzhou.github.io/tutorials/data-manipulation/plt/1-1-why/</a><br><a href="https://www.lookfor404.com/%E8%BF%90%E8%A1%8Cggplot%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98no-display-name-and-no-display-environment-variable/" target="_blank" rel="noopener">https://www.lookfor404.com/%E8%BF%90%E8%A1%8Cggplot%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98no-display-name-and-no-display-environment-variable/</a></p>]]></content>
    
    <summary type="html">
    
      插播一句题外话：将域名解析到IP的其他端口的方法是通过一个临时域名来配置“隐性url”
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>解决https证书在赛门铁克认证失败的问题</title>
    <link href="http://yoursite.com/2018/02/26/%E8%A7%A3%E5%86%B3https%E8%AF%81%E4%B9%A6%E5%9C%A8%E8%B5%9B%E9%97%A8%E9%93%81%E5%85%8B%E8%AE%A4%E8%AF%81%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/02/26/解决https证书在赛门铁克认证失败的问题/</id>
    <published>2018-02-26T14:40:03.000Z</published>
    <updated>2018-02-27T06:57:58.892Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="问题描述">问题描述</span></h2><p>今天电子商城的市场接到一个故障，说更换了.lechange.com的https证书（原有的证书到期了，新买了一个依旧还是.lehcange.com域名证书）之后，订单在支付宝支付的时候提示支付失败。我把<code>request id</code>提供给支付宝的客服请他们查看一下后台，支付宝客服说我们电商的https证书没有认证成功。于是我就登陆<a href="https://cryptoreport.websecurity.symantec.com/checker/" target="_blank" rel="noopener">https://cryptoreport.websecurity.symantec.com/checker/</a> 去检查一下电商的域名，果不其然，赛门铁克的反馈是错误的，如图：<br><img src="/images/saimentieke1.png" alt="paradin"></p><p>但是登陆网站，在浏览器里却显示https证书是OK的，如图：<br><img src="/images/saimentieke2.png" alt="paradin"></p><p>然后我用<code>symantec</code>的那个网站测试了一下电商平台开发环境的域名，发现也是OK的，如图：<br><img src="/images/saimentieke3.png" alt="paradin"></p><p>这就郁闷了，到底哪里出问题了？</p><h2><span id="问题排查">问题排查</span></h2><p>首先跟研发确认，开发环境与线上环境在涉及到证书的代码是否一致，得到研发的确认之后。就检查服务器里的<code>nginx</code>，发现服务器<code>nginx</code>的配置文件里是没有涉及到<code>ssl</code>，无论是开发环境和线上环境都是通过阿里云slb配置的https证书。而且两者的证书指纹一模一样，如图：<br><img src="/images/saimentieke4.png" alt="paradin"></p><p>既然都是用的一样的证书，为啥一个检验通过，另一个检验不通过呢？这个时候我想到线上环境与开发环境唯一的不同就是线上环境多了一个cdn，于是就登陆到cdn的控制页面，找到对应的https证书，发现cdn的https证书指纹也是跟上面的指纹一样，如图：<br><img src="/images/saimentieke5.png" alt="paradin"></p><p>既然指纹一样，那证书也应该是一样的，场面又进入了一个僵局。</p><p>于是我就到一台服务器里使用<code>curl -vv https://www.lechange.com</code>，看到的结果如下：<br><img src="/images/saimentieke6.png" alt="paradin"></p><p>提示<code>未配置签发者根证书</code>，我这时候想起来了，<font color="red">首先证书指纹一致不能说明证书是完全一致的，只能说明key文件是一样的！</font>其次这个https证书是中级机构证书，那么中级机构颁发的证书链规则是这样的：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-----BEGIN CERTIFICATE-----</span><br><span class="line"></span><br><span class="line">-----END CERTIFICATE-----</span><br><span class="line"></span><br><span class="line">-----BEGIN CERTIFICATE-----</span><br><span class="line"></span><br><span class="line">-----END CERTIFICATE-----</span><br></pre></td></tr></table></figure></p><p>那么我怀疑就是https证书链那部分可能在cdn配置错误了，或许在slb配置错误了，甚至两个都配置错误了！</p><p>于是干脆删除掉线上电商原有的https证书，重新导入cdn和slb的https证书，返回到<code>symantec</code>刷新，这次的检验结果就OK了。<br><img src="/images/saimentieke7.png" alt="paradin"></p><h2><span id="补充">补充</span></h2><p>虽然这个问题解决了，但是我还是不明白，为什么在网页端查看证书是绿色OK的呢？在<code>sf.gg</code>上提问之后，一个叫Avro的朋友是这么回答我的：</p><blockquote><p>以chrome为例，他信任了[所在平台的信任证书列表][1]，而这些平台集成了一系列信任的根证书，如iOS 11 中可用的受信任根证书列表可以找到你的根证书“04 00 00 00 00 01 15 4B 5A C3 94 ”(序列号)，因此验证过程中没有问题，而对于其他的工具，如果未使用这些平台根证书信任列表依然需要完整的证书链（这个证书链在ssl握手过程中被下发）进行校验。</p></blockquote><h2><span id="参考资料">参考资料</span></h2><p><a href="https://openclub.alipay.com/read.php?tid=3451&amp;fid=57&amp;page=1" target="_blank" rel="noopener">https://openclub.alipay.com/read.php?tid=3451&amp;fid=57&amp;page=1</a><br><a href="https://www.jianshu.com/p/84af353f43c5" target="_blank" rel="noopener">https://www.jianshu.com/p/84af353f43c5</a><br><a href="https://help.aliyun.com/knowledge_detail/39468.html?spm=a2c4g.11186631.2.2.w2qcWT" target="_blank" rel="noopener">https://help.aliyun.com/knowledge_detail/39468.html?spm=a2c4g.11186631.2.2.w2qcWT</a></p>]]></content>
    
    <summary type="html">
    
      搞了半天其实就是https证书没弄对...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="https证书" scheme="http://yoursite.com/tags/https%E8%AF%81%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>记录Apache Storm的部署始末</title>
    <link href="http://yoursite.com/2018/02/25/%E8%AE%B0%E5%BD%95Apache-Storm%E7%9A%84%E9%83%A8%E7%BD%B2%E5%A7%8B%E6%9C%AB/"/>
    <id>http://yoursite.com/2018/02/25/记录Apache-Storm的部署始末/</id>
    <published>2018-02-25T13:27:42.000Z</published>
    <updated>2018-02-25T13:56:07.024Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="前言">前言</span></h2><p><code>Storm</code>是一个流式处理框架（你可以把它当成一种消息队列），开发人员开发出特定的项目，然后通过storm这个渠道下发各种任务，从而达到任务执行的效果。</p><p>Storm有两个比较重要的组件：<code>nimbus</code>和<code>supervision</code>，其中<code>nimbus</code>主要是承接任务和分配任务用，而每一个<code>supervision</code>可以有若干<code>worker</code>（视服务器硬件而定），而<code>supervison</code>的主要任务就是监控对应的<code>worker</code>，一旦<code>worker</code>死了，<code>supervision</code>就会把他们唤醒。</p><p>本次试验是用的是金山云服务器，storm的版本是<code>1.0.2</code>，配置是<code>1个nimbus，三个supervision</code>，每一个worker上只执行一个任务，总共三个任务。</p><h2><span id="准备工作">准备工作</span></h2><p>安装<code>storm</code>之前需要在<code>storm</code>里新安装一套<code>zookeeper</code>，因为<code>storm</code>是需要一个zk集群的，<code>nimbus</code>和每一个<code>supervisior</code>是通过zk的心跳来传递存活的信息，于是我们就在每一个<code>supervision</code>里面安装一个<code>zookeeper</code>，并且启动<code>zookeeper</code>的<code>server</code>端，安装<code>zookeeper</code>的方法可以移步<a href="http://chenx1242.blog.51cto.com/10430133/1889715" target="_blank" rel="noopener">http://chenx1242.blog.51cto.com/10430133/1889715</a> 。</p><p>上面这段话用图来说就是这样子：<br><img src="/images/storm1.jpg" alt="paradin"></p><p>启动<code>zookeeper</code>之后，就需要在<code>nimbus</code>和<code>supervisior</code>里安装<code>storm</code>，上面说过本次安装的<code>storm</code>是<code>1.0.2</code>版本，路径直接是<code>/storm/apache-storm-1.0.2</code>。</p><p>将<code>storm</code>安装完之后，需要在<code>nimbus</code>和<code>supervisior</code>里更改<code>/etc/hosts</code>文件，改成如下的格式：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> localhost</span><br><span class="line"> </span><br><span class="line">nimbus的内网IP online-nimbus<span class="number">-001</span></span><br><span class="line">supervision1的内网IP supervision<span class="number">-001</span></span><br><span class="line">supervision2的内网IP supervision<span class="number">-002</span></span><br><span class="line">supervision3的内网IP supervision<span class="number">-003</span></span><br><span class="line"> </span><br><span class="line">zookeeper的内网IP zookeeper的名称            #注意，这里的zk是给模块拉取配置的zk</span><br><span class="line">storm的zk1的内网IP storm的zk1            #这里的zk就是给storm集群用的zk</span><br><span class="line">storm的zk2的内网IP  storm的zk2                      #如果storm的zk是standalone模式，这里就不要写了。</span><br><span class="line">storm的zk3的内网IP  storm的zk3                      #如果storm的zk是standalone模式，这里就不要写了。</span><br></pre></td></tr></table></figure></p><p>保存完<code>/etc/hosts</code>之后，还有一个比较重要的步骤，就是在<code>/etc/ld.so.conf.d/</code>这个路径里面建立一个<code>ffmped.conf</code>这个文件，文件的内容如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/storm/apache-storm<span class="number">-1.0</span><span class="number">.2</span>/lib</span><br><span class="line">/storm/apache-storm<span class="number">-1.0</span><span class="number">.2</span>/lib/<span class="number">3</span>rd</span><br></pre></td></tr></table></figure></p><p>注意，<code>/storm/apache-storm-1.0.2</code>是我的storm路径，在实际情况下需要根据自己的路径进行更改。</p><p>把这个<code>ffmped.conf</code>建立成功之后，我们可以测试一下，如果输入<code>ldconfig</code>的话，会出现如下的内容，就证明达到了我们的效果：<br><img src="/images/storm2.jpg" alt="paradin"></p><p><code>storm</code>本身的<code>bin</code>目录夹里也有很多命令可以直接使用，为了调用<code>storm list</code>方便，我们需要把<code>bin/storm</code>这个可执行文件作一个软连接，方法就是先<code>cd /usr/local/bin/</code>，然后<code>ln -s /storm/apache-storm-1.0.2/bin/storm storm</code>。这样的话，我们就可以直接使用<code>storm list</code>来查看任务列表了。</p><h2><span id="storm的具体配置">Storm的具体配置</span></h2><p>安装了<code>storm</code>，调整了命令行，同时也搞定了<code>ffmpeg.conf</code>，下面就是调整<code>storm</code>的配置文件了，<code>nimbus</code>和<code>supervisior</code>都要修改。</p><p>storm的配置文件叫<code>storm.yaml</code>，路径位于<code>storm</code>文件夹下的<code>/conf/</code>文件夹，我们需要在这个文件里面输入如下的内容：<br><img src="/images/storm3.png" alt="paradin"></p><p>下面对配置文件作一个简单的解释：<br>1）storm.zookeeper.port:zk的默认端口2181；<br>2）storm.cluster.mode:storm的集群运行模式，这里我们也是采用默认的distributed（分布式）；<br>3）storm.local.dir:storm使用的本地文件的目录，这个目录必须存在而且storm进程可读写；<br>4）supervisor.slots.ports：这个地方在nimbus里可以不用管，但是在supervisior里是需要改的，如果你只打开6700，那么就只放开了6700端口，即只有一个worker，如果你打开了6700、6701、6702三个端口，那么就意味这个supervisior将有三个worker在工作，由于这次试验里我们每一个supervisor只开启一个任务，所以在supervisior的storm.yaml里这个节点就只保留6700，其他的就全部注释掉；<br>5）nimbus.task.launch.secs:task启动时的一个特殊超时设置.在启动后第一次心跳前会使用该值来临时替代nimbus.task.timeout.secs；<br>6）worker.childopts:设定每个worker (JVM任务)的最小和最大内存；</p><p>更改完了<code>storm.yaml</code>之后，就要在<code>nimbus</code>里面安装<code>zkclient</code>。直接复制粘贴过来就好了。</p><p>如果你不喜欢<code>storm</code>自带的日志格式，想更改一下日志的内容，那么就要在<code>/storm/apache-storm-1.0.2/log4j2</code>文件夹里面修改<code>worker.xml</code>，不过在这里善意的提醒，最好在修改之前先备份原有的<code>worker.xml</code>。</p><h2><span id="连接具体任务">连接具体任务</span></h2><p>这次的实验包用的是我所在的公司开发内部使用的包，先把这个包的内容复制到<code>/storm/</code>文件夹下，同时<code>mkdir install</code>和<code>makir properties</code>这两个文件夹，在<code>install</code>文件夹里有开发写的任务的<code>jar</code>包和启动程序，如下：<br><img src="/images/storm4.png" alt="paradin"></p><p>而在<code>properties</code>文件夹里，应该有这个任务的配置文件，如下：<br><img src="/images/storm5.png" alt="paradin"></p><p>由于我们已经事前在<code>/etc/hosts</code>里指定了zkclient需要访问的zk的ip地址了，那么如果zk项配置正确，zkclient这个时候是可以成功启动的。同时在<code>install</code>文件夹里<code>./update_stormserver_config.sh</code>也应该是反应正确的。</p><p>然后我们就可以启动storm了。</p><h2><span id="启动nimbus和supervision">启动nimbus和supervision</span></h2><p>启动<code>storm</code>要先启动<code>nimbus</code>，在<code>/storm/apache-storm-1.0.2/bin</code>里面启动<code>run_nimbus.sh</code>，然后等一下会有一大片东西出现，再<code>jps</code>一下就能看到<code>nimbus</code>已经启动了，如图：<br><img src="/images/storm6.png" alt="paradin"></p><p>从上图我们可以看到，18141的进程就是<code>zkclient</code>，只不过在<code>jps</code>里它名字叫<code>AppServerDaemon</code>，而<code>zkServer</code>在<code>jps</code>里叫<code>QuorumPeerMain</code>。</p><p>如果 <code>storm</code>出现<code>Did you specify a valid list of nimbus hosts for config nimbus.seeds?</code>的错误提示，那么就是<code>nimbus</code>没有启动的缘故。</p><p>启动了<code>nimbus</code>之后，就可以在<code>supervisor</code>的机器里去效仿着启动<code>supervisor</code>，但是这里要注意，如果你开启了一个<code>supervisior</code>，那么按照我们上面的配置文件，就启动了一个6700端口的<code>worker</code>，这个时候在<code>nimbus</code>执行下派一个任务的命令，<code>nimbus</code>就会下派这个任务给这个<code>worker</code>。</p><p>下派命令的例子如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">storm jar storm-starter<span class="number">-0.9</span><span class="number">.2</span>-incubating-jar-<span class="keyword">with</span>-dependencies.jar com.lechange.recordshare.RecordShareTopology <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>这样就启动了一个叫<code>videoshare</code>的任务，这个任务只用1个<code>worker</code>。</p><p>如果在命令行里反馈这样的错误：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Error</span>: Could not find or load main <span class="class"><span class="keyword">class</span> <span class="title">storm</span>.<span class="title">starter</span>.<span class="title">recordshare</span>.<span class="title">RecordShareTopology</span></span></span><br></pre></td></tr></table></figure></p><p>或者<code>exception in thread main java.lang.NoClassDefFoundError</code>这样的错误，那就要检查jar包和路径。</p><p>而如果你再打开一个<code>supervisor</code>，在<code>nimbus</code>端又下发了一个任务，那么这个任务就会给刚刚新启动的<code>supervisor</code>。这样，启动一个下发一个，就会对每一个<code>worker</code>具体干的任务情况有一个比较清晰的了解。<br><img src="/images/storm7.png" alt="paradin"></p><p>在nimbus上执行<code>storm list</code>，就可以获得上图的样子，可以看出，我在nimbus端下发了三个任务，就是<code>topology_name</code>这一栏，他们的状态也是<code>active</code>，而<code>workers</code>数量都是1，也就是说在那三台<code>supervisor</code>里都在工作。而跑到<code>supervisor</code>一看日志，也是对应有各自的任务日志。</p><p>至此整个storm和具体的模块工作的搭建就完成了。</p><h2><span id="补充">补充</span></h2><p>如果你事前一口气把三个<code>supervisor</code>都打开了，即开启了3个<code>worker</code>，然后一口气在<code>nimbus</code>端，一口气输入了三个下发任务的命令，那么这三个命令会随机的到这三个<code>worker</code>里，没有任何顺序而言，你只能通过日志的关键词来判断具体的<code>worker</code>做哪些任务。</p><p>而如果你的worker数量少于<code>nimbus</code>下发任务的数量，会有什么反应呢？</p><p>答案就是任务根本没有<code>worker</code>去干，在<code>storm list</code>里，多余的任务对应的<code>num_workers</code>的数字是0，而如果这个时候你新增一个<code>supervisor</code>到这个<code>storm</code>集群，那么这个任务就会吭哧吭哧开始工作了。</p>]]></content>
    
    <summary type="html">
    
      杭州终于要有一点春天的温暖了
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="大数据分析" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
      <category term="storm" scheme="http://yoursite.com/tags/storm/"/>
    
  </entry>
  
  <entry>
    <title>DockerFile创建一个nginx容器的全过程</title>
    <link href="http://yoursite.com/2018/02/25/DockerFile%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAnginx%E5%AE%B9%E5%99%A8%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/02/25/DockerFile创建一个nginx容器的全过程/</id>
    <published>2018-02-25T11:54:34.000Z</published>
    <updated>2018-02-25T12:09:17.094Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="创建容器">创建容器</span></h2><p>首先，随便建立一个文件夹，比如先<code>mkdir sample</code>，然后我在这个sample文件夹里建立一个<code>Dockerfile</code>，内容如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:<span class="number">14.04</span></span><br><span class="line">MAINTAINER Chris Chan <span class="string">"chenx1242@163.com"</span></span><br><span class="line">ENV REFRESHED_AT <span class="number">2016</span><span class="number">-12</span><span class="number">-05</span></span><br><span class="line">RUN apt-get -y update &amp;&amp; apt-get install -y nginx</span><br><span class="line">RUN mkdir -p /<span class="keyword">var</span>/www/html/website</span><br><span class="line">ADD nginx/global.conf /etc/nginx/conf.d/</span><br><span class="line">ADD nginx/nginx.conf /etc/nginx/nginx.conf</span><br><span class="line">EXPOSE <span class="number">80</span></span><br></pre></td></tr></table></figure></p><p>从这个Dockfile里面看出：我们使用了ubuntu的基础镜像，然后下载了nginx，同时建立一个<code>/var/www/html/website</code>文件夹，然后又拷贝了宿主机上的两个文件，一个是<code>global.conf</code>，另一个是<code>nginx.conf</code>，这两个文件需要我们自己写。于是我们就要在sample下再建立一个叫nginx的文件夹，里面写上这两个文件，其中<code>global.conf</code>的内容如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">       listen   <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">80</span>;</span><br><span class="line">       server_name     _;</span><br><span class="line">       root    /<span class="keyword">var</span>/www/html/website;</span><br><span class="line">       index   index.html index.htm;</span><br><span class="line">       access_log      /<span class="keyword">var</span>/log/nginx/default_access.log;</span><br><span class="line">       error_log       /<span class="keyword">var</span>/log/nginx/default_error.log;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而<code>nginx.conf</code>的内容如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">user www-data;</span><br><span class="line">worker_processes <span class="number">4</span>;</span><br><span class="line">pid /run/nginx.pid;</span><br><span class="line">events &#123; &#125;</span><br><span class="line">http &#123;</span><br><span class="line"> sendfile on;</span><br><span class="line"> tcp_nopush on;</span><br><span class="line"> tcp_nodelay on;</span><br><span class="line"> keepalive_timeout <span class="number">65</span>;</span><br><span class="line"> types_hash_max_size <span class="number">2048</span>;</span><br><span class="line"> include /etc/nginx/mime.types;</span><br><span class="line"> default_type application/octet-stream;</span><br><span class="line"> access_log /<span class="keyword">var</span>/log/nginx/access.log;</span><br><span class="line"> error_log /<span class="keyword">var</span>/log/nginx/error.log;</span><br><span class="line"> gzip on;</span><br><span class="line"> gzip_disable <span class="string">"msie6"</span>;</span><br><span class="line"> include /etc/nginx/conf.d<span class="comment">/*.conf;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure></p><p>全部搞定之后，我们就来build这个镜像，比如这个镜像名叫做<code>chentest/nginx001</code>，在sample文件夹里使用的命令语句就是：<code>docker build -t=&#39;chentest/nginx001&#39; .</code>。</p><p>一顿七七八八之后，显示OK，<code>docker ps -a</code>就会显示我们新建的镜像，如图：<br><img src="/images/dockernginx1.png" alt="paradin"></p><p>有了镜像，再在sample文件夹里新增一个文件夹，比如就叫<code>webiste</code>，里面有一个文件叫<code>index.html</code>。而<code>index.html</code>的内容如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span> is a nginxtest page.</span><br></pre></td></tr></table></figure></p><p>保存退出之后，返回到sample目录。</p><p>现在我们可以制作一个容器了，制作容器命令是<code>docker run -d -p 8080:80 --name test02 -v $PWD/website:/var/www/html/website chentest/nginx001 nginx -g &quot;daemon off;&quot;</code>,这句话里规定容器的8080端口映射到宿主机的80端口，同时引入了当前目录的website目录到容器的<code>/var/www/html/website</code>目录，nginx也默认在前台进程进行。执行之后，<code>docker ps -a</code>看一下：<br><img src="/images/dockernginx2.png" alt="paradin"></p><p>看见port这一栏已经显示8080与80端口的相勾结成功，于是我们可以登录这台机器的80端口看一下。<br><img src="/images/dockernginx3.png" alt="paradin"></p><p>而如果现在我更改一下上面的<code>index.html</code>，改成另外一句话。比如说改成“why so serious??”,保存文件之后，直接刷新网页，就会看到网页的内容已经发生了变化，如图：<br><img src="/images/dockernginx4.png" alt="paradin"></p><p>可见引入<code>-v</code>这个命令在容器里，可以随时调试内容，而不是每次都要重新打包生成镜像。这一点再调试阶段为我们提供了很大的方便。</p><h2><span id="docker端口映射的问题">docker端口映射的问题</span></h2><p><code>docker run</code>命令里指定端口的格式是<code>-p 容器端口:宿主机端口</code>。如果想要随机指定就是大写的<code>P</code>。如图：<br><img src="/images/dockernginx5.png" alt="paradin"></p><p>这里就是随机分配了一个32775端口给宿主机，访问的时候也是要访问这个32775端口。</p><p>有时候port这里却不显示端口映射的情况，如图：<br><img src="/images/dockernginx6.png" alt="paradin"></p><p>这个情况是因为这个容器的status是<code>exited</code>，docker会在容器主进程结束后自动终止容器运行，而<code>nginx</code>启动后就会在后台运行，docker以为<code>nginx</code>已经结束运行了，所以就会停止容器。</p>]]></content>
    
    <summary type="html">
    
      中国共产党建议修改宪法，取消国家主席任期不得超过两届的规定。
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>DockerFile创建一个redis容器的全过程</title>
    <link href="http://yoursite.com/2018/02/25/DockerFile%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAredis%E5%AE%B9%E5%99%A8%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/02/25/DockerFile创建一个redis容器的全过程/</id>
    <published>2018-02-25T11:36:46.000Z</published>
    <updated>2018-02-25T11:47:14.380Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="正文">正文</span></h2><p>本次目标是用<code>Centos 7</code>的基础镜像做一个redis容器供开发人员在开发环境里蹂躏。</p><p>首先，创建一个叫<code>redis-test</code>的文件夹，在这个<code>redis-test</code>文件夹里建立一个<code>Dockerfile</code>，内容如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM centos:latest</span><br><span class="line">MAINTAINER Chris Chan <span class="string">"chenx1242@163.com"</span></span><br><span class="line">ENV REFRESHED_AT <span class="number">2017</span><span class="number">-02</span><span class="number">-16</span></span><br><span class="line">RUN yum -y update &amp;&amp;  yum -y install epel-release &amp;&amp; yum -y install redis &amp;&amp; yum -y install net-tools</span><br><span class="line">EXPOSE <span class="number">6379</span></span><br><span class="line">ENTRYPOINT [ <span class="string">"/usr/bin/redis-server"</span> ]</span><br><span class="line">CMD []</span><br></pre></td></tr></table></figure></p><p>这里我们简单说一下整个<code>Dockerfile</code>的内容：</p><p>首先选择了基础镜像是centos的最新版，即<code>centos 7</code>，然后填写作者信息；</p><p>在yum这一块要注意，如果没有安装<code>epel-release</code>的话，是无法正常安装redis的，这是centos与ubuntu不一样的地方。至于后面又补充安装了<code>net-tools</code>是因为<code>centos 7</code>里不自带<code>ifconfig</code>命令，所以需要安装一下<code>net-tools</code>，这样就有了<code>ifconfig</code>了；</p><p>随即我们又开放了<code>6379</code>端口；</p><p>然后就是<code>entrypoint</code>和<code>cmd</code>，这两个命令的区别很重要，具体区别请看：<a href="http://cloud.51cto.com/art/201411/457338.htm" target="_blank" rel="noopener">http://cloud.51cto.com/art/201411/457338.htm</a> 这篇文章。</p><p>然后我们就可以依照这个Dockfile去建立一个镜像，因为目的是要在“centos环境下建立一个redis”，那么我们这个镜像的名字就叫作<code>lccentos/redis</code>，具体操作就是在<code>redis-test</code>文件夹下执行<code>docker build -t lccentos/redis .</code>。</p><p>然后根据这个镜像需要制作一个容器，容器的名字就叫<code>redisforcentos</code>，那么命令就是：<code>docker run -d -p 6379 --name redisforcentos lccentos/redis</code>。</p><p>然后我们<code>docker ps -a</code>看一下效果，如下：<br><img src="/images/redisinfo2.png" alt="paradin"></p><p>可见宿主机的32774端口和容器的6379端口“融为一体”，这个时候，我们测试一下这个<code>redisforcento</code>s的容器是否已经正常启动了redis，如图：<br><img src="/images/redisinfo3.png" alt="paradin"></p><p>而且对于Docker来说，可以多个docker对应宿主机的同一个端口，比如我这台机器搞了两个redis，两个容器都可以指向6379的端口，如图：<br><img src="/images/redisinfo4.png" alt="paradin"></p><h2><span id="dockerfile的优化原则">Dockerfile的优化原则</span></h2><p>1）ADD和VOLUME应该放在Dockerfile底部，因为它们相对比yum安装那些变化的更勤；<br>2）EXPOSE可以一口气对应多个端口，比如<code>EXPOSE 80 2003 2004 7002</code>的效果跟下面的效果一样；<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE <span class="number">80</span> </span><br><span class="line">EXPOSE <span class="number">2003</span> </span><br><span class="line">EXPOSE <span class="number">2004</span> </span><br><span class="line">EXPOSE <span class="number">7002</span></span><br></pre></td></tr></table></figure></p><p>3）<code>ADD</code>的操作应该放在<code>Dockerfile</code>的最下面；</p><h2><span id="参考资料">参考资料</span></h2><p><a href="http://dockone.io/article/255?spm=5176.100239.blogcont40494.25.8RXqDX" target="_blank" rel="noopener">http://dockone.io/article/255?spm=5176.100239.blogcont40494.25.8RXqDX</a></p>]]></content>
    
    <summary type="html">
    
      用这个dockerfile作为模板，以后就在这个基础上拓展
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>阿里云获取DTS服务延迟值的脚本</title>
    <link href="http://yoursite.com/2018/02/24/%E9%98%BF%E9%87%8C%E4%BA%91%E8%8E%B7%E5%8F%96DTS%E6%9C%8D%E5%8A%A1%E5%BB%B6%E8%BF%9F%E7%9A%84%E8%84%9A%E6%9C%AC/"/>
    <id>http://yoursite.com/2018/02/24/阿里云获取DTS服务延迟的脚本/</id>
    <published>2018-02-24T08:49:31.000Z</published>
    <updated>2018-03-05T16:42:54.583Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="正文">正文</span></h2><p>春节“嗖”的一下就过完了，在年前领导交代另一个任务，想要每天统计一下在阿里云DTS（数据同步）服务的延迟情况，于是我就要使用阿里云的api去写一个脚本，每小时运行一次，然后将这24个数字输出出来给领导过目。</p><p>阿里云dts的sdk包在这里：<a href="https://help.aliyun.com/document_detail/57694.html?spm=a2c4g.11186623.6.675.W811bN" target="_blank" rel="noopener">https://help.aliyun.com/document_detail/57694.html?spm=a2c4g.11186623.6.675.W811bN</a> ，直接点击<code>Python</code>下载即可，不过这个地址经我测试使用非国内IP 地址是打不开的，需要使用国内IP地址下载。</p><p>下载完毕之后，上传到linux服务器并解压，解压后的样子如图：<br><img src="/images/dts1.png" alt="paradin"></p><p>由于我们这次只是查看同步作业状态，所用的py就是<code>DescribeSynchronizationJobStatusRequest.py</code>，现在我们就可以写脚本，假设这个脚本叫<code>getDTS.py</code>,那么整个内容如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line">#coding=utf-8</span><br><span class="line">#auther:ChrisChan@2018-2-24</span><br><span class="line">#这个脚本是用来获取DTS服务的延迟值</span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore <span class="keyword">import</span> client</span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore.acs_exception.exceptions <span class="keyword">import</span> ClientException</span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore.acs_exception.exceptions <span class="keyword">import</span> ServerException</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line">import sys#由于这个包不是通过pip install的方式安装,要调用其它路径的python脚本就要使用sys方法</span><br><span class="line">sys.path.append(<span class="string">'sdk压缩包的绝对路径'</span>)</span><br><span class="line"><span class="keyword">import</span> DescribeSynchronizationJobStatusRequest</span><br><span class="line"></span><br><span class="line"># 创建Client实例</span><br><span class="line">clt = client.AcsClient(<span class="string">'阿里云AK'</span>,<span class="string">'阿里云SK'</span>,<span class="string">'所属地域'</span>)</span><br><span class="line"></span><br><span class="line"># 创建request并设置参数</span><br><span class="line">request = DescribeSynchronizationJobStatusRequest.DescribeSynchronizationJobStatusRequest()</span><br><span class="line">request.set_accept_format(<span class="string">'json'</span>)</span><br><span class="line"></span><br><span class="line"># 写上对应的服务ID</span><br><span class="line">request.set_SynchronizationJobId(<span class="string">"这里写上DTS的ID"</span>)</span><br><span class="line"></span><br><span class="line">response = clt.do_action_with_exception(request)</span><br><span class="line">print response</span><br><span class="line">delay = json.loads(response)</span><br><span class="line">print <span class="string">"===================================================="</span></span><br><span class="line">print <span class="string">"当前延迟是："</span> + str(delay[<span class="string">"DataSynchronizationStatus"</span>][<span class="string">"Delay"</span>])</span><br><span class="line">print <span class="string">"当前同步速度是："</span> + str(delay[<span class="string">"Performance"</span>][<span class="string">"FLOW"</span>])</span><br></pre></td></tr></table></figure></p><p>整个脚本执行的效果如下：<br><img src="/images/dts2.png" alt="paradin"></p><p>dts的延迟时间是5秒计算一次，API请求会取到最新的延迟时间，控制台是每隔20秒才刷新一次。</p><h2><span id="补充">补充</span></h2><p><code>getDTS.py</code>这个脚本获取到的<code>response</code>是一个str字符串，这里我使用<code>json.loads</code>来将其转化成了<code>dict</code>模式。但是除了这个方法还有两个方法：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; user</span><br><span class="line"><span class="string">"&#123;'name' : 'jim', 'sex' : 'male', 'age': 18&#125;"</span></span><br><span class="line">&gt;&gt;&gt; b=<span class="built_in">eval</span>(user)</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">&#123;<span class="string">'age'</span>: <span class="number">18</span>, <span class="string">'name'</span>: <span class="string">'jim'</span>, <span class="string">'sex'</span>: <span class="string">'male'</span>&#125;</span><br><span class="line">&gt;&gt;&gt; print b[<span class="string">'sex'</span>]</span><br><span class="line">male</span><br><span class="line">&gt;&gt;&gt; exec(<span class="string">"c="</span>+user)</span><br><span class="line">&gt;&gt;&gt; c</span><br><span class="line">&#123;<span class="string">'age'</span>: <span class="number">18</span>, <span class="string">'name'</span>: <span class="string">'jim'</span>, <span class="string">'sex'</span>: <span class="string">'male'</span>&#125;</span><br><span class="line">&gt;&gt;&gt; print c[<span class="string">'name'</span>]</span><br><span class="line">jim</span><br></pre></td></tr></table></figure></p><font color="red">但是要注意！上面这两个方法有一定的安全隐患，而且只能全是字符串可用，如果有的<code>value</code>是<code>True</code>、<code>False</code>、<code>Null</code>这样的字眼的话，<code>eval</code>是不支持的，所以没法正确转换，就会爆这样的错：<code>NameError: name &#39;True&#39; is not defined</code>。</font><h2><span id="参考资料">参考资料</span></h2><p><a href="https://help.aliyun.com/document_detail/49453.html?spm=a2c4g.11186623.6.667.sRyVqY" target="_blank" rel="noopener">https://help.aliyun.com/document_detail/49453.html?spm=a2c4g.11186623.6.667.sRyVqY</a><br><a href="https://segmentfault.com/q/1010000000174694" target="_blank" rel="noopener">https://segmentfault.com/q/1010000000174694</a><br><a href="https://www.crifan.com/resolved_in_python_using_eval_to_force_variable_to_convert_a_string_to_a_dictionary_when_the_error_nameerror_name_39null39_is_not_defined/" target="_blank" rel="noopener">https://www.crifan.com/resolved_in_python_using_eval_to_force_variable_to_convert_a_string_to_a_dictionary_when_the_error_nameerror_name_39null39_is_not_defined/</a><br><a href="https://segmentfault.com/q/1010000000345915" target="_blank" rel="noopener">https://segmentfault.com/q/1010000000345915</a><br><img src="/images/suyaleisi.jpg" alt="paradin" title="状态越来越好~"></p>]]></content>
    
    <summary type="html">
    
      先获取到值，然后做出来一个图。
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="阿里云" scheme="http://yoursite.com/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>Atlas的几种常见故障解决方法</title>
    <link href="http://yoursite.com/2018/02/23/Atlas%E7%9A%84%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2018/02/23/Atlas的几种常见故障解决方法/</id>
    <published>2018-02-23T13:39:43.000Z</published>
    <updated>2018-02-24T10:59:54.346Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="使用atlas却发现读库闲置框架还是去主库读写数据"><font color="red">使用atlas却发现“读库闲置，框架还是去主库读写数据”</font></span></h2><p>配置完atlas之后，发现使用<code>jdbc</code>框架的话，读库和写库各司其职，但是使用<code>mybatis</code>框架之后，就发现框架的读写都去了主库，把读库放置一边，那么这种情况是因为<code>有事务存在的话，atlas就会强制走主库</code>，遇到这种情况就检查一下是否有事务的存在，比如<code>@Transactional</code>，如果要解决的话，就加上<code>@Transactional(propagation=Propagation.NOT_SUPPORTED)</code>即可。<br><img src="/images/atlas13.png" alt="paradin"></p><h2><span id="自动读写分离挺好但有时候我写完马上就想读万一主从同步延迟怎么办"><font color="red">自动读写分离挺好，但有时候我写完马上就想读，万一主从同步延迟怎么办?</font></span></h2><p>SQL语句前增加 <code>/*master*/</code> 就可以将读请求强制发往主库。在mysql命令行测试该功能时，需要加<code>-c</code>选项，以防mysql客户端过滤掉注释信息。不过这不能从本质上解决问题，使用Atlas需要考虑到这点，提高主机的IO性能，加大memory可以缓解延迟症状，但依旧不能避免延迟的出现，尤其是读多写少的应用。</p><h2><span id="resource-limit的问题"><font color="red"><code>resource limit</code>的问题</font></span></h2><p>atlas有自己的连接池，会吃掉很多CPU, <code>php</code>应用端改用短链接来连接atlas, 这时候atlas对<code>php</code>发送来的sql只负责验证和转发的操作，后端DB的连接由atlas自己管理,未使用的连接线程进行剔除操作(DB的wait_timeout和interactive_timeout设置为300s,超时亦退出)。</p><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2014</span><span class="number">-04</span><span class="number">-12</span> <span class="number">20</span>:<span class="number">56</span>:<span class="number">29</span>: (warning) (libevent) event_del: event has no event_base set.</span><br><span class="line"><span class="number">2014</span><span class="number">-04</span><span class="number">-12</span> <span class="number">20</span>:<span class="number">56</span>:<span class="number">29</span>: (critical) last message repeated <span class="number">5</span> times</span><br><span class="line"><span class="number">2014</span><span class="number">-04</span><span class="number">-12</span> <span class="number">20</span>:<span class="number">56</span>:<span class="number">29</span>: (critical) network-conn-pool-lua.c<span class="number">.144</span>: socket() failed: Too many open files (<span class="number">24</span>)</span><br><span class="line"><span class="number">2014</span><span class="number">-04</span><span class="number">-12</span> <span class="number">20</span>:<span class="number">56</span>:<span class="number">29</span>: (warning) (libevent) event_del: event has no event_base set.</span><br><span class="line"><span class="number">2014</span><span class="number">-04</span><span class="number">-12</span> <span class="number">20</span>:<span class="number">56</span>:<span class="number">30</span>: (debug) chassis-unix-daemon.c:<span class="number">168</span>: <span class="number">12951</span> returned: <span class="number">12951</span></span><br><span class="line"><span class="number">2014</span><span class="number">-04</span><span class="number">-12</span> <span class="number">20</span>:<span class="number">56</span>:<span class="number">30</span>: (critical) chassis-unix-daemon.c:<span class="number">196</span>: [angel] PID=<span class="number">12951</span> died on signal=<span class="number">11</span> (it used <span class="number">16</span> kBytes max) ... waiting <span class="number">3</span>min before restart</span><br></pre></td></tr></table></figure></code></pre><p>如果MySQL后端的连接数也满了可能会报以下错误:</p><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2014</span><span class="number">-11</span><span class="number">-13</span> <span class="number">12</span>:<span class="number">21</span>:<span class="number">07</span>: (critical) network_mysqld_proto_password_scramble: assertion <span class="string">`20 == challenge_len' failed</span></span><br><span class="line"><span class="string">2014-11-13 12:21:07: (warning) (libevent) event_del: event has no event_base set.</span></span><br><span class="line"><span class="string">2014-11-13 12:21:07: (critical)</span></span><br></pre></td></tr></table></figure></code></pre><p>可以临时增加MySQL connection数量:</p><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo -n “Max processes=SOFT_LIMIT:HARD_LIMIT” &gt; <span class="regexp">/proc/</span><span class="string">`pidof mysqld`</span>/limits</span><br></pre></td></tr></table></figure></code></pre><h2><span id="出现too-many-open-files的错误怎么办"><font color="red">出现<code>Too many open files</code>的错误，怎么办？</font></span></h2><p>关于<code>Too many open files</code>错误，可能由两种情况引起:<br>一、php长连接连接到atlas后，每个线程占用一个FD,直到超出系统资源限制而出现too many错误;<br>二、php应用端发送到atlas的sql过多，大量并发的情况下,linevent维护的队列过多，每个event吃一个FD，超出系统资源限制引起<code>Too many open files</code>错误;</p><p>避免<code>Too many open files</code>错误,增加用户的ulimit值加大<code>FD</code>的使用量,可增加系统ulimit资源到 <code>~/.bash_profile</code>文件或<code>/etc/security/limits.conf</code>文件:</p><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># cat .bash_profile </span><br><span class="line"># .bash_profile</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="keyword">export</span> PATH</span><br><span class="line">ulimit -n <span class="number">16384</span></span><br></pre></td></tr></table></figure></code></pre>]]></content>
    
    <summary type="html">
    
      一口气连看17集《大明王朝1566》
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="atlas" scheme="http://yoursite.com/tags/atlas/"/>
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>如何手动释放linux内存</title>
    <link href="http://yoursite.com/2018/02/23/%E5%A6%82%E4%BD%95%E6%89%8B%E5%8A%A8%E9%87%8A%E6%94%BElinux%E5%86%85%E5%AD%98/"/>
    <id>http://yoursite.com/2018/02/23/如何手动释放linux内存/</id>
    <published>2018-02-23T12:57:35.000Z</published>
    <updated>2018-02-23T13:13:55.869Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>在生产过程中，一些java模块会比较残忍的吃系统内存，然后如果这个模块写的比较挫，产生的垃圾就会比较多，如果linux系统的内存释放也不会及时，然后恶性循环，最后就把进程卡死，但是服务器是不可以down机的，所以这个时候就需要我们运维出来，手动的释放内存。</p><p>首先，我们登陆一台服务器，<code>free -m</code>看一下目前的情况：<br><img src="/images/neicun1.png" alt="paradin"></p><p>然后<code>cat /proc/sys/vm/drop_caches</code>，会看到里面的值是0，0是不释放的意思。</p><p><code>sync</code>,将系统缓存区中的脏数据写入磁盘中，包括已修改的i-node、已延迟的块I/O和读写映射文件。</p><p><code>echo 3 &gt; /proc/sys/vm/drop_caches</code></p><p>为什么这里是<code>3</code>呢？这是因为<code>echo 1</code>的话代表“清理页面缓存”，<code>echo 2</code>的话代表“清理索引节点（inode）链接”，<code>echo 3</code>就是包括上面两者。</p><p><code>sysctl -p</code>,这样不用重启服务器也可以生效。出现下面的一连串文字之后，再<code>free -m</code>看一下：<br><img src="/images/neicun2.png" alt="paradin"></p><p>从112释放到2790，可见效果立竿见影。</p><p>上面整个过程的自动化脚本是这样的：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">#Author:Chris Chan</span><br><span class="line">#E-mail:chen_shuo@dahuatech.com</span><br><span class="line">oldmemory=$(free -m|sed -n <span class="string">'2p'</span>|awk <span class="string">'&#123;printf $4&#125;'</span>)</span><br><span class="line">echo <span class="string">"开始的空余内存值："</span>$oldmemory</span><br><span class="line">sync</span><br><span class="line">echo <span class="number">3</span> &gt; <span class="regexp">/proc/</span>sys/vm/drop_caches</span><br><span class="line">sysctl -p</span><br><span class="line">correctmemory=$(free -m|sed -n <span class="string">'2p'</span>|awk <span class="string">'&#123;printf $4&#125;'</span>)</span><br><span class="line">echo <span class="string">"释放完后的空余内存值："</span>$correctmemory</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      这里释放的内存主要是缓存的内存
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>回家过年</title>
    <link href="http://yoursite.com/2018/02/21/%E5%9B%9E%E5%AE%B6/"/>
    <id>http://yoursite.com/2018/02/21/回家/</id>
    <published>2018-02-21T08:08:40.000Z</published>
    <updated>2018-02-22T14:07:36.532Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>我承认我是一个很恋家的人，但是我在3年之前还不是这样。</p><p>我记得我在哈尔滨上大学的时候，虽然坐火车也就一个半小时的时间，但是是“能不回家就不回家”，哪怕自己一个人蹲在寝室也是自由舒服，后来上班，我也是有很长的时间自己独住，只有周末才回去一次。那时候我奶不止一次的批评我“都快成一个客人了”。</p><p>真的应了那句传烂了的话“只有失去的才是美好的”，现在我人在杭州，天天忙成狗。最欢喜的事情第一个是涨工资，第二个是发工资，第三个是放假，第四个就是放假回家。当初的我总是忽略家庭的温暖，在家里逗留的时间不长，现在却倍感珍惜回家的机会，唉，那几年真是简单的可笑。<br><img src="/images/jia5.jpg" alt="paradin"></p><p>这一次回家过年看到了许许多多亲人：生病的大姨夫的精神状态也好了许多，不过他这次回来又害了一次发烧；小外甥和他那婴儿肥的脸蛋，在《守望先锋》里越死越勇；我那几个弟弟们全都瘦了也更精神了，从我妈和女票看我的眼神里，我觉得我的体重是应该好好管控一下了：体型太腐败。</p><p>短短的六天时间，吃完三姨家吃四姨家，吃完老叔家吃小舅家，总之就是带着女票游走于各种亲戚家。中途还抽空跟龙南数据班的几个老同事一起吃了顿“一口猪”，主要也是带我女票看看东北菜，看上去我这几个老同事们都过得很不错，至少几杯酒下去均红光满面，依旧插科打屁、大呼小叫。这次过年唯一可惜的是，没有给四姨夫装上翻墙软件，害得他要继续挠墙忍耐。</p><p>我吃我妈的菜已经吃了30年，但是这次过年真正在家里吃饭仅仅只有一顿。我妈烧了虾，做了孜然羊肉，而且煮了酸菜馅饺子。这都是我爱吃的，杭州的确能吃到很多美味，但我妈的手艺却是独一份儿。我跟我爹依旧话不算多，但是关系却比之前好了许多倍。有可能是我现在比以前有了一点进步，让我爸看起来顺眼了一点，这一次回家没有跟我爸单独喝上酒，但是他有几顿喝的很开心。看到他俩这个年过得快乐满足，我这个做儿子的，心底涌起了最大的温暖。</p><p>离开家的时候，依旧是箱子沉沉，里面有爸妈装的许多东西，有给我的也有给我女票她妈的，每一个东西都是代表了他们的心思。其实家中长辈身体健康、心情愉悦，就是给我们这些在外的儿女最大的宽慰了。假期就这样结束了，我也马上要踏上回杭州的航班，希望家里所有长辈都平平安安，也希望我今年能够达到自己给自己定下的目标！<br><img src="/images/quanjiafu.jpg" alt="paradin"></p>]]></content>
    
    <summary type="html">
    
      最期盼的假期，已经余额不足了...
    
    </summary>
    
      <category term="坠乱花天" scheme="http://yoursite.com/categories/%E5%9D%A0%E4%B9%B1%E8%8A%B1%E5%A4%A9/"/>
    
    
      <category term="春节" scheme="http://yoursite.com/tags/%E6%98%A5%E8%8A%82/"/>
    
      <category term="心情" scheme="http://yoursite.com/tags/%E5%BF%83%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>中国梦，宪政梦</title>
    <link href="http://yoursite.com/2018/02/13/%E4%B8%AD%E5%9B%BD%E6%A2%A6%EF%BC%8C%E5%AE%AA%E6%94%BF%E6%A2%A6/"/>
    <id>http://yoursite.com/2018/02/13/中国梦，宪政梦/</id>
    <published>2018-02-12T17:00:57.000Z</published>
    <updated>2018-02-13T04:26:08.912Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p><strong>本文原作者：《南方周末》评论部编辑戴志勇</strong></p><p>天地之间，时间绽放。</p><p>这是我们在2013年的第一次相见，愿你被梦想点亮。</p><p>2012年，你守护自己的生活，他们守护自己的工作。守护这份工作，就是在守护他们对生活的梦想。</p><p>2012年，庙堂之上发出的宪政强音嗡然回响：”宪法的生命在于实施，宪法的权威也在于实施。”我们期待宪法长出牙齿，宪政早日落地。惟如此，才能成就这个沧桑古国的艰难转型；惟如此，国家与人民，才能重新站立于坚实的大地之上。</p><p>今天，已是能够梦想的中国，今天，已是兑现梦想的时代。经历过宪政缺失的”文革”梦魇，我们花费三十多年的时间来逐渐回归常理与常情。从土地联产承包责任制到个体户、乡镇企业到”民企”，稍稍归还国人自主安排生活的权利，我们便创造了繁华城市，收获了满仓粮食。</p><p>我们重新体认什么是真，什么是假，是其是，非其非；我们重燃对公义的热爱，对自由的向往。面对暴虐强力，我们双手相握，一起走过艰难时刻，迎接生活转机。</p><p>今天，我们终于可以从厚厚的历史尘埃中挺起胸，从琐碎的日常生活中抬起头，重走先辈的宪政长征，重温先辈的伟大梦想。</p><p>一百七十多年前，我们开始从天朝上国的迷梦中醒来。先败于英，后败于日。百姓愈加民不聊生，耻感深深刺痛中国士人。保国！保种！由洋务而君宪，由立宪而革命。从器物到制度再至文化，激愤者不惜彻底打倒”孔家店”，决绝地将自己的文明连根拔起。</p><p>辛亥革命后，清帝退位，先辈们终于建立了亚洲第一个共和国。但是，一个自由、民主、富强的宪政中国并没有随之而来。</p><p>国家内外，战争连连；人群内外，残酷不断。</p><p>一度，人们远离仁，远离义，远离天道，远离对自由的坚守。</p><p>一度，人们认错为对，指鹿为马，万千生灵生机断绝。</p><p>美梦与山河，齐齐破碎。自由与宪政，双双消隐。</p><p>度尽人世劫波，深味人性幽暗，我们依然是能做梦的人，有颗能做梦的心。</p><p>今天，我们断断不只梦想物质丰盛，更希望性灵充盈；我们断断不只梦想国力能强盛，更希望国民有自尊。新民和新国，救亡与启蒙，谁也离不开谁，谁也不能压倒谁。而宪政便是这一切美梦的根基。</p><p>兑现宪政，坚守权利，人人才能心如日月流光溢彩；鳏寡孤独才能感受冬日暖意而非瑟瑟发抖；”城管”与小贩才能谈笑风生；房屋才能成为自己与家人的城堡；</p><p>兑现宪政，限权分权，公民们才能大声说出对公权力的批评；每个人才能依内心信仰自由生活；我们才能建成一个自由的强大国家。</p><p>兑现宪政大梦，每个人才能做好个人的美梦。而这需要我们就从手边做起，就从守护此时此刻的生活做起，而不要将重任留给子孙。</p><p>很多人一直深深懂得这一点，很多人早就努力践行这一点。</p><p>不是杰出者才做梦，是善于做梦者才杰出。</p><p>你的天赋权利就是可以梦想，并且兑现梦想！</p><p>为你的梦想鼓掌，为这个国家的梦想加油，这就是很多新闻人的梦想，是他们不大不小的野心。他们忠于新闻，更忠于内心。愿你也有个玫瑰色的美梦；自由成就自己，完成天之所赋。</p><p>总会梦想人人都可以做一个有尊严的人，不论身居高位，还是街头卖艺；</p><p>总会梦想人人内心有爱，即使罪犯也未必穷凶极恶，总有恻隐之心自由闪动；</p><p>总会梦想阶层只是引人自由流动的动力，而不再是相互猜忌和仇视的天堑；总会梦想这五千年文明生生不息，为改善人类的现代处境，捧出一掬甘冽清泉……</p><p>兑现这一千一万个梦想，才能抚平这一百多年的刻骨痛楚。</p><p>兜兜转转一百七十年，美梦成真何其难！一百七十年后，依然有人渴望良知萌新芽，重温天命之谓性；依然有人坚持要求权利一一落地，政治复归于正，公义自在流淌。</p><p>依然有人相信，不管多难，梦想终会落实为宪政良制，风行为敦敦美俗。</p><p>先辈们筚路蓝缕，践义成仁。如今，后人承继其志，燃灯前行。</p><p>兑现梦想，自然要借鉴前贤智慧，与古人的信仰、习俗和情感和解。儒释道法墨，百家皆是源泉；周汉唐宋明，代代皆有可取。</p><p>但这决不是要复古，古人不能给予今天所需的一切。只是不再轻易贬损先辈，平心静气地吸收转进，以让中华文明开新花，结新果。</p><p>兑现梦想，自然要吸取世界经验。所以要认真审视希腊民主，罗马法治，借鉴英美宪政，追赶现代科技文明。</p><p>但这也不是仅仅作一个西方文明的优等生，西人有西人演进的轨迹，同样未必能直接给予我们今天所需的一切。</p><p>我们要站在自己的大地上，与各国人民一起，生活出一种古今相融的新生活，文明出一种中西合璧的新文明。在古今中西的激荡中，要遵循人类共通的价值，也要不惮于做自己的新梦。</p><p>称美古人，赞扬邻居，不是因为他们足够完美，而是因为我们熟悉他们眼中洋溢的快乐，心底流淌的自由。</p><p>中国人本应就是自由人。中国梦本应就是宪政梦。</p><p>宪政之下，才能国家持续强盛，宪政之下，才有人民真正强大。兑现宪政梦想，才能更好地外争国权，维护国家的自由；才能更好地内争民权，维护人民的自由。而国家的自由最终必得落脚于人民的自由，必得落脚于人人可以我口说我心，人人可以用心做美梦。</p><p>生而为人，谁能不热爱自由？这自由，不仅是权利针对权力而言，也是宽恕针对报复而言，是般若针对无明而言，是仁爱针对暴虐而言，是有道针对无道而言。</p><p>大道之行，天下为公；万物自在，各正性命。这就是古人的梦想，先辈的梦想，也是今天很多人的梦想。</p><p>中国梦，自由梦，宪政梦。</p><p>万物速朽，但梦想永在。万物诞生，因梦想不灭。梦想就是生生之几，就是当你失败了一百次，那第一百零一次充实你内心的不死之希望。</p><p>依然有人倾听你的梦想，期待你敢于做梦。你从苦难中爬起，他们为你加油；你尝尽人世冷暖，他们为你加油；你收获美好生活，他们为你加油……他们别无所资，惟有对梦想的执着；他们别无所长，惟有对真相的追求。</p><p>一句真话能比整个世界还重，一个梦想能让生命迸射光芒！</p>]]></content>
    
    <summary type="html">
    
      谨以此文纪念“南方周末事件”
    
    </summary>
    
      <category term="坠乱花天" scheme="http://yoursite.com/categories/%E5%9D%A0%E4%B9%B1%E8%8A%B1%E5%A4%A9/"/>
    
    
      <category term="中国政治" scheme="http://yoursite.com/tags/%E4%B8%AD%E5%9B%BD%E6%94%BF%E6%B2%BB/"/>
    
  </entry>
  
</feed>
