<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chris Chan&#39;s BLOG</title>
  
  <subtitle>那些在阳光下挥洒青春的日子啊！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-02-03T17:39:25.630Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Chris Chan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2019年的个人读书总结</title>
    <link href="http://yoursite.com/2020/02/03/2019%E5%B9%B4%E7%9A%84%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/02/03/2019年的读书总结/</id>
    <published>2020-02-03T15:03:22.000Z</published>
    <updated>2020-02-03T17:39:25.630Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>整个2019年过去了，2020年也不算开了一个很好地头。于是这个年度回顾了也跟着来的晚了点。本文里就不扯那些事业上的进步blablabla的，重点说说我这一年读的书。<br><img src="/images/2019book.jpg" alt="akb48"></p><p>我尽量不去在文艺作品里批评作者的三观，因为所有脱离当时时代背景就说三观不正的行为都是耍流氓。</p><h2><span id="基督山伯爵">基督山伯爵</span></h2><p>说实话，这本书我是当爽文看的，里面对人物的描写走的是“三突出，高大全”的路线—-好人一颦一笑都好的洋溢，坏人无论做什么都是坏，而且特别的磕碜。</p><p>我本身就读外国书不多，一大主要原因是外国人名太长，看了后面忘了前面，要是都是“汤姆”、“约翰”、“史蒂芬”这样的还好。偏偏这本法国书里很多人的姓都是四五个字的，幸好整套书看下来设计的人物不算多，人与人的关系还算捋得清。尤其是艾德蒙-唐代斯，念出来的时候还挺有气势。</p><p>读过这本书的人太多了，我也不多做什么分析，各种大神都已经分析烂了，甚至不少大作家也有借鉴它的结构，比如金庸先生的《连城诀》。《基督山伯爵》就是一部剧情跌宕起伏的文学小说而已，现实意义哲学道理神马的的确没有那么多，它给人带来的就是阅读快感。里面很多的情话读起来肉麻的刚好，有一些人物的内心揣摩也很真实，比如检察官维尔福宽恕自己的想法：“如果发现世人都有罪，自己身上的负罪感就会减轻”。不过说来说去，我倒是觉得检察官全家死光的安排有点狠，而唐会计最后被宽恕了到有点轻。除此之外，我也想表达的是“复仇与创业一样，要保持热情和初心是挺难的”。</p><p>“等待与希望”，的确是对人来说很重要的两个事儿，厉害的人好像比普通的人就是多了那么一点点的耐心。</p><h2><span id="主角">主角</span></h2><p>《主角》这本书是我看《圆桌派》的时候，王蒙老先生提到的，于是就买了一本，《主角》是一本比较新的书，第一版是2018年1月。不过这部“茅盾文学奖”得主貌似并不受豆瓣青年的喜爱，我看了一下目前的得分是6.7分。在短评里很多人打出了三星以下的得分，我想主要原因就是作者把主人公忆秦娥写的太憋屈了，于是剧情党很是不满。</p><p>忆秦娥这个角色，让作者写的有点“小龙女+罗德曼”的味道，说她小龙女呢，是因为她长相美丽又不食人间烟火；说她罗德曼呢，是因为她跟罗德曼一样，靠磨炼技术去逃避自己对现实的不满。所以我想当作者安排她把处女之身给了刘红兵的时候，应该心里是比较波折的。其实开始我心里也是反对这门亲事，因为刘红兵虽然爹比较硬、家庭比较好、嘴巴会说，但是毕竟是一个毫无事业的人，而且性格也过于社会。但是作者这么安排我想也有他的良苦用心，第二部中期作者开始逐渐对刘红兵有了一些正面的描述，比如说他做了一手好面、人高马大、英俊帅气（就是后来被忆秦娥打掉一个门牙），合着除了业务能力不咋地之外，这人就没啥缺点了。他追忆秦娥追了一年多，用物质砸，用手段哄，拿出了“烈女怕缠男、打死不退”的劲儿。作者也锲而不舍的描述他有多么的体贴入微：忆秦娥在中南海因为表演吹火而下场吐了一地，刘红兵二话不说直接脱了外套，用衣服把呕吐物包起来又把地面收拾了。这个细节的确把我打动了，换成我，我估计我就做不出来。</p><p>整本书看完，忆秦娥除去了主角光环，她的人生和爱情悲剧成分居多，这跟她自己的成长经历有很大的关系，书里的安排也是符合现实的。她前半段人生欲扬先抑，靠着一股痴劲儿遇到了不少好伯乐来提升她的技术。但是她毕竟不喜读书，遇事自己没主意，更多的时候只会“手背捂着嘴”，自己本来就傻，还不喜欢别人说她傻。早期米兰给她一本字典，后来秦八娃也让她去买书看，但是她更想睡觉。再加上性格自卑孤僻圈子小，封潇潇一出局，周围除了一个死缠烂打的刘红兵也就没有几个适龄男子了。不选他选谁？</p><p>不过说实话啊，烈女与缠男的戏码，古往今来、艺术现实，基本都没有好结局，因为毕竟“强扭的瓜不甜”。缠男多半是图烈女的貌馋她的身子，他就是坚持100年也是为了多滚几次床单而不是特别图她的性格。一旦要了女子的身子，新鲜劲儿又过了，缠男自然就受不了烈女的脾气。忆秦娥是一个性冷淡，刘红兵出轨是再正常不过的安排。</p><p>诚然，同样是西北文学。《主角》的光辉跟《白鹿原》是没法比的。虽然故事基本都是发生在一个小圈子，也有男女之间的破鞋烂事儿。但是《白鹿原》的故事背景太大了，而且达到了从小孔窥大局的高度。而《主角》重心更多是描写京剧这门艺术、新老剧的冲突和封闭的剧团内部争风吃醋的现象。</p><h2><span id="长夜难明">长夜难明</span></h2><p>这本书我好像一下午就读完了，它不算是一本推理小说，更多的是一部反腐小说，作者也下了一番功夫在故事的曲折性和现实的映射中找平衡。从故事情节来看，很棒，很悲壮，把正义与腐败的斗争写的很真实，尤其是江阳按下按钮抛出公寓闭眼等死那一段，可以说是写的非常有画面感，让人不禁激动落泪。有时候我也在反思：人们茶余饭后吹的那些正邪斗争的牛逼，真实情况里付出的代价太沉重了。</p><p>当全世界都在阻挠你做一个正确的事情，还能有几个人坚持下去呢？</p><p>如果要说缺点，就是有些文笔比较粗糙和纸面化，感觉像是长篇纪实文学了。但是对司法体系和刑事程序的描写很真实。后来我也看了作者紫金陈的《谋杀官员》系列，个人最喜欢的是第一部徐策的故事。</p><p>中国14亿人口，每天出现的故事上千万。如果将来真的有一天取消了审查制度，我相信会有很多优秀感人的文艺作品问世的。</p><h2><span id="其他">其他</span></h2><p>至于其他的一些书，比如《论人类不平等的起源与基础》，《思考，快与慢》，《彷徨》，《逆境无赖—开司麻将篇》（漫画也算进来了…）这些书的感受不太容易马上写出来,这次就先不写了。最后我要补充一句，都说鲁迅杂文写的牛逼，但是他写景也是一绝。<br><img src="/images/科比强硬防守安东尼2.gif" alt="akb48" title="曼巴一路走好吧！"></p>]]></content>
    
    <summary type="html">
    
      春节出不去，趁着还没正式上班，在家写一下总结
    
    </summary>
    
      <category term="坠乱花天" scheme="http://yoursite.com/categories/%E5%9D%A0%E4%B9%B1%E8%8A%B1%E5%A4%A9/"/>
    
    
      <category term="读书" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>Google SRE读后感</title>
    <link href="http://yoursite.com/2020/02/03/Google-SRE%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
    <id>http://yoursite.com/2020/02/03/Google-SRE读后感/</id>
    <published>2020-02-03T08:42:37.000Z</published>
    <updated>2020-02-03T10:23:04.644Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="职业定义">职业定义</span></h2><p>SRE是<code>站点可靠性工程师</code>，与运维不同之处是，运维更多是在别人开发好的系统上当流水线工人，而SRE需要自己开发系统，所以SRE需要有更加强的脚本开发技能，同时也要具备强有力的沟通能力、领导能力和丰富的排错经验。开发技能表现在需要开发一些工具帮助我们监控、事故追踪和压测。而沟通能力是因为我们需要经常与开发人员和产品经理交流，无论是优化环节还是故障排查环节。领导能力是建立在排错经验基础上的，当出现了线上故障，我们要第一时间的迅速定位故障点，同时领导整个团队高效解决故障。</p><p>注意！SRE并不负责部署，但是要负责发布！这里发布的概念要比部署大多了，虽然不负责机械化的部署操作，但是SRE更着眼于整个流程，而且更要有流程化思维。</p><p>SRE，我个人认为它是与用户站在同一个角度思考问题的，开发人员关注的是<code>功能是否会实现</code>，实现了那就OK了。而SRE关注的是<code>用户用的爽不爽</code>，若用户使用的时候出现了错误，那么SRE就要出场解决问题。</p><p>SRE也要注意推动问题解决，SRE不是<code>server reboot engineering</code>…重启大法虽然好，但是治标不治本。</p><h2><span id="平台稳定与slo">平台稳定与SLO</span></h2><p>谷歌对系统稳定性有一个比较人性的看法：天底下没有100%不出故障的系统，出故障是正常情况，而如果判断一个系统的健康程度，主要看它是否满足预期的SLO。</p><p>SLO是一个重要概念,它中文意思是服务质量目标.服务的故障由于种种原因是无法避免的，每个服务的级别不同，不可能所有服务都是99.999999%，要针对业务的不通特性制定不同的SLO。如果是稳定性要求很高,即与客户有高强度的赔偿协议的服务,那么SLO的级别必须很高，那么付出的代价就是发布变动频率不高或者每一次发布都要严谨评审；而如果是相对冷门涟源的服务，那么SLO可以适度放低。</p><p>SLO的制定通常是产品经理、开发团队、SRE一起协商完成，大家根据业务的规模，产品特性，产品处于的阶段制定。当出现了“稳定”与“创新”的矛盾的时候，那么就要产品经理、开发团队、SRE再一次坐到一起修正SLO。</p><p>而年度总结的时候，是否满足SLO也是判断SRE的工作业绩的一个考核标准。</p><h2><span id="值班问题">值班问题</span></h2><p>SRE有on-call制度的，即值班制度。这里的值班并不是广义的值班，而是在某个周期，某个成员会成为故障的第一接口人。这段时间里，这位同学保证内网VPN和工作电脑时刻在身边。值班范围可以先从一个小系统开始，然后随着对业务的熟悉而逐渐扩大。</p><p>值班同学切记不要搞“个人英雄主义”，该汇报汇报，该求助求助，同时其他同学也不可以“事不关己”的态度，同是一个团队的战友，“解决问题”是大家的共同责任。但是辩证法的看，如果平台太稳定，会导致on-call人员产生惰性，所以有些时候需要“人为制造麻烦”—-不断的演习；</p><p>但是总而言之，值班是一个很苦逼的工作，如何让值班变得轻松且成功，也是一个制度改进的问题。</p><h2><span id="故障排查">故障排查</span></h2><p>不要一天到晚盯着“大屏”，而是编写合适的监控与报警规则，让我们能快速找到故障根源；</p><p>出故障第一时间先快速恢复（回滚、部分服务降级限流或者是其他方法），可以将流量转移到其他节点去，保留一台服务器作为事故现场，用于事后分析（这里可以看出虽然SRE不用实际手动去部署，但是有权利直接回滚）</p><p>故障排查不是一门玄学，平时经验积累是很重要的一环，经验的积累有助于在模糊不清的旁人描述中提高判断力，但是也要注意结合实际环境和最后一次改动，怀疑的范围逐渐缩小最后得到“真凶”。</p><p>事后总结要遵循“对事不对人”的原则，这样大家就不惧怕写事后总结了，而且会让事后总结质量提高，可以对新入职的同学有帮助；</p><h2><span id="结合实际的工作目标">结合实际的工作目标</span></h2><p>首要任务：有效性和覆盖率<br>具体工作内容（☆越多代表优先级越高）：<br>1.对现有的系统二次开发或者利用开源软件搭建环境，得到符合自己业务需要的监控系统（分布式，高可用），监控是SRE的眼睛；<font color="red">☆☆</font><br> 1.1 监控系统要从更高的服务质量和链路通讯层面告警，通过API或者是CURL等技术获取整体细节，但是也要能快速定位到具体的颗粒；<br>1.2 告警分级系统，兼顾覆盖率的前提下要突出重点；<br>1.3 准备一个文档，可以给开发或者其他同事讲述如何应对各种告警；<br>1.4 即可以tcp又可以udp的探测系统；<br>1.5 事故根源被跟踪恢复，可能还需要一个基线式的事故跟踪系统；<br>2.需求预测与规划容量，一些大型促销时需要正确计算出扩容的规模；<font color="red">☆☆</font><br>3.保障大促期间平台的正常运行，处理紧急运维事件，注意满足“1510法则”；<font color="red">☆☆☆</font><br>4.建立一套完整的on-call值班机制；<font color="red">☆</font><br>5.当熟悉了系统以及与开发人员交流增多的前提下，参与延迟优化和性能优化等工作；<font color="red">☆</font><br>6.学习并参与全链路压测；<font color="red">☆☆</font><br>7.参与各种演习，如故障演习，攻防演习等等，将平时演习得分提升上去；<font color="red">☆☆☆</font></p><h2><span id="书中金句分享">书中金句分享</span></h2><p>1.备份就像纳税一样，是一个服务需要持久而付出的代价，来保障其数据的可用性；<br>2.失败是正常现象，没有100%正常的系统，但是要主动的去寻找失败的可能性；<br>3.用排除法定位故障不是不可以，但是要快速定位，就要平时有对比环境是否一致性的习惯，这就是推动容器化的主要原因；<br>4.SRE通过创造流程、实践以及工具，来提高软件的可靠性；<br>5.一个需要人工阅读邮件和分析报警来决定目前是否需要采取某种行动的系统从本质上是错误的，没有不需要采取行动的警报，如果您遇到一个自己认为不需要执行操作的警报，您需要采用自动化的手段来修复该警报；<br>6.不应该盲目的追求高可用性，从99.99% –&gt;99.999%付出的成本是巨大的，但是收益仅仅是0.009%而已。<br><img src="/images/利拉德1.gif" alt="akb48" title="利拉德踩中场logo超远距离三分"></p>]]></content>
    
    <summary type="html">
    
      入职新东家的第一任务
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="运维技术" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4%E6%8A%80%E6%9C%AF/"/>
    
      <category term="SRE" scheme="http://yoursite.com/tags/SRE/"/>
    
  </entry>
  
  <entry>
    <title>纪念我的姥姥</title>
    <link href="http://yoursite.com/2020/01/22/%E7%BA%AA%E5%BF%B5%E6%88%91%E7%9A%84%E5%A7%A5%E5%A7%A5/"/>
    <id>http://yoursite.com/2020/01/22/纪念我的姥姥/</id>
    <published>2020-01-22T03:25:42.000Z</published>
    <updated>2020-01-22T14:13:45.616Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>李惠中老人在2020年1月20日夜10点左右驾鹤西游，永远离开了这个世界，而她就是我的姥姥。</p><p>她这次意外是出于夜里上厕所自己不小心摔了一跤，导致胯部骨裂。医生检查后发现，年纪太大，骨质疏松已经很严重，所以不建议开刀做手术只能选择静养的保守治疗。随着这么一次折腾，她的各种并发症也一起并发了，元旦我回家看她的时候，甲亢已经很严重了，脖子胖胖的，摸上去软软的，同时还有肺炎，据说严重的时候整个人浮肿的厉害，手指头摸上去，很明显的感受得到老手皮下的液体。不过整个人是清醒的，头发又白又长又乱，眼袋很大，穿着毛衣，外面套着病号服，屁股下垫着成人尿不湿，她整个人木木的坐在被子里，呼噜呼噜的，医生嘱咐不能久坐，所以她更多的时间是平躺或者侧躺。我的几个姨姨和舅妈经也换着花样给她做点鸡蛋羹或者小米粥这样的东西给她喂饭。她食量忽高忽低，我第二次离开医院的时候，她状态很好，吃了一杯酸奶和一碗麦片。后来我到了杭州，听我妈说她的状态是往好转的，水肿消了不少而且甚至可以站起来了，只是不能走动。明明一切情况都是积极的，但是这个肺炎最后还是出现了情况恶化，夺走了她的生命。俗话说七十三八十四，我姥姥还是没有坚持过84这个坎。</p><p>我现在还记得姥姥家老房子的客厅结构，那是一个很小的客厅，没有阳台，窗户下面是暖气片，旁边就是一个木头的组合单人床，单人床对面是一个木头的青灰色大书桌，大书桌上有日历、座机电话和一个电视机。书桌上面有局部地方漆掉了，露出了里面的木头。单人床左边是一个长沙发，大约能并排坐下四个成年男子，沙发再左边又是一个单人床，这个单人床挨着墙壁，而墙里还嵌着一个柜子，里面放一些棉被枕头等东西。这个客厅在过年聚会的时候就会热闹，大人们在这里打麻将，小孩子这时候要不就是在单人床上七扭八歪的看电视，要不就是来回的从这个单人床跑跳到对面的单人床上，打打闹闹。</p><p>在我印象里，我姥姥并不是一个做饭的好手，她只会做一点简单的炒菜，以及大米饭炒鸡蛋，炖鸡炸鱼我个人是从来没见她做过。主要是她做的菜并不是很好看，所以每次我去她家都是猛劲儿吃蛋炒饭和熟食的。我姥爷走得早，我姥姥的房间在聚会散去之后就会显得很冷清，她自己也习惯了这种喧闹之后突然安静的日子，自己自有自己过的生活。我姥姥信佛，记得老房子里她的卧室还有一个挺大的佛台，供着瓷做的观音和小童子等摆件，佛台上还有一些附近寺里拿回来的经书和烛台。不过这些东西再在家之后好像就扔掉了。</p><p>除了信佛之外，我姥姥就没有别的什么业余生活了，她不怎么看书写字，看电视更多就是《西游记》这样的老片儿，朋友来往不算多，平常时候会自己下楼买菜或者遛弯，如果没什么事就早早上床睡了。如果子女忙工作没时间去看她的话，就这样从白天到黑夜，再由黑夜到第二个白天。为了怕她孤独，我的几个姨姨和舅舅也会抽时间过去跟她吃饭，顺便给她带点牛奶蔬菜等食物。姥姥说话很少，虽然到东北多年，但是一口的山西话还是很浓重。后来姥姥牙齿掉光，给她配了假牙，她也随身有一个小杯子，假牙不用了就泡进去。再后来她的耳朵也背了，但是她坚持不要带助听器，无论别人怎么劝。以至于后期跟她交流基本靠吼，打电话基本能累死一个人。也就这样，原本就不太与人交流的她更加沉默。她后来罗圈腿比较严重了，走路颤颤巍巍的，也偶有爬楼梯摔跤的经历，于是搬离了老房子去与我三姨同住。我去年春节回家的时候，全家去三姨家过年，看她自己在一个小屋里躺着，三姨给她调好IPAD，她就一集接着一集的看电视剧，有字幕和声音的帮助来了解剧情，以此来消磨时间。到了吃饭的时候，也是颤颤巍巍的走出来，在桌子边的角落吃点稀饭素菜，依旧不停的给我们小孩这些夹肉夹鸡蛋，或者一个劲儿的让我们喝雪碧可乐。她过年也会给我们这样的孙子辈准备红包，一笑起来，满脸的褶子更多了，一一分发给我们，哪怕我们都已经上班好几年了。</p><p>我姥姥是一个普普通通的石油工人家属，相比较我姥爷“郭老大”年轻时候的威风，她更多一种幕后后勤的角色。姥姥有七个子女，四女三男，其中有一个舅舅由于历史原因就一直在老家生活。那时候家里条件不算很好，我姥姥就这样坚持把这六个在身边的子女养大，并且安排他们一个一个都成了家，甚至有了我们这第三代。记得我大舅说过，在他年轻浪荡时，经常打个招呼就出门了，玩好了后再去朋友家喝酒喝通宵，当时没有什么通讯手段，我姥姥就一个一个朋友家的找过去，把醉酒的大舅找到。</p><p>我姥姥也有她自己的缺点，她有苏大强的那一面：偏心、固执、对弱者耍脾气对强者逃避。家里能长期忍受她脾气的人不多，除了我大姨也就是我三姨大舅一家了。她有一个弟弟，我叫舅老爷，俩人不知道怎么回事，突然就闹翻了，这一翻就翻了十多年。搞得现在子女往来都有点尴尬，我结婚的时候，舅老爷那边人也没有过来现场祝贺。但是身后第二天烧姥姥遗物的时候，舅老爷家来人悼念了。</p><p>今天已经是身后第三天了，我没有赶的回去，听几个已经到东北老家的弟弟说，一大早就出殡做了遗体告别，骨灰也暂放在殡仪馆百日。等头七的时候，我就要带着媳妇儿去给我姥姥磕头烧纸。</p><p>但是这几天我就一直在想，待我大年初二到了老家后，看到曾经总有一个人的那张床上空空如也，自己会是一个什么样的心情呢？那会是一种什么样的无奈失落和不适应？</p><p>仁厚黑暗的地母呵，愿在你怀里永安她的灵魂！<br><img src="/images/姥姥.jpg" alt="akb48"></p>]]></content>
    
    <summary type="html">
    
      有时候真觉得，冥冥中自有天意
    
    </summary>
    
      <category term="坠乱花天" scheme="http://yoursite.com/categories/%E5%9D%A0%E4%B9%B1%E8%8A%B1%E5%A4%A9/"/>
    
    
      <category term="心情" scheme="http://yoursite.com/tags/%E5%BF%83%E6%83%85/"/>
    
      <category term="亲情" scheme="http://yoursite.com/tags/%E4%BA%B2%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>Python调用另一个py变量失败的问题</title>
    <link href="http://yoursite.com/2019/12/31/Python%E8%B0%83%E7%94%A8%E5%8F%A6%E4%B8%80%E4%B8%AApy%E5%8F%98%E9%87%8F%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/12/31/Python调用另一个py变量失败的问题/</id>
    <published>2019-12-31T06:37:11.000Z</published>
    <updated>2020-01-06T06:43:30.000Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="举个栗子">举个栗子</span></h2><p>我有两个文件，第一个文件<code>a.py</code>的内容如下：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line">CHOOSE = input (<span class="string">'''</span></span><br><span class="line"><span class="string">         \033[1;35m choose 1 or 2:\033[0m</span></span><br><span class="line"><span class="string">         1)tom</span></span><br><span class="line"><span class="string">         2)jack</span></span><br><span class="line"><span class="string">'''</span>)</span><br><span class="line"></span><br><span class="line">a = <span class="number">666</span></span><br><span class="line">b = <span class="string">"bbb"</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"this is a test"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"function"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">if</span> CHOOSE == <span class="string">'1'</span>:</span><br><span class="line">        username = <span class="string">'tom'</span></span><br><span class="line">        print(username)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> CHOOSE == <span class="string">'2'</span>:</span><br><span class="line">        username = <span class="string">'jack'</span></span><br><span class="line">        print(username)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'wrong choice,script is exit...'</span>)</span><br></pre></td></tr></table></figure></p><p>拎一个脚本，<code>b.py</code>的内容如下：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> a</span><br><span class="line"><span class="keyword">from</span> a <span class="keyword">import</span> b,f,CHOOSE,username</span><br><span class="line"></span><br><span class="line">a = a.a</span><br><span class="line">f()</span><br><span class="line">print(b,a,CHOOSE,username)</span><br></pre></td></tr></table></figure></p><p>可以看出<code>b.py</code>的内容就是调用同目录下<code>a.py</code>的变量，但是执行<code>b.py</code>是会报错的。<br><img src="/images/pyredis4.png" alt="akb48"></p><p>可见<code>b.py</code>已经成功读取到了<code>b,f,CHOOSE</code>这些变量，但是<code>username</code>却引入失败，为啥呢？</p><p>因为<code>a.py</code>里有一个<code>if __name__ == &#39;__main__&#39;</code>，他的意思是<font color="red">当.py文件被直接运行时，if <strong>name</strong> == ‘<strong>main</strong>‘之下的代码块将被运行；当.py文件以模块形式被导入时，if <strong>name</strong> == ‘<strong>main</strong>‘之下的代码块不被运行。</font></p><p>举个例子解释一下：假设你是<code>小明.py</code>，在朋友眼中你是小明(<strong>name</strong> == ‘小明’), 你自己眼中你是你自己(<strong>name</strong> == ‘<strong>main</strong>‘)。</p><p>你编程很好, 朋友调你去帮他写程序(import 小明, 这时你在朋友眼中: <strong>name</strong> == ‘小明’),但你晚上也会打开xx网站, 做一些自己的事情(直接运行小明.py, <strong>name</strong> == ‘<strong>main</strong>‘)—摘自知乎网友回答。</p><p>既然知道了原因，解决方法也很简单：把<code>a.py</code>里的<code>if __name__ == &#39;__main__&#39;</code>段落拆掉，把相应内容改成一个函数，比如<code>a.py</code>改成如下的样子：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">上面内容略</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(CHOOSE)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> CHOOSE == <span class="string">'1'</span>:</span><br><span class="line">        username = <span class="string">'tom'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> CHOOSE == <span class="string">'2'</span>:</span><br><span class="line">        username = <span class="string">'jack'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        username = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> username</span><br></pre></td></tr></table></figure></p><p><code>b.py</code>改成如下样子(其他可读取的变量不考虑)：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> a <span class="keyword">import</span> foo</span><br><span class="line">CHOOSE = input (<span class="string">'''</span></span><br><span class="line"><span class="string">         \033[1;35m choose 1 or 2:\033[0m</span></span><br><span class="line"><span class="string">         1)tom</span></span><br><span class="line"><span class="string">         2)jack</span></span><br><span class="line"><span class="string">'''</span>)</span><br><span class="line"></span><br><span class="line">username = foo(CHOOSE)</span><br><span class="line"><span class="keyword">if</span> username:</span><br><span class="line">    print(username)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'Wrong choice'</span>)</span><br></pre></td></tr></table></figure></p><p>这样问题就解决了，记住<code>if __name__ == &#39;__main__&#39;</code>更适合放在脚本的入口点。</p><p>上面说了，<code>if __name__ == &#39;__main__&#39;</code>更适合放在脚本的入口点，到底哪个程序入口被选中，这取决于<code>__name__</code>的值，<code>__name__</code>是内置变量，可用于表示当前模块的名字。如果一个<code>.py</code>文件（模块）被直接运行时，则其没有包结构，其<code>__name__</code>值为<code>__main__</code>，即模块名为<code>__main__</code>。</p><p>所以，<code>if __name__ == &#39;__main__&#39;</code>的意思是：当<code>.py</code>文件被直接运行时，<code>if __name__ == &#39;__main__&#39;</code>之下的代码块将被运行；当<code>.py</code>文件以模块形式被导入时，<code>if __name__ == &#39;__main__&#39;</code>之下的代码块不被运行。</p><p>上面的话，可以做一个小实验来理解，我们在<code>a.py</code>里<code>if __name__ == &#39;__main__&#39;</code>之前加入<code>print __name__</code>，即将<code>__name__</code>打印出来，那么执行<code>a.py</code>会看到<code>__name__</code>输出是<code>__main__</code>。<br><img src="/images/pyredis5.png" alt="akb48"></p><p>但是此时<code>a.py</code>不动，直接执行<code>b.py</code>，会发现<code>__name__</code>变量值为b,不满足<code>__name__==&quot;__main__&quot;</code>的条件，因此，无法执行其后的代码:<br><img src="/images/pyredis6.png" alt="akb48"></p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://zhuanlan.zhihu.com/p/34112508" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/34112508</a><br><a href="http://blog.konghy.cn/2017/04/24/python-entry-program/" target="_blank" rel="noopener">http://blog.konghy.cn/2017/04/24/python-entry-program/</a><br><a href="https://stackoverflow.com/questions/419163/what-does-if-name-main-do" target="_blank" rel="noopener">https://stackoverflow.com/questions/419163/what-does-if-name-main-do</a><br><a href="https://www.zhihu.com/question/49136398" target="_blank" rel="noopener">https://www.zhihu.com/question/49136398</a> （里面有很多例子）</p>]]></content>
    
    <summary type="html">
    
      unzip要直接覆盖原有同名文件，那就unzip -o，这样不会进行询问了
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Zabbix配置discovery主动发现ActiveMQ队列</title>
    <link href="http://yoursite.com/2019/12/19/Zabbix%E9%85%8D%E7%BD%AEdiscovery%E4%B8%BB%E5%8A%A8%E5%8F%91%E7%8E%B0ActiveMQ%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2019/12/19/Zabbix配置discovery主动发现ActiveMQ队列/</id>
    <published>2019-12-19T11:44:02.000Z</published>
    <updated>2019-12-20T08:38:24.000Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>快到年关了，领导大手一挥，要把线上环境切换新的VPC。既然要切VPC，就要与原有的VPC决裂，也要重新搭一套zabbix了，搭建activemq监控项就难免要监控各种队列，但是每个activemq里面的队列名又不同，一个一个特殊配置太头疼，于是就尝试使用<code>主动发现</code>来做，系统自己匹配队列。</p><h2><span id="后端脚本">后端脚本</span></h2><p>首先要先准备一个<code>discover_mq.py</code>，如下：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># !/usr/bin/env python </span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># 用来获取当前mq的队列名</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  <span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">  <span class="keyword">import</span> simplejson <span class="keyword">as</span> json</span><br><span class="line"><span class="keyword">import</span> commands</span><br><span class="line"></span><br><span class="line">(status, output) = commands.getstatusoutput(<span class="string">"""curl -s -u 'mq前端页面账号:mq前端页面密码' http://127.0.0.1:8161/admin/queues.jsp|grep '&lt;/a&gt;&lt;/td&gt;'|awk -F'&lt;' '&#123;print $1&#125;'"""</span>)</span><br><span class="line">outputs = output.split(<span class="string">'\n'</span>)</span><br><span class="line">result = []</span><br><span class="line"><span class="keyword">for</span> one <span class="keyword">in</span>  outputs:</span><br><span class="line">result.append(&#123;<span class="string">'&#123;#RESULT&#125;'</span>: one&#125;)</span><br><span class="line">print(json.dumps(&#123;<span class="string">'data'</span>:result&#125;,sort_keys=<span class="keyword">True</span>,indent=<span class="number">4</span>))</span><br></pre></td></tr></table></figure></p><p>这个脚本执行就可以获取当前所有的队列名，如图：<br><img src="/images/zabbix7.png" alt="akb48"></p><p>然后再准备一个<code>monitor_mq.sh</code>，如下：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line"><span class="comment"># 获取每一个队列的入队、出队和积压量</span></span><br><span class="line">username=mq前端页面账号</span><br><span class="line">password=mq前端页面密码</span><br><span class="line">myip=$<span class="number">1</span></span><br><span class="line">queuename=$<span class="number">2</span></span><br><span class="line">mytype=$<span class="number">3</span></span><br><span class="line"></span><br><span class="line">case $&#123;mytype&#125; <span class="keyword">in</span></span><br><span class="line">Pending)</span><br><span class="line">curl -s -u <span class="string">"$username:$password"</span>  <span class="string">"http://$&#123;myip&#125;:8161/admin/queues.jsp"</span>|grep <span class="string">"^$&#123;queuename&#125;&lt;/a&gt;&lt;/td&gt;"</span> -A <span class="number">5</span>|sed -n <span class="string">'2p'</span>|egrep -o <span class="string">'[0-9]+'</span></span><br><span class="line">;;</span><br><span class="line">Enqueued)</span><br><span class="line">curl -s -u <span class="string">"$username:$password"</span>  <span class="string">"http://$&#123;myip&#125;:8161/admin/queues.jsp"</span>|grep <span class="string">"^$&#123;queuename&#125;&lt;/a&gt;&lt;/td&gt;"</span> -A <span class="number">5</span>|sed -n <span class="string">'4p'</span>|egrep -o <span class="string">'[0-9]+'</span></span><br><span class="line">;;</span><br><span class="line">Dequeued)</span><br><span class="line">curl -s -u <span class="string">"$username:$password"</span>  <span class="string">"http://$&#123;myip&#125;:8161/admin/queues.jsp"</span>|grep <span class="string">"^$&#123;queuename&#125;&lt;/a&gt;&lt;/td&gt;"</span> -A <span class="number">5</span>|sed -n <span class="string">'5p'</span>|egrep -o <span class="string">'[0-9]+'</span></span><br><span class="line">;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure></p><p>然后就是准备zabbix的自定义监控项：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UserParameter=activemq.discover, python /mnt/discover_mq.py<span class="comment">#我放到/mnt目录下了</span></span><br><span class="line">UserParameter=activemq.check[*],sh /mnt/monitor_mq.sh $<span class="number">1</span> $<span class="number">2</span> $<span class="number">3</span></span><br></pre></td></tr></table></figure></p><p>重启<code>zabbix-agent</code>，此时别忘了在<code>/etc/sudoers</code>添加上<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zabbix  ALL=(root) NOPASSWD: /usr/bin/python</span><br><span class="line">Defaults:zabbix   !requiretty</span><br></pre></td></tr></table></figure></p><h2><span id="前端配置">前端配置</span></h2><p>来到zabbix-server前端页面，先在对应的templates添加Discovery，如图：<br><img src="/images/zabbix8.png" alt="akb48"></p><p>点击<code>Create discovery rule</code>，创建一个规则：<br><img src="/images/zabbix9.png" alt="akb48"></p><p>然后创建3个<code>item prototypes</code>，每一个对应入队、出队、积压量，如图：<br><img src="/images/zabbix10.png" alt="akb48"></p><p>还可以针对积压量做一个<code>Trigger prototypes</code>的告警。</p><p>保存之后，整个主动发现就配置到整个Templates，我们可以抽查一个机器，看一下是否自动匹配到所有的队列：<br><img src="/images/zabbix11.png" alt="akb48"></p><p>大功告成，收工回家！</p>]]></content>
    
    <summary type="html">
    
      感觉今年没啥事竟来回切环境了
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="监控技术" scheme="http://yoursite.com/tags/%E7%9B%91%E6%8E%A7%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Zabbix" scheme="http://yoursite.com/tags/Zabbix/"/>
    
  </entry>
  
  <entry>
    <title>美妙的东京八日游</title>
    <link href="http://yoursite.com/2019/12/03/%E7%BE%8E%E5%A6%99%E7%9A%84%E4%B8%9C%E4%BA%AC%E5%85%AB%E6%97%A5%E6%B8%B8/"/>
    <id>http://yoursite.com/2019/12/03/美妙的东京八日游/</id>
    <published>2019-12-03T15:24:27.000Z</published>
    <updated>2019-12-25T10:00:08.000Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>9月份的时候，俺就跟媳妇琢磨想要一起休有薪假，原本打算去台湾转转，但是由于国家政策变化只能作罢，而我个人对韩国、老挝、柬埔寨也没啥感觉，于是选来选去还是决定二刷日本，不过这次目的地不再是大阪了，而是东京。</p><p>买了国航的票，一大早9点半从杭州坐机场大巴到浦东机场，当时上海正值国际进口博览会，刚入上海还要停车—所有人下车安检。之后顺利到达浦东机场，办理值机托运和出关手续之后，我和媳妇买了两个汉堡王套餐垫垫肚子。终于等到1点半起飞，4点抵达成田机场。</p><p>在日本办理入关的时候还有一个小插曲，我媳妇随身携带的布包里有飞机上吃剩的柚子和玉米，结果入关时被搜查犬盯上闻来闻去，然后与搜查犬一起的小姐姐就拿出一个纸片，上面有中文：“您的包裹里有食物，请配合我们检查”，于是我们就配合的检查了一下，检查完毕食物并没有没收照样还给了我们。插曲结束，跳上skyline直达东京市区，又买了东京3日地铁卡，然后按照google导航顺利找到酒店办理入住。</p><p>我们住的是平价酒店，在店员的指导下用机器checkin，到了房间里发现什么东西都很小，桌子小、卫生间小、浴缸小，除了大床剩下的基本能上墙的都上墙了。虽然小，但该有的都有，而且很整洁，很精致。我也人生第一次使用了他们的水冲屁屁马桶，那感觉还真有点“酸爽”。每天早上宾馆还有早餐，虽然免费的只有两个套餐，但是可颂抹黄油再配上一杯红茶还是挺好吃的。</p><p>我住的酒店位于茅长町。茅长町在当地是一个普通的住宅区，初到的那个晚上把行李放好之后，在酒店四处走了走，发现附近都是住宅区、小商店、写字楼、小公园，并没有什么景点。不过日本的街道很好玩，因为楼与楼很近，感觉就像迷宫一样，我就在各种小路里溜达探索，意外的发现了一个小神社，神社里还有人再出售神符。而且这个神社还挺有人气的，又一次我早上来溜达的时候，看到一个穿正装的女子前来拜祭，啪啪拍了两下手低头鞠躬，然后还往功德箱里面扔了几个硬币。估计这位妹子是去求职面试吧，希望自己能有一个好运气。<br><img src="/images/tokyo7.jpg" alt="akb48" title="可惜我没有零钱，又不能扫码支付..."></p><p>具体的行程表如下：<br>11月9日    杭州东站—上海浦东机场—东京成田机场入关—茅长町酒店入住，周围小转<br>11月10日  台场—自由女神–杜莎夫人蜡像馆–SEGA欢乐城—海贼王公园—东京塔观光<br>11月11日  东京迪士尼海洋公园<br>11月12日  东京国立博物馆—不忍池—秋叶原<br>11月13日  雷门—浅草寺—上野动物园—茑屋书店（代官山店）<br>11月14日  镰仓小町通—鹤岗八幡宫—镰仓高校打卡—歌舞伎町一番街<br>11月15日  新宿买买买<br>11月16日  东京成田机场买买买—上海浦东机场—杭州东站</p><h2><span id="东京迪士尼海洋公园">东京迪士尼海洋公园</span></h2><p>东京迪士尼毫无疑问是本次东京之行的重头戏，非常值得独立出来说，它的篇幅也的确有点大。我们去的是迪士尼海洋园区。为了这趟迪士尼，本人着实下一番功夫：先去东京迪士尼的官网注册会员然后购买了门票并且打印出二维码。东京迪士尼跟上海的迪士尼不一样—FAST PASS卡不是用钱买的，而是需要抢的，如果不想自己掐着表在园区里跑来跑去，那么就需要下载两个app—<code>Disney Resort</code>和<code>TDL/S时间</code>：<br><img src="/images/tokyo4.jpg" alt="akb48" title="APP是必不可少的！"></p><p>但是这里要注意，只有日版的apple store才能下载到这俩个app，所以你需要用一个邮箱来申请一个日区的apple store账号，下载APP完毕之后，在<code>Disney Resort</code>需要登陆的也是你在东京迪士尼网络上注册买票的账号！这里是比较坑的一个地方。</p><p>这样在官网买了票，又准备了APP抢FAST PASS卡，带上几瓶水和简单的干粮。我和媳妇就一大早起床出发，直奔迪士尼海洋，到了园区拿了中文地图就方便多了，我俩足足玩了一整天，各种打卡拍照不亦乐乎。东京迪士尼我个人觉得必刷的几个项目：</p><ol><li>百老汇演出，这个第一场是随便进的，强烈推荐去看！除了第一场剩余的都要抢票才可以；</li><li>玩具总动员，这个跟上海迪士尼不一样，比上海迪士尼的更好玩；</li><li>惊魂古塔，超级超级超级的跳楼机，我跟媳妇琢磨了许久，最后没敢上…</li></ol><p>至于忿怒双神（过山车），飞跃地平线等项目也都很棒，但是跟上海迪士尼的差不太多，所以我强烈建议优先搞定上面三个。至于龟龟漫谈、神灯阿拉丁还有其他的部分项目，是有日语对白的，所以如果不懂日语就只能看个热闹。<br><img src="/images/tokyo3.jpg" alt="akb48" title="这个就是忿怒双神，不过见识过环球影城的翼龙飞行的我，对它就是微微一笑"></p><p>迪士尼海洋馆是没有花车游行的，但是中午会有露天舞蹈演出，我们去的时候已经属于圣诞节期，所以NPC们穿的都是圣诞装束了。到了晚上八点半，园区中央同样会有游船表演和烟火，只不过规模没有旁边迪士尼主区那么大。虽然东京迪士尼相比较大阪的环球影城更加偏低龄化，但是也非常值得花一天去享受，里面的火鸡腿也很好吃！</p><h2><span id="东京的文化">东京的文化</span></h2><p>东京国立博物馆是收费的，同样可以先在官网购买票，打印出票或保存二维码直接入门。我自己都没想到我花在东京国立博物馆的时间竟然比当时在大英博物馆的时间都要长，可能是因为国立博物馆主馆部分游客不多，许多展品可以一件一件的看过去，在这个空旷的展厅一个字一个字的读铂了金的佛经也是一个乐事。国立博物馆正馆里有一个特殊的小展厅，它里面每个月都会换国宝文物来展出，我去的时候正好是展出唐朝《群书治要》的手抄卷的一部分。<br><img src="/images/tokyo16.jpg" alt="akb48" title="《群书治要》不能拍，只能拍黑漆大小"></p><p>出了正馆，右手边就是东洋馆，不过先不急，天气特别好。我就在长凳上慢慢喝了一杯热咖啡，顺便晒晒太阳。东洋馆的“人，神，自然”特别展出给我留下的印象比较深刻—展厅中央是两具古尸，周围是各种公元前时代各种的祭品。人类本相通，无论什么种族肤色，都是从祭祀敬天慢慢的进化到娱己重我，那些静静躺着的文物也无声的证明这这段时光。在东洋馆3、4楼有较大的一片区域专门展出中国文物，有商朝的摇钱树、唐朝的器皿、宋朝的字画。底楼是展出波斯柬埔寨等国的文物，在展厅二楼中间可以掷骨算命和印章这样的小互动，免费玩一玩游戏还是蛮有意思的。</p><p>今年是日本新天皇上任，所以国立博物馆特意安排了奈良的正仓院举行特别展出，这次特别展出的招牌就是传世唯一唐朝五弦琵琶。果然那个琵琶附近全是人，排成队的流动。这次正仓院展出是额外收费的，而且只能凭借纸质票补差价，如果是电子票必须全额买，这一点比较坑。话说日本有很多老头老太太来逛博物院，一个个走的颤颤巍巍的。<br><img src="/images/tokyo17.jpg" alt="akb48"></p><p>除了博物馆，东京还有很多的美术馆，这里面我个人强烈推荐根津美术馆，它是一个私人收藏馆，整个园林的布置非常的考究，但是很遗憾，八天的时间里由于根津美术馆维修，我只能缘悭一面。后来我媳妇的闺蜜在12月初去了根津美术馆，媳妇闺蜜发微信说12月枫叶红了，整个根津美术馆特别漂亮和雅致，惊艳到她了。</p><h2><span id="东京的买">东京的买</span></h2><p>说到买，东京有著名五大购物区—新宿、银座、池袋、涩谷、六本木。我俩行程里只安排了一天的购物，所以就在新宿泡了一整天。今年人民币贬值比较厉害，所以在东京购物相比较大陆，实惠的力度稍打折扣，不过还是比国内便宜很多，我买了一个加南大鹅的棉马夹，淘宝要4000，日本价格不到3100人民币。除此之外，买了三盒蒸汽眼罩。</p><p>江湖传言Adidas和North Face在日本都能买到特殊设计的服装，果然这两个品牌店在东京也是比较好找的。里面的款式也的确是国内专卖店没有的，看上去都很潮。不过很可惜，日本的男性普遍都是瘦身材，所以衣服最大码就是L码，对于我说来看到喜欢的衣服却没有XL码真是一个很痛苦的事情。</p><p>说完了买衣服再说说别的。台场商业中心是高达死忠粉必打卡的地方，中心门口的巨型高达已经足够吸睛，据说每天有两场灯光秀。而商场里最顶层有一半的空间是高达基地。这个简直可以称之为“高达博物馆”的地方里面有各式各样的高达手办，甚至可以自己DIY给高达配色和组装零部件。<br><img src="/images/tokyo5.jpg" alt="akb48" title="门口的独角兽简直太威风了！"><br><img src="/images/tokyo18.jpg" alt="akb48" title="我全都要啊啊啊啊"></p><p>如果你是NBA死忠粉，那么在台场商场的NBA店会看到许多NBA巨星的签名和球鞋，从飞人乔丹魔术师约翰逊鲨鱼奥尼尔再到艾弗森库里，中国长城姚主席的球衣也在展列柜里：<br><img src="/images/tokyo6.jpg" alt="akb48" title="梦一队队服和球鞋，7号是拉里伯德"><br><img src="/images/tokyo19.jpg" alt="akb48" title="大姚的鞋果然很大..."></p><p>到了东京怎么能不去秋叶原？秋叶原以死宅的“圣域”而闻名，里面手办、游戏、漫画、写真、COSPLAY的衣服，无论是见过的没见过的，知道名的不知道名的，应有尽有。当然如果你乱走，也会有可能误入出售岛国爱情动作片和成人用品的地区，完全是意外之喜啊！</p><p>AKB48的剧场也位于秋叶原，如果你看过WorldOrder舞团的《Have a nice day》的MV，应该会对这里有点印象：<br><img src="/images/tokyo9.jpg" alt="akb48"></p><p><img src="/images/tokyo10.jpg" alt="akb48" title="这么多年了，海报还是最初的那几个元老"></p><p>我是斋藤飞鸟的死宅粉，那么买一个我鸟的写真集也是早早就列入愿望list里的。而代官山的茑屋书店是一个很著名的书店，书店是全玻璃体，分三个部分，有露天楼梯相通，书店里出售书籍、影像、CD、文具、蓝牙音箱、车模乃至超市用具都有，甚至可以在里面边看书边吃饭。我在网上看它是一个东京少数的24小时店，甚至还提供住宿服务，不过我转了一圈并没有发现可以睡觉的地方…<br><img src="/images/tokyo2.jpg" alt="akb48" title="意外的发现了《三体》"></p><p><img src="/images/tokyo20.jpg" alt="akb48" title="披头士签名唱片"></p><h2><span id="东京的吃">东京的吃</span></h2><p>在东京吃东西很贵，我一个普通工薪族也没有安排特别高大上的东西。几天下来我个人觉得最好吃的就是在新宿店吃的“鸟贵族”，他们以烧鸟作为招牌菜。先叫上两杯梅子酒，吃上几串芝士鸡肉丸，我个人非常喜欢他们的天妇罗，炸的软软的，入口即。鸡皮盐味烤也不错，鸡皮烤得脆焦程度刚好，而且并不油腻。咬下去汁液在口腔中四溅，像盛开的烟花。再叫上一杯大扎啤，歇歇逛了一天的脚，感觉好极了。<br><img src="/images/tokyo21.jpg" alt="akb48"></p><p>在七里滨，我跟媳妇慕名来尝尝这里的bills—传说中最棒的早餐。我俩到达的时候已经是下午4点左右，已经开始排起了小队，但是队伍并不长。这里招牌的就是pancake，好吃到流泪，随着松饼温度而慢慢溶化的蜂蜜奶油，更增添香味。奶油让松饼入口即化，细细咀嚼后能够感受到淡淡的乳香，搭配上烤过的香蕉片，清爽甜蜜的美味让人难忘。虽然银座也有bills，但是七里滨的bills位于海边，当时正好是渐渐夕阳的时间段，在店里靠窗户的位置还能看着大海里一个一个冲浪结束返回的人，无敌的海景view。<br><img src="/images/tokyo1.jpg" alt="akb48" title="七里滨的海景"></p><p>在上野公园，正好有机会去尝了尝一兰拉面，一进店门机器投币下单，机器打印小票，每人单人隔间，把外套挂到身后的衣架上，小票放到小盘里按一下桌子上的按钮，就会从店员从帘子后面伸出手来把小票拿走，根据小票内容准备食物。如果想要多加一份面或者半份面也是在门口的机器上投币下单，然后重复的把票放到小盘里按按钮即可。豚骨拉面还是很好吃的，他家的绿茶豆腐也很棒，没有那么甜，绿茶味挺浓。</p><p>陈晓卿先生在《圆桌派》里说过：想了解一个城市，就一定要去它的菜市场，饱览里面的食材，饱尝各种美味。筑地市场现在也成了东京的一个景点，那是一个当地很有名的水产市场，很可惜它要搬走了，由于2020东京奥运会的缘故。</p><p>至于女仆咖啡店，老夫只是在秋叶原的街上遇到上穿羽绒服下穿短裙的卡哇伊妹子发传单，而没有亲身尝试。现在很多女仆咖啡店也开始对中国人做生意了，提供中文菜单，而且可以跟众多女仆妹子们一起嗨。秋叶原的女仆店价钱比新宿的女仆店要便宜一点，但是秋叶原的咖啡店玩法比较多，除了女仆还有三国系列，为什么会有三国设定？学赵子龙七进七出嘛？好吧，我承认我开车了…<br><img src="/images/tokyo8.jpg" alt="akb48"></p><h2><span id="东京的玩">东京的玩</span></h2><p>东京作为国际级别大都市，地标建筑很多，我们第一天晚上就去了东京塔。东京塔有一个网红拍摄地，就是在一个地下室的台阶上仰拍整个东京塔，我跟媳妇去的时候发现那里已经有不下50个人在排队拍照，有些是拍塔，有些是连塔带人一起拍。东京塔里吃的东西一般，但是海贼王主题乐园就在东京塔里，在网络上购票比现场买便宜，而且还可以买东京塔观光的联票。海贼王主题乐园的周边出售到没有什么特别新奇的，而且很多一看就是义乌小商品。但是里面的真人表演还是挺棒的，还原度挺高，每人还发一个荧光棒来配合演员唱歌，剧情是独立的内容。<br><img src="/images/tokyo22.jpg" alt="akb48" title="二楼展区有作者的亲笔签名"></p><p>出了海贼王我们就直接上塔观光，东京塔有两层用来观光，高度不同价钱自然也不同。其实在main deck里能看到东京大部分的市容风景，top deck风景更佳。虽然现在东京的晴空塔更新更高，但是在很多东京人的心中，东京塔还是有一个无法磨灭的地位在。<br><img src="/images/tokyo13.jpg" alt="akb48"></p><p>SEGA欢乐城其实就是一个超大的电子游戏机厅，除了常规的游戏机之外（不过我在东京的游戏机厅里没见过《拳皇》），里面也有一些全体作战的重量型主题游戏机，需要4~10人一起玩的。如果你日文读的能力差一点的话，可能有些地方就要乱按键，看看能不能瞎猫碰上死耗子了。</p><p>上野动物园跟不忍池都在东京国立博物馆旁边的上野公园里，我去的时候池塘的荷花已经败掉了，但是在上野动物园看到了著名的鲸头鹳，呆呆傻傻的，偶尔一张开翅膀惊得很多人欢呼。在动物园经常看到日本的老头老太太在笼子外无声的做手势，嘴巴里轻轻的呼唤着里面的动物，希望可以得到动物的注意而跑过来。除了鲸头鹳，上野动物园的镇馆之宝就是大熊猫了，毫无疑问，熊猫馆排队也是非常惊人的，我跟媳妇没有去凑这个热闹。<br><img src="/images/tokyo11.jpg" alt="akb48"></p><p>我们这次还抽出了一天的时间去镰仓，拜访了著名了镰仓高校车站。这个车站已经被众多《灌篮高手》的粉丝打卡，尤其是火车过站的时候，很多中国游客在狂热的拍照。车站往上走一点点就能看到镰仓高校，学校门口有一个告示牌：“请游客不要入内拍照”，可见这个学校虽然作为湘北高校的原型而红遍大江南北，但是也饱受游客骚扰之苦。<br><img src="/images/tokyo12.jpg" alt="akb48" title="这个景色没有因为是傍晚而失去魅力"></p><p>说完了健康的娱乐，再说一点不健康的…在上野公园出来的路边，我惊喜的发现了成人电影院（囧）。看广告应该是500日元可以看一小时，可以一直看到深夜，成人影院门口贴满热辣的马赛克海报以及门口也摆了一两个穿制服的塑料模特。我驻足一会，顶着被抓的风险，拍了几张照就离开了…<br><img src="/images/tokyo15.jpg" alt="akb48"></p><h2><span id="东京的人">东京的人</span></h2><p>这此是我第二次来东京，觉得其实日本人还是很好分辨的。日本女人不用多说，妙龄少女打扮的很精致，贴假睫毛，牙齿又不算太整齐的话，那基本就是日本妹子了（甚至女厕所里会有梳妆台！别问我怎么知道的…）。而东京男人的体态特征也很明显，首先他们由于瘦，脸长且面部的棱角比较突出，而且感觉他们还都很喜欢鹰钩鼻，不知道是否有专门做这方面整容的医院。除了面部器官，头发也是识别东京男人的一个标志，很多年轻人都喜欢卷卷的头发，或长发或刘海，配上他们苗条的身材和不大的脸蛋，有些“花美男”的味道。</p><p>日本人超级能排队，当然据说他们心理对于“排队”也是拒绝的，但是身体却很诚实。上到美术馆下到拉面店，日本人在哪里都能排队。记得在迪士尼海洋，在环球喷泉最佳拍摄角度那里，日本人都会自发排队一个一个拍照…据说这是一种从众的体现。而且东京没有共享单车，因为几乎家家都有自行车，如果是住独栋的，院子里也会停一辆小排量的家用车。</p><p>日本的电车跟伦敦的一样，没有安检。站台非常干净，车厢里也是十分安静，很多人戴着口罩，不知道是遮住早起的倦容，还是藏着工作了一天的疲惫。刷手机，听歌，或者玩switch。看着车上的上班族，让我不自觉的想起日本综艺节目《让我去你家》里的一个一个小故事。想必国际大都市大抵都是这样，挤满了人，灯火辉煌的后面是一颗颗孤独的心。站在银座伊势丹的顶层，俯瞰这来往穿梭的人群车流，绝对是独一无二的景致。</p><p>上一次在大阪没有机会感受柏青哥，这次到了秋叶原也去转了一圈。发现里面各种柏青哥游戏机，小的是一个人玩的飞牌机，最大的有8个人一起玩的。在柏青哥店里，同样有吃有喝，排队等机器的话甚至可以看店家提供的杂志和漫画。店里20~80岁的各年龄层的男女顾客在这霹雳哗啦吵杂的声音里专注的盯着自己的屏幕消磨时间。有的人甚至旁边有一个小筐，筐里全是钢珠。但是柏青哥店并不是通宵营业，11点就关门了。<br><img src="/images/tokyo14.jpg" alt="akb48" title="光看着我就已经晕了"></p><p>除了以上几点，东京给我更大的感触，就是虽然警车会在街上巡逻，但是生活中没有那么多的安检—-地铁没有，博物馆没有，甚至在机场也没有人来摸你检查有没有带违规东西。这一现象大陆几乎不可能，而对于我来说是很舒服的。</p><h2><span id="东京tips">东京tips</span></h2><ol><li>从成田到东京市内可以坐skyliner，这个可以在网上直接订票，然后凭借二维码直接刷码入场。不过价钱有点小贵，但是车上很空；</li><li>东京迪士尼海洋馆没有漫威和星球大战的区域，也没有他们的周边卖；</li><li>宫崎骏美术馆需要至少提前一个月买票，如果实在没有票可以尝试去闲鱼购买，价钱比淘宝上便宜很多；</li><li>如果三年内两次入境日本，可以办理日本免签了；</li></ol><p>8天很快就过去了，我这一次没有去的地方还很多：明治神宫、吉普力博物馆、晴空塔、棒球场、涩谷、池袋等等等等。但是整体玩下来，感觉到东京无愧于亚洲第一城市，繁华、奢靡、喧闹、庞大，这样的形容词来形容它的日和夜。静与杂，非常和谐的充斥在这座城市的24小时。对于日本来说，东京承担着“北京+上海”的职责。它在1945年被美军轰炸，而1964年就举办了东京奥运会，再生速度简直惊人！</p><p>东京，是一个规则更加分明、细节更加发达的城市，但是这个城市里又容纳了各种各样的人和他们的文化，无论是奥特曼还是哥斯拉，火影忍者还是AKB48，每天发生着不同的故事，为这个城市增加了无限多的可能性。我这次仅仅是走马观花，东京给我的感觉就是这样一个干净、安全，人与人之间礼貌、尊重、信任的城市。作为一个游客，我还是想再玩一次！</p>]]></content>
    
    <summary type="html">
    
      东京八天根本玩不完，要真的想比较细致的感受，至少要15天
    
    </summary>
    
      <category term="坠乱花天" scheme="http://yoursite.com/categories/%E5%9D%A0%E4%B9%B1%E8%8A%B1%E5%A4%A9/"/>
    
    
      <category term="旅游" scheme="http://yoursite.com/tags/%E6%97%85%E6%B8%B8/"/>
    
      <category term="日本" scheme="http://yoursite.com/tags/%E6%97%A5%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>Zabbix添加多个微信告警渠道</title>
    <link href="http://yoursite.com/2019/11/27/Zabbix%E6%B7%BB%E5%8A%A0%E5%A4%9A%E4%B8%AA%E5%BE%AE%E4%BF%A1%E5%91%8A%E8%AD%A6%E6%B8%A0%E9%81%93/"/>
    <id>http://yoursite.com/2019/11/27/Zabbix添加多个微信告警渠道/</id>
    <published>2019-11-27T07:44:35.000Z</published>
    <updated>2019-11-27T13:01:04.000Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>我们的zabbix监控项好几千个，这些告警都是使用同一个微信公众号的应用去报警，这样很多告警刷来刷去，就会把一些重要告警淹没。于是我们一方面做了更加详细的告警分级，而且也增加多个微信应用。让每个应用更加有针对性的告警，就不再大杂烩了，避免重要报警遗漏。</p><p>本文目的就是创建一个新的微信应用，专门用来告警这个Templates下的情况：<br><img src="/images/proxy33.png" alt="akb48"></p><p>首先，先去微信企业号里创建一个新的应用，如图：<br><img src="/images/proxy32.png" alt="akb48"></p><p>然后将原来<code>zabbix-server</code>上的<code>wechat.py</code>复制一份，比如叫<code>proxysql-wechat.py</code>，修改对应的<code>corpsecret</code>和<code>agentid</code>，改成新应用的。这个脚本可以去看<a href="https://rorschachchan.github.io/2018/01/10/Zabbix3-0%E6%90%AD%E9%85%8D%E5%BE%AE%E4%BF%A1%E4%BC%81%E4%B8%9A%E5%8F%B7%E6%8A%A5%E8%AD%A6/" target="_blank" rel="noopener">https://rorschachchan.github.io/2018/01/10/Zabbix3-0%E6%90%AD%E9%85%8D%E5%BE%AE%E4%BF%A1%E4%BC%81%E4%B8%9A%E5%8F%B7%E6%8A%A5%E8%AD%A6/</a> 。</p><p>下面就来到zabbix server的Web端，首先<code>Administrain---Media Types</code>，增加一个新的告警媒介<code>Proxysql-wechat</code>，使用的脚本就是刚刚复制出来的<code>proxysql-wechat.py</code>：<br><img src="/images/proxy34.png" alt="akb48"></p><p>然后再去<code>Users</code>里创建一个新的用户，因为原来的<code>Administrator</code>已经有了微信告警，所以要创建一个新的用户来专门接收<code>proxysql-wechat.py</code>的告警：<br><img src="/images/proxy35.png" alt="akb48"></p><p>把它的<code>media</code>改成<code>Proxysql-wechat</code>：<br><img src="/images/proxy36.png" alt="akb48"></p><p>下一步很容易遗忘，就是在<code>Permissions</code>里给这个用户对应的Templates下所涉及用户组的全部权限，当然，如果你胆子大（比如我），可以给这个用户Super权限：<br><img src="/images/proxy37.png" alt="akb48"></p><p>告警人和告警路径已经搞定，下面就是要配置“什么样的告警才可以触发此微信应用，同时其他应用不要重复发信”。</p><p>来到<code>Configuration---Actions</code>，新创建一个triggers的action：<br><img src="/images/proxy38.png" alt="akb48"></p><p>这里声明此action只会关注templates为”proxysql单独监控”的triggers情况。</p><p>在<code>Operation details</code>别忘了配置各个环节的<code>Send to Users</code>和<code>Send only to</code>：<br><img src="/images/proxy39.png" alt="akb48"></p><p>保存之后，我们还要把原有的微信应用告警更改一下，如果不该的话，”proxysql单独监控”这个Templates触发了告警，两个微信应用都会告警，于是就把老的action改成如下：<br><img src="/images/proxy40.png" alt="akb48"></p><p>此时触发一下”proxysql单独监控”这个Templates涉及的告警项，就会看到只发送了<code>proxysql-wechat</code>，而老的wechat媒介没有被触发。<br><img src="/images/proxy41.png" alt="akb48"></p><p>微信也能正常收到信息：<br><img src="/images/proxy42.png" alt="akb48"></p><p>总结一下：如果希望新增加一个报警途径，那么就新在后台创建脚本，然后在前台创建媒介，创建连接此媒介的用户，最后在告警action上配置正确的规则就OK了！</p>]]></content>
    
    <summary type="html">
    
      查看当前服务器有多少个tcp连接最快的方法是ss -s
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="监控" scheme="http://yoursite.com/tags/%E7%9B%91%E6%8E%A7/"/>
    
      <category term="zabbix" scheme="http://yoursite.com/tags/zabbix/"/>
    
  </entry>
  
  <entry>
    <title>解决Ssh时出现Connection closed by remote host的问题</title>
    <link href="http://yoursite.com/2019/11/21/Ssh%E6%97%B6%E5%87%BA%E7%8E%B0Bad-protocol-version-identification%E7%9A%84%E5%9D%91/"/>
    <id>http://yoursite.com/2019/11/21/Ssh时出现Bad-protocol-version-identification的坑/</id>
    <published>2019-11-21T06:49:18.000Z</published>
    <updated>2019-11-21T08:08:04.000Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>今天遇到一个超奇怪的现象：同一台服务器，有的可以ssh通，有的不可以ssh通。故障机器的ssh细节如下：<br><img src="/images/ssh.png" alt="akb48" title="左边是可以连接的，右边是失败的"></p><p>发现成功的服务器会持续到：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">debug1: Remote protocol version <span class="number">2.0</span>, remote software version OpenSSH_7<span class="number">.4</span></span><br><span class="line">debug1: match: OpenSSH_7<span class="number">.4</span> pat OpenSSH*</span><br></pre></td></tr></table></figure></p><p>这一步，而失败的服务器会直接断开，并且爆<code>ssh_exchange_identification: Connection closed by remote host</code>的错误。</p><p>来到要连接的服务器上，查看<code>/var/log/secure</code>，发现每次失败的服务器每次发起ssh连接请求的时候，会有如下日志：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Nov <span class="number">19</span> <span class="number">15</span>:<span class="number">56</span>:<span class="number">26</span> iZuf6h1kfgutxc3el68z2lZ sshd[<span class="number">15096</span>]: Bad protocol version identification <span class="string">'\026\003\001'</span> <span class="keyword">from</span> X.X.X.X port <span class="number">38966</span></span><br><span class="line">Nov <span class="number">19</span> <span class="number">15</span>:<span class="number">56</span>:<span class="number">27</span> iZuf6h1kfgutxc3el68z2lZ sshd[<span class="number">15097</span>]: Bad protocol version identification <span class="string">'\026\003\001'</span> <span class="keyword">from</span> X.X.X.X port <span class="number">38990</span></span><br></pre></td></tr></table></figure></p><p>查了很多资料，基本都说请检查<code>/etc/ssh/sshd_config</code>、<code>/etc/hosts.allow</code>、<code>/etc/hosts.deny</code>、安全组和iptables。我把上面的文件在两台服务器都进行了对比，发现没有什么不同。</p><p>后来才发现这里有一个很深的坑，<code>iptables -L</code>的结果其实不一定是真的！最重要的是要看<code>iptables-save</code>的结果：<br><img src="/images/ssh2.png" alt="akb48"></p><p>上面可见<code>iptables -L</code>返回的结果虽然是空的，但是<code>iptables-save</code>却是有内容的，怪不得连接不上。</p><p>如果要删除<code>iptables-save</code>这里的规则，直接<code>service iptables stop</code>即可。但是如果在启动iptables时有<code>No config file</code>的警告错误的话，任意添加一条策略，然后保存就能正常启动了：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -P OUTPUT ACCEPT</span><br><span class="line">service iptables save</span><br></pre></td></tr></table></figure></p><p><img src="/images/ssh3.png" alt="akb48"></p>]]></content>
    
    <summary type="html">
    
      使用xshell登录服务器发现只能使用publickey，请先修改目标服务器的PasswordAuthentication为yes
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ssh" scheme="http://yoursite.com/tags/ssh/"/>
    
      <category term="itables" scheme="http://yoursite.com/tags/itables/"/>
    
  </entry>
  
  <entry>
    <title>Python从Mysql里获取值并且调用ansible批量执行的脚本</title>
    <link href="http://yoursite.com/2019/11/20/Python%E4%BB%8EMysql%E9%87%8C%E8%8E%B7%E5%8F%96%E5%80%BC%E5%B9%B6%E4%B8%94%E8%B0%83%E7%94%A8ansible%E6%89%B9%E9%87%8F%E6%89%A7%E8%A1%8C%E7%9A%84%E8%84%9A%E6%9C%AC/"/>
    <id>http://yoursite.com/2019/11/20/Python从Mysql里获取值并且调用ansible批量执行的脚本/</id>
    <published>2019-11-20T11:17:34.000Z</published>
    <updated>2019-11-20T11:39:26.000Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>我们的服务器资产信息都是在购买的时候就记录在mysql里的，表结构如图：<br><img src="/images/ansibleip3.png" alt="akb48"></p><p>可见我们的服务器命名都是有标准的，即<code>Ez4IP_地域缩写_模块名</code>，如果有T就是测试环境没有T就是正式环境，现在就是要从mysql里取出来对应的值然后再由ansible 2.7批量执行命令，脚本如下：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># !/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># 作者：ChrisChan</span></span><br><span class="line"><span class="comment"># 用途：海外模块获取IP脚本，首先先从mysql数据库里获取对应IP，然后写上对应的命令，批量操作</span></span><br><span class="line"><span class="comment"># 注意！这里写死了Ez4ip_XX_xx的格式，如果有需要则自己手动更改</span></span><br><span class="line"><span class="keyword">import</span> pymysql, argparse, os, json, shutil</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"><span class="keyword">from</span> ansible.parsing.dataloader <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">from</span> ansible.vars.manager <span class="keyword">import</span> VariableManager</span><br><span class="line"><span class="keyword">from</span> ansible.inventory.manager <span class="keyword">import</span> InventoryManager</span><br><span class="line"><span class="keyword">from</span> ansible.playbook.play <span class="keyword">import</span> Play</span><br><span class="line"><span class="keyword">from</span> ansible.executor.playbook_executor <span class="keyword">import</span> PlaybookExecutor</span><br><span class="line"><span class="keyword">from</span> ansible.executor.task_queue_manager <span class="keyword">import</span> TaskQueueManager</span><br><span class="line"><span class="keyword">from</span> ansible.plugins.callback <span class="keyword">import</span> CallbackBase</span><br><span class="line"><span class="keyword">import</span> ansible.constants <span class="keyword">as</span> C</span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令行参数</span></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">'本脚本先从mysql获取内网IP地址，然后回滚'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'-i'</span>, <span class="string">'--iii'</span>, metavar=<span class="string">'目标模块名,如Ez4ip_FK_messagepushservice'</span>, required=<span class="keyword">True</span>, dest=<span class="string">'hosts'</span>, nargs=<span class="string">'+'</span>, help=<span class="string">'请必须输入一个模块名，不然无法执行数据库查询'</span>)  <span class="comment"># required表示此字段一定需要,nargs=’+’ 表示至少一个参数</span></span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkSQL</span><span class="params">(i)</span>:</span></span><br><span class="line">    <span class="comment"># 使用cursor()方法获取操作游标</span></span><br><span class="line">    cursor = db.cursor()</span><br><span class="line">    <span class="comment"># SQL 查询语句</span></span><br><span class="line">    sql = <span class="string">"select * from cloudresource_aws_instance where instance_name regexp '"</span> + i +<span class="string">"' and project_name regexp 'ez4ip';"</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        cursor.execute(sql)</span><br><span class="line">        results = cursor.fetchall()</span><br><span class="line">        <span class="comment"># 获取所有记录写到文件里，这个文件将来给ansible用</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> results:</span><br><span class="line">            instance_name = row[<span class="number">3</span>]</span><br><span class="line">            instance_innerip = row[<span class="number">4</span>]</span><br><span class="line">            print(<span class="string">"instance_name=%s,instance_innerip=%s"</span> % (instance_name, instance_innerip))</span><br><span class="line">            f.write(<span class="string">'\n'</span>+instance_innerip)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        print(<span class="string">"出现错误，mysql无法获取到数据！"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResultCallback</span><span class="params">(CallbackBase)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    重构ansible输出</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        super(ResultCallback, self).__init__(*args, **kwargs)</span><br><span class="line">        self.host_ok = &#123;&#125;</span><br><span class="line">        self.host_unreachable = &#123;&#125;</span><br><span class="line">        self.host_failed = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">v2_runner_on_ok</span><span class="params">(self, result, **kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""成功"""</span></span><br><span class="line">        self.host_ok[result._host.name] = result._result[<span class="string">"stdout"</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">v2_runner_on_unreachable</span><span class="params">(self, result, **kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""不可达"""</span></span><br><span class="line">        self.host_unreachable[result._host.name] = result._result[<span class="string">"msg"</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">v2_runner_on_failed</span><span class="params">(self, result, ignore_errors=False, **kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""失败"""</span></span><br><span class="line">        self.host_failed[result._host.name] = result._result[<span class="string">"stderr"</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">runner</span><span class="params">(ansible_host_path, module, args)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    类似Ad-Hoc命令</span></span><br><span class="line"><span class="string">    :param ansible_host_path: 一个清单文件，一行一个ip就行</span></span><br><span class="line"><span class="string">    :param module:</span></span><br><span class="line"><span class="string">    :param args:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    Options = namedtuple(<span class="string">'Options'</span>,</span><br><span class="line">                         [<span class="string">'connection'</span>,</span><br><span class="line">                          <span class="string">'module_path'</span>,</span><br><span class="line">                          <span class="string">'forks'</span>,</span><br><span class="line">                          <span class="string">'private_key_file'</span>,</span><br><span class="line">                          <span class="string">'remote_user'</span>,</span><br><span class="line">                          <span class="string">'become'</span>,</span><br><span class="line">                          <span class="string">'become_method'</span>,</span><br><span class="line">                          <span class="string">'become_user'</span>,</span><br><span class="line">                          <span class="string">'check'</span>,</span><br><span class="line">                          <span class="string">'diff'</span>])</span><br><span class="line">    options = Options(connection=<span class="string">'smart'</span>,</span><br><span class="line">                      module_path=<span class="keyword">None</span>,</span><br><span class="line">                      forks=<span class="number">10</span>,</span><br><span class="line">                      private_key_file=<span class="string">"/root/.ssh/id_rsa"</span>, <span class="comment"># 你的私钥</span></span><br><span class="line">                      remote_user=<span class="string">"guest"</span>,      <span class="comment"># 远程用户</span></span><br><span class="line">                      become=<span class="keyword">True</span>,</span><br><span class="line">                      become_method=<span class="string">"sudo"</span>,</span><br><span class="line">                      become_user=<span class="string">"root"</span>,<span class="comment"># sudo的用户</span></span><br><span class="line">                      check=<span class="keyword">False</span>,</span><br><span class="line">                      diff=<span class="keyword">False</span>)</span><br><span class="line">    <span class="comment"># 主要加载设置的变量</span></span><br><span class="line">    loader = DataLoader()</span><br><span class="line">    <span class="comment"># 一个密码参数，可以设置为None，默认即可，没什么影响，我用的是秘钥登录</span></span><br><span class="line">    passwords = dict(vault_pass=<span class="string">'secret'</span>)</span><br><span class="line">    <span class="comment"># 结果回调</span></span><br><span class="line">    callback = ResultCallback()</span><br><span class="line">    <span class="comment"># 设置传入的机器清单</span></span><br><span class="line">    inventory = InventoryManager(loader=loader, sources=[ansible_host_path])</span><br><span class="line">    <span class="comment"># 加载之前的变量</span></span><br><span class="line">    variable_manager = VariableManager(loader=loader, inventory=inventory)</span><br><span class="line">    play_source = dict(</span><br><span class="line">            name=<span class="string">"Ansible Play"</span>,</span><br><span class="line">            hosts=<span class="string">"all"</span>,           <span class="comment"># all表示匹配清单所有机器，看源码发现的</span></span><br><span class="line">            gather_facts=<span class="string">"no"</span>,</span><br><span class="line">            tasks=[</span><br><span class="line">                dict(action=dict(module=module, args=args), register=<span class="string">'shell_out'</span>),</span><br><span class="line">             ]</span><br><span class="line">        )</span><br><span class="line">    play = Play().load(play_source, variable_manager=variable_manager, loader=loader)</span><br><span class="line"></span><br><span class="line">    tqm = <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        tqm = TaskQueueManager(</span><br><span class="line">                  inventory=inventory,</span><br><span class="line">                  variable_manager=variable_manager,</span><br><span class="line">                  loader=loader,</span><br><span class="line">                  options=options,</span><br><span class="line">                  passwords=passwords,</span><br><span class="line">                  stdout_callback=callback,</span><br><span class="line">              )</span><br><span class="line">        result = tqm.run(play)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">if</span> tqm <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            tqm.cleanup()</span><br><span class="line">        shutil.rmtree(C.DEFAULT_LOCAL_TMP, <span class="keyword">True</span>)</span><br><span class="line">    <span class="comment"># 重构输出</span></span><br><span class="line">    result_raw = &#123;<span class="string">'success'</span>: &#123;&#125;, <span class="string">'failed'</span>: &#123;&#125;, <span class="string">'unreachable'</span>: &#123;&#125;&#125;</span><br><span class="line">    <span class="keyword">for</span> host, result <span class="keyword">in</span> callback.host_ok.items():</span><br><span class="line">        result_raw[<span class="string">"success"</span>][host] = result</span><br><span class="line">    <span class="keyword">for</span> host, result <span class="keyword">in</span> callback.host_unreachable.items():</span><br><span class="line">        result_raw[<span class="string">'failed'</span>][host] = result</span><br><span class="line">    <span class="keyword">for</span> host, result <span class="keyword">in</span> callback.host_failed.items():</span><br><span class="line">        result_raw[<span class="string">'unreachable'</span>][host] = result</span><br><span class="line">    <span class="keyword">return</span> json.dumps(result_raw, indent=<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接mysql</span></span><br><span class="line">db = pymysql.connect(<span class="string">"mysql连接地址"</span>, <span class="string">"mysql账号"</span>, <span class="string">"mysql密码"</span>, <span class="string">"database名称"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开文件                    </span></span><br><span class="line">f = open(<span class="string">'/home/chens/instance.txt'</span>,<span class="string">'a'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ansible文件所在的路径</span></span><br><span class="line">ansible_host_path = os.path.join(os.getcwd(), <span class="string">"instance.txt"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">for</span> host <span class="keyword">in</span> args.hosts:</span><br><span class="line">command = <span class="string">"hostname &amp;&amp; date &amp;&amp; whoami"</span></span><br><span class="line">        module = host.split(<span class="string">"_"</span>,<span class="number">2</span>)[<span class="number">2</span>]</span><br><span class="line">        print(<span class="string">"输入的参数是："</span> + host)</span><br><span class="line">        print(<span class="string">"对应的模块是："</span> + module)</span><br><span class="line">        chenchenchen = <span class="string">"cd /opt/"</span> + module +<span class="string">"/ &amp;&amp; ./stop.sh &amp;&amp; ./start.sh"</span></span><br><span class="line">        <span class="keyword">print</span> (<span class="string">"重启命令是："</span> +chenchenchen)</span><br><span class="line">        checkSQL(host)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">"ansible批量执行出现错误，请检查！"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭文件                              </span></span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭数据库连接                        </span></span><br><span class="line">db.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行ansible</span></span><br><span class="line">data = runner(ansible_host_path, <span class="string">"shell"</span>, command)</span><br><span class="line">print(data)</span><br><span class="line"></span><br><span class="line">os.remove(ansible_host_path)</span><br></pre></td></tr></table></figure></p><p>执行效果如下：<br><img src="/images/ansibleip4.png" alt="akb48" title="本脚本是可以执行多个组"></p><p>上面的脚本里执行的是ansible语句，如果想要执行playbook，可以看一下<a href="https://blog.csdn.net/CCjedweat/article/details/88683152" target="_blank" rel="noopener">https://blog.csdn.net/CCjedweat/article/details/88683152</a> 这位大神的文章。</p>]]></content>
    
    <summary type="html">
    
      python是可以直接比较字符串的，如果模块在部署后，文件夹后缀是时间，那么可以直接比较文件名，取最大的值就是上一个版本，直接回滚之
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="python2" scheme="http://yoursite.com/tags/python2/"/>
    
      <category term="ansible api" scheme="http://yoursite.com/tags/ansible-api/"/>
    
  </entry>
  
  <entry>
    <title>AWS数据迁移到阿里云的一些坑</title>
    <link href="http://yoursite.com/2019/11/07/AWS%E9%85%8D%E7%BD%AE%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    <id>http://yoursite.com/2019/11/07/AWS配置的一些问题解决/</id>
    <published>2019-11-07T09:16:29.000Z</published>
    <updated>2019-11-08T06:41:18.000Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>最近在忙AWS迁移阿里云的事情，在这之中发现了也解决了很多坑，这里记录一下。</p><h2><span id="只读rds修改配置组无效果">只读RDS修改配置组无效果</span></h2><p>我们这一次数据库的迁移是重点任务，考虑到AWS的源库都是无公网访问权限的，于是就创建一个有公网权限的只读库（read replica），然后在阿里云是用DTS，以这个只读库作为源库，然后进行数据的<code>增量同步</code>。这里有一点：“源库”的binlog必须是ROW模式，而默认的AWS创建的源库是MIX模式，于是就需要修改一下参数组（parameter group），将其改成ROW：<br><img src="/images/aws1.png" alt="akb48"></p><p>然后配置只读实例引用这个参数组，但是要等待参数组状态是（pending reboot），重启。</p><p>但是这里有一个大坑！那么就是<code>read replica</code>的<code>Backup retention period</code>值不可以是0，不然参数组即使重启了是不会生效的！<br><img src="/images/aws2.png" alt="akb48"></p><p>当然直接使用DTS并不是一个好方案，因为即使是同一个可用区，比如都在法兰克福，但是不同厂商还是会有网络影响，所以更加推荐就是搭一个专线，然后走专线同步。而且DTS的时候，切忌目标库发生与源库不同的操作造成数据错乱，那样就前功尽弃了。</p><p>DTS的原理就是不断的读取binlog然后执行binlog，但是row模式的binlog特别巨大，再加上网络有波动或者源库有跟主库名称一样但是内容不一致的数据导致所有唯一主键都要报错一遍，那么延迟可能就是一辈子的事儿…</p><h2><span id="无公网ec2访问外网">无公网ec2访问外网</span></h2><p>本次迁移数据除了mysql还有redis，但是AWS的redis也都是内网服务器，于是这样我们就做了外网NLB，在阿里云的redis上做主从配置，并且在阿里云的redis.conf里把主写成了NLB的域名，这里如果担心NLB域名后面的IP发生变化而故障，那么可以事先在aws里购买弹性IP，然后将域名绑定死对应的IP就不怕了。</p><p>但是如果想要返回来，让阿里云的redis做主，AWS这个无公网的ec2 redis做从的话，用外网NLB就不行了。不过AWS比较好，就是ec2虽然表面没有公网IP，但是它有一个<code>隐藏的公网</code>，比如我这个ec2:<br><img src="/images/aws3.png" alt="akb48"></p><p>可见它没有公网IP，但是在服务器里使用<code>curl myip.ipip.net</code>可以获取到它的公网出口IP：<br><img src="/images/aws4.png" alt="akb48"></p><p>将这个IP写到阿里云的安全组就可以在ec2这边访问到阿里云的公网了！</p><h2><span id="dms白名单问题">DMS白名单问题</span></h2><p>AWS的数据迁移叫DMS，这个地方也有一个坑，就是<code>Replication instances</code>的公网IP可能是不对的，如图：<br><img src="/images/aws5.png" alt="akb48"></p><p>我把图中的<code>Public IP address</code>填写到了阿里云对应数据库的白名单里但是test无法成功，后来改成<code>0.0.0.0/0</code>之后登陆上去一看，连接的IP并不是图中的IP，这真的是一个大坑！</p>]]></content>
    
    <summary type="html">
    
      AWS的change_resource_record_sets是不能直接更改解析方式的，如果想要从A记录改成CNAME记录，那就要先把原来的删除，再重新建立
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="aws" scheme="http://yoursite.com/tags/aws/"/>
    
      <category term="运维" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Alertmanager配置微信告警和钉钉告警</title>
    <link href="http://yoursite.com/2019/10/29/Alertmanager%E9%85%8D%E7%BD%AE%E5%BE%AE%E4%BF%A1%E5%91%8A%E8%AD%A6%E5%92%8C%E9%92%89%E9%92%89%E5%91%8A%E8%AD%A6/"/>
    <id>http://yoursite.com/2019/10/29/Alertmanager配置微信告警和钉钉告警/</id>
    <published>2019-10-29T06:50:12.000Z</published>
    <updated>2019-10-31T11:53:36.000Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="配置微信告警">配置微信告警</span></h2><p>首先先去搞一个微信企业号，创建一个新的应用：<br><img src="/images/prometheus16.png" alt="akb48"></p><p>创建微信企业号的过程可以见<a href="https://rorschachchan.github.io/2018/01/10/Zabbix3-0%E6%90%AD%E9%85%8D%E5%BE%AE%E4%BF%A1%E4%BC%81%E4%B8%9A%E5%8F%B7%E6%8A%A5%E8%AD%A6/" target="_blank" rel="noopener">https://rorschachchan.github.io/2018/01/10/Zabbix3-0%E6%90%AD%E9%85%8D%E5%BE%AE%E4%BF%A1%E4%BC%81%E4%B8%9A%E5%8F%B7%E6%8A%A5%E8%AD%A6/</a> 这篇文章。</p><p>来到prometheus服务器里，编辑<code>alertmanager.yml</code>如下：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">global</span>:</span><br><span class="line">  resolve_timeout: <span class="number">5</span>m</span><br><span class="line">  smtp_smarthost: <span class="string">'smtp.163.com:465'</span></span><br><span class="line">  smtp_from: <span class="string">'chenx1242@163.com'</span></span><br><span class="line">  smtp_auth_username: <span class="string">'chenx1242@163.com'</span></span><br><span class="line">  smtp_auth_password: <span class="string">'邮箱密码'</span></span><br><span class="line">  smtp_require_tls: false</span><br><span class="line">  wechat_api_url: http://qyapi.weixin.qq.com/cgi-bin/<span class="comment">#这里是wechat对外接口</span></span><br><span class="line"></span><br><span class="line">templates:</span><br><span class="line">  - <span class="string">'./template/*.tmpl'</span><span class="comment"># 模板的地址</span></span><br><span class="line"></span><br><span class="line">route:</span><br><span class="line">  group_by: [<span class="string">'chentest'</span>]</span><br><span class="line">  group_wait: <span class="number">10</span>s</span><br><span class="line">  group_interval: <span class="number">30</span>s</span><br><span class="line">  repeat_interval: <span class="number">30</span>m</span><br><span class="line">  receiver: <span class="string">'GOOGLE-email'</span></span><br><span class="line">  routes:<span class="comment"># 这里做了一个路由</span></span><br><span class="line">  - receiver: <span class="string">'wechat'</span></span><br><span class="line">    group_wait: <span class="number">30</span>s<span class="comment"># 这个路由会覆盖上面的值</span></span><br><span class="line"></span><br><span class="line">receivers:</span><br><span class="line">- name: <span class="string">'GOOGLE-email'</span></span><br><span class="line">  email_configs:</span><br><span class="line">  - send_resolved: true</span><br><span class="line">    to: <span class="string">'chenshuo955@gmail.com'</span></span><br><span class="line">    html: <span class="string">'&#123;&#123; template "email.html" . &#125;&#125;'</span></span><br><span class="line">    headers: &#123; Subject: <span class="string">"[WARN]Prometheus告警邮件"</span> &#125;</span><br><span class="line"></span><br><span class="line">- name: <span class="string">'wechat'</span></span><br><span class="line">  wechat_configs:</span><br><span class="line">  - corp_id: <span class="string">'XXXX'</span><span class="comment"># 企业信息("我的企业"---&gt;"CorpID"[在底部])</span></span><br><span class="line">    to_user: <span class="string">'@all'</span><span class="comment"># 所有人就是@all，或者是指定人</span></span><br><span class="line">    agent_id: <span class="string">'1000003'</span> <span class="comment"># 企业微信("企业应用"--&gt;"自定应用"[Prometheus]--&gt; "AgentId")</span></span><br><span class="line">    api_secret: <span class="string">'E8DR55yEDwp0E3d0mpjsdWdt0pFNF9i7kQPzFfsQVbI'</span><span class="comment"># 企业微信("企业应用"--&gt;"自定应用"[Prometheus]--&gt; "Secret") </span></span><br><span class="line">    send_resolved: true<span class="comment">#问题解决了要发信息</span></span><br><span class="line">    message: <span class="string">'&#123;&#123; template "wechat.html" . &#125;&#125;'</span><span class="comment"># 指定模板</span></span><br><span class="line"></span><br><span class="line">inhibit_rules:</span><br><span class="line">  - source_match:</span><br><span class="line">      severity: <span class="string">'critical'</span></span><br><span class="line">    target_match:</span><br><span class="line">      severity: <span class="string">'warning'</span></span><br><span class="line">    equal: [<span class="string">'alertname'</span>, <span class="string">'dev'</span>, <span class="string">'instance'</span>]</span><br></pre></td></tr></table></figure></p><p>然后来到当前目录的<code>/template/</code>里创建<code>wechat.tmpl</code>，如下：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; define <span class="string">"wechat.html"</span> &#125;&#125;</span><br><span class="line">    &#123;&#123; range .Alerts &#125;&#125;</span><br><span class="line">    ========start==========</span><br><span class="line">    告警程序: prometheus_alert</span><br><span class="line">    告警级别: &#123;&#123; .Labels.severity &#125;&#125;</span><br><span class="line">    告警类型: &#123;&#123; .Labels.alertname &#125;&#125;</span><br><span class="line">    故障主机: &#123;&#123; .Labels.instance &#125;&#125;</span><br><span class="line">    告警主题: &#123;&#123; .Annotations.summary &#125;&#125;</span><br><span class="line">    告警详情: &#123;&#123; .Annotations.description &#125;&#125;</span><br><span class="line">    触发时间: &#123;&#123; .StartsAt.Format <span class="string">"2019-01-01 01:01:01"</span> &#125;&#125;</span><br><span class="line">    ========end==========</span><br><span class="line">    &#123;&#123; end &#125;&#125;</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure></p><p>启动alertmanager，不就就可以在微信上看到信息了：<br><img src="/images/prometheus17.png" alt="akb48"></p><h2><span id="配置钉钉告警">配置钉钉告警</span></h2><p>首先先创建钉钉机器人并且获取对应的token:<br><img src="/images/prometheus18.png" alt="akb48"></p><p>然后检查一下自己的golang版本，网络上流行的timonwong的webhook是不能用于1.13版本的，所以要安装1.11版本的golang。安装方法golang 1.11方法如下：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://studygolang.com/dl/golang/go1<span class="number">.11</span>.linux-amd64.tar.gz</span><br><span class="line">tar zxvf go1<span class="number">.11</span>.linux-amd64.tar.gz -C /usr/local</span><br></pre></td></tr></table></figure></p><p>修改<code>/etc/profile</code>,在文件末尾添加如下内容:<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#go setting</span></span><br><span class="line">export GOROOT=/usr/local/go</span><br><span class="line">export GOPATH=/usr/local/gopath</span><br><span class="line">export PATH=$PATH:$GOROOT/bin</span><br></pre></td></tr></table></figure></p><p>执行<code>source /etc/profile</code>配置文件的环境变量立刻生效，此时在<code>/usr/local/go/src</code>路径下：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir -pv github.com/timonwong</span><br><span class="line">cd github.com/timonwong</span><br><span class="line">git clone https://github.com/timonwong/prometheus-webhook-dingtalk.git</span><br><span class="line">cd  prometheus-webhook-dingtalk/</span><br><span class="line">make</span><br></pre></td></tr></table></figure></p><p>然后执行效果如下，同时<code>/usr/local/go/src/github.com/timonwong/prometheus-webhook-dingtalk</code>路径下多了一个<code>prometheus-webhook-dingtalk</code>：<br><img src="/images/prometheus21.png" alt="akb48"></p><p>然后在后台执行这个<code>prometheus-webhook-dingtalk</code>：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./prometheus-webhook-dingtalk --ding.profile=<span class="string">"chen_dingding=https://oapi.dingtalk.com/robot/send?access_token=XXXXX"</span>   <span class="number">2</span>&gt;&amp;<span class="number">1</span> <span class="number">1</span>&gt;dingding.log &amp;<span class="comment">#创建一个频道chen_dingding</span></span><br></pre></td></tr></table></figure></p><p>然后在<code>alertmanager.yaml</code>增加钉钉报警相关的信息：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- receiver: <span class="string">'dingding'</span></span><br><span class="line">  group_wait: <span class="number">30</span>s</span><br><span class="line">  match:</span><br><span class="line">    go: gothreads</span><br><span class="line"></span><br><span class="line">- name: <span class="string">'dingding'</span></span><br><span class="line">  webhook_configs:</span><br><span class="line">  - send_resolved: true</span><br><span class="line">    url: http://localhost:<span class="number">8060</span>/dingtalk/chens_dingding/send<span class="comment">#这里频道要一致</span></span><br></pre></td></tr></table></figure></p><p>然后重启Alarmmanager即可，一会就能收到报警：<br><img src="/images/prometheus22.png" alt="akb48"></p><p>至于这个钉钉与alertmanager的webhook勾连的细节，可以去看<a href="http://ylzheng.com/2018/03/01/alertmanager-webhook-dingtalk/" target="_blank" rel="noopener">http://ylzheng.com/2018/03/01/alertmanager-webhook-dingtalk/</a> 。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://www.cnblogs.com/xzkzzz/p/10211394.html" target="_blank" rel="noopener">https://www.cnblogs.com/xzkzzz/p/10211394.html</a><br><a href="https://github.com/prometheus/alertmanager/issues/1385" target="_blank" rel="noopener">https://github.com/prometheus/alertmanager/issues/1385</a><br><a href="https://blog.rj-bai.com/post/158.html" target="_blank" rel="noopener">https://blog.rj-bai.com/post/158.html</a></p>]]></content>
    
    <summary type="html">
    
      这几天又是云迁移又是GDPR，累的吐血
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="监控" scheme="http://yoursite.com/tags/%E7%9B%91%E6%8E%A7/"/>
    
      <category term="Prometheus" scheme="http://yoursite.com/tags/Prometheus/"/>
    
  </entry>
  
  <entry>
    <title>Prometheus配置Alertmanager并实现邮箱告警</title>
    <link href="http://yoursite.com/2019/10/12/Prometheus%E5%A2%9E%E5%8A%A0%E5%91%8A%E8%AD%A6%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9B%91%E6%8E%A7%E9%A1%B9/"/>
    <id>http://yoursite.com/2019/10/12/Prometheus增加告警和自定义监控项/</id>
    <published>2019-10-12T02:59:31.000Z</published>
    <updated>2019-10-31T11:51:00.000Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="添加告警配置">添加告警配置</span></h2><p>在<a href="https://rorschachchan.github.io/2019/10/08/%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2Prometheus/" target="_blank" rel="noopener">https://rorschachchan.github.io/2019/10/08/%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2Prometheus/</a> 里已经搭建好了Prometheus，当时是把主配置文件<code>prometheus.yml</code>写在了<code>/mnt/promethues/server</code>，然后挂载到相关容器里。现在也在相同目录里编写一个<code>rules.yml</code>，如下：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">groups:</span><br><span class="line">- name: example</span><br><span class="line">  rules:</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Alert for any instance that is unreachable for &gt;5 minutes.</span></span><br><span class="line">  - alert: load15在告警!<span class="comment"># 告警规则的名称</span></span><br><span class="line">    expr: node_load15&#123;group=<span class="string">"server"</span>,instance=<span class="string">"172.31.0.85:9100"</span>,job=<span class="string">"server"</span>&#125; &gt; <span class="number">0</span><span class="comment">#给予PromQL的表达式的告警触发条件</span></span><br><span class="line">    <span class="keyword">for</span>: <span class="number">1</span>m<span class="comment">#触发条件持续多久之后发送告警</span></span><br><span class="line">    labels:</span><br><span class="line">      severity: node_load<span class="comment">#自定义标签</span></span><br><span class="line">    annotations:<span class="comment">#描述，这段信息会作为参数发送给Alertmanager</span></span><br><span class="line">      summary: <span class="string">"实例 &#123;&#123; $labels.instance &#125;&#125; 的load15大于 0"</span></span><br><span class="line">      description: <span class="string">"&#123;&#123; $labels.instance &#125;&#125; of job &#123;&#123; $labels.job &#125;&#125; 值大于 0."</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Alert for any instance that has a median request latency &gt;1s.</span></span><br><span class="line">  - alert: gothreads过多啊！</span><br><span class="line">    expr: go_threads&#123;group=<span class="string">"server"</span>,instance=<span class="string">"172.31.0.85:9100"</span>,job=<span class="string">"server"</span>&#125; &gt; <span class="number">5</span></span><br><span class="line">    <span class="keyword">for</span>: <span class="number">1</span>m</span><br><span class="line">    annotations:</span><br><span class="line">      summary: <span class="string">"&#123;&#123; $labels.instance &#125;&#125;的gothreads过多"</span></span><br><span class="line">      description: <span class="string">"&#123;&#123; $labels.instance &#125;&#125; has a high gotheads: (current value: &#123;&#123; $value &#125;&#125;s)."</span></span><br></pre></td></tr></table></figure></p><p>保存退出之后，在<code>prometheus.yml</code>里的<code>rule_files</code>字段做一下修改：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rule_files:</span><br><span class="line">  - <span class="string">'rules.yml'</span><span class="comment">#将刚刚编写的rules.yml结合进去</span></span><br></pre></td></tr></table></figure></p><p>然后重启一下prometheus（如果不是容器部署的，就是<code>killall -HUP prometheus</code>），再去Prometheus的web界面，先是<code>Status--Rules</code>，看到我们的规则已经导入进去了，并且正常在运行：<br><img src="/images/prometheus11.png" alt="akb48"></p><p>再点击Alerts，就会看到目前告警处于<code>pending</code>，也就是说准备要告警了：<br><img src="/images/prometheus9.png" alt="akb48"></p><p>刷新一下，就看到状态已经变成了<code>Firing</code>，即告警了：<br><img src="/images/prometheus10.png" alt="akb48"></p><p>配置已经成功！不过不要过分激动，这个demo实在是太简单了，我们会在实际的工作里根据具体的场景增加一下难度。</p><h2><span id="安装alertmanager">安装Alertmanager</span></h2><p>目前我们已经配置了告警但是还没有配置发送通知，而实现发送通知就需要靠<code>Alertmanager</code>来完成。正常来说<code>Alertmanager</code>没必要跟<code>Prometheus</code>装在一起，只要他俩能正常通讯即可。但是我资源紧张，就安装到一台服务器里了，具体安装方法如下：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /mnt/<span class="comment">#我安装在mnt目录下</span></span><br><span class="line">wget https://github.com/prometheus/alertmanager/releases/download/v0<span class="number">.19</span><span class="number">.0</span>/alertmanager<span class="number">-0.19</span><span class="number">.0</span>.linux-amd64.tar.gz</span><br><span class="line">tar -zxvf alertmanager<span class="number">-0.19</span><span class="number">.0</span>.linux-amd64.tar.gz</span><br><span class="line">cd  alertmanager<span class="number">-0.19</span><span class="number">.0</span>.linux-amd64</span><br><span class="line">./alertmanager   <span class="comment">#这个是前台运行的</span></span><br></pre></td></tr></table></figure></p><p>启动之后，发现9093和9094这两个端口开启了。此时我们再回到<code>prometheus.yml</code>，在最后添加如下内容，把<code>Alertmanager</code>配置到<code>prometheus.yml</code>中：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">alerting:</span><br><span class="line">  alertmanagers:</span><br><span class="line">  - scheme: http</span><br><span class="line">    static_configs:</span><br><span class="line">    - targets:</span><br><span class="line">      - <span class="string">"172.31.0.85:9093"</span><span class="comment">#这个是Alertmanager所在的服务器IP地址</span></span><br></pre></td></tr></table></figure></p><p>这个配置告诉Prometheus，当发生告警时，将告警信息发送到<code>Alertmanager</code>，<code>Alertmanager</code>的地址为<code>http://172.31.0.85:9093</code>。也可以使用命名行的方式指定<code>Alertmanager</code>：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./prometheus -alertmanager.url=http://<span class="number">172.31</span><span class="number">.0</span><span class="number">.85</span>:<span class="number">9093</span></span><br></pre></td></tr></table></figure></p><p>此时我们登陆<code>http://Alertmanager公网IP:9093/#/alerts</code>，就会看到prometheus的alerts的内容出现在了<code>Alertmanager</code>里：<br><img src="/images/prometheus12.png" alt="akb48" title="左边是prometheus，右边是alertmanagers"></p><p>然后点击具体的告警项目，就会看到一些细节，比如我们在<code>rules.yml</code>里写的<code>description</code>和<code>summary</code>：<br><img src="/images/prometheus13.png" alt="akb48"></p><h2><span id="配置alertmanager实现邮箱告警">配置Alertmanager实现邮箱告警</span></h2><p>编辑<code>alertmanager.yml</code>如下：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">global</span>:</span><br><span class="line">  resolve_timeout: <span class="number">5</span>m</span><br><span class="line">  smtp_smarthost: <span class="string">'smtp.163.com:465'</span></span><br><span class="line">  smtp_from: <span class="string">'chenx1242@163.com'</span></span><br><span class="line">  smtp_auth_username: <span class="string">'chenx1242@163.com'</span></span><br><span class="line">  smtp_auth_password: <span class="string">'这里邮箱的密码'</span></span><br><span class="line">  smtp_require_tls: false<span class="comment">#注意这个一定要写false，默认是true，若不改成false会有require_tls' is true (default) but \"smtp.qq.com:465\" does not advertise the STARTTLS extension</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#templates:</span></span><br><span class="line"> <span class="comment">#  - './template/*.tmpl'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有报警信息进入后的根路由，用来设置报警的分发策略</span></span><br><span class="line">route:</span><br><span class="line">  group_by: [<span class="string">'chentest'</span>]<span class="comment"># 这里的标签列表是接收到报警信息后的重新分组标签</span></span><br><span class="line">  group_wait: <span class="number">10</span>s<span class="comment"># 第一次等待多久时间发送一组警报的通知</span></span><br><span class="line">  group_interval: <span class="number">10</span>s<span class="comment"># 在发送新警报前的等待时间</span></span><br><span class="line">  repeat_interval: <span class="number">1</span>m<span class="comment"># 如果一个报警信息已经发送成功了，等待'repeat_interval'时间来重新发送他们</span></span><br><span class="line">  receiver: <span class="string">'GOOGLE-email'</span> <span class="comment"># 发送警报的接收者的名称，与receivers name的名称相同</span></span><br><span class="line"></span><br><span class="line">receivers:</span><br><span class="line">- name: <span class="string">'GOOGLE-email'</span></span><br><span class="line">  email_configs:<span class="comment"># 邮箱配置</span></span><br><span class="line">  - send_resolved: true<span class="comment"># 告警解决是否通知，默认是不通知</span></span><br><span class="line">    to: <span class="string">'chenshuo955@gmail.com'</span></span><br><span class="line"><span class="comment">#html: '&#123;&#123; template "email.html" . &#125;&#125;'</span></span><br><span class="line"><span class="comment">#headers: &#123; Subject: "[WARN] 报警邮件"&#125; # 接收邮件的标题</span></span><br><span class="line"></span><br><span class="line">inhibit_rules:</span><br><span class="line">  - source_match:</span><br><span class="line">      severity: <span class="string">'critical'</span></span><br><span class="line">    target_match:</span><br><span class="line">      severity: <span class="string">'warning'</span></span><br><span class="line">    equal: [<span class="string">'alertname'</span>, <span class="string">'dev'</span>, <span class="string">'instance'</span>]</span><br></pre></td></tr></table></figure></p><p>Alertmanager检查配置文件的语句：<code>./amtool check-config alertmanager.yml</code>。如果出现<code>SUCCESS</code>即文件OK！</p><p>默认Alertmanager的启动方式：<code>./alertmanager --config.file=alertmanager.yml</code>，不指定<code>config.file</code>则会去读取<code>alertmanager.yml</code>，不过我们还是用systemctl来启动，先编写<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=alertmanager</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Restart=on-failure</span><br><span class="line">ExecStart=/mnt/alertmanager<span class="number">-0.19</span><span class="number">.0</span>.linux-amd64/alertmanager --config.file=/mnt/alertmanager<span class="number">-0.19</span><span class="number">.0</span>.linux-amd64/alertmanager.yml</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure></p><p>保存之后通过<code>systemctl start alertmanager</code>启动。既然是systemctl启动的进程，那么查看日志的方法就是<code>sudo journalctl _PID=alertmanager进程号</code>：<br><img src="/images/prometheus20.png" alt="akb48"></p><p>稍等一会，Gmail就会受到邮件，如图：<br><img src="/images/prometheus14.png" alt="akb48"></p><p>可见在告警邮件里是有在<code>rules.yml</code>配置的<code>summary</code>和<code>description</code>信息。</p><p>如果要用docker部署alertmanager的话，语句如下：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run --name alertmanager --rm -d \</span><br><span class="line">-v /宿主机路径/alertmanager.yml:/etc/alertmanager/alertmanager.yml \</span><br><span class="line">--net=host \</span><br><span class="line">prom/alertmanager</span><br></pre></td></tr></table></figure></p><p>为了方便，我们会配置一个模板，这样告警邮件看起来会更加直观，那么就在<code>/mnt/alertmanager-0.19.0.linux-amd64</code>目录下新建一个template文件夹，然后创建一个<code>email.tmpl</code>如下：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; define <span class="string">"email.html"</span> &#125;&#125;</span><br><span class="line">&lt;table border=<span class="string">"1"</span>&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">                &lt;td&gt;报警项&lt;/td&gt;</span><br><span class="line">                &lt;td&gt;实例&lt;/td&gt;</span><br><span class="line">                &lt;td&gt;报警阀值&lt;/td&gt;</span><br><span class="line">                &lt;td&gt;开始时间&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">        &#123;&#123; range $i, $alert := .Alerts &#125;&#125;</span><br><span class="line">                &lt;tr&gt;</span><br><span class="line">                        &lt;td&gt;&#123;&#123; index $alert.Labels "alertname" &#125;&#125;&lt;/td&gt;</span><br><span class="line">                        &lt;td&gt;&#123;&#123; index $alert.Labels "instance" &#125;&#125;&lt;/td&gt;</span><br><span class="line">                        &lt;td&gt;&#123;&#123; index $alert.Annotations "value" &#125;&#125;&lt;/td&gt;</span><br><span class="line">                        &lt;td&gt;&#123;&#123; $alert.StartsAt &#125;&#125;&lt;/td&gt;</span><br><span class="line">                &lt;/tr&gt;</span><br><span class="line">        &#123;&#123; end &#125;&#125;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure></p><p>然后把上面<code>alertmanager.yml</code>里那几个<code>#templates、#html、#headers</code>的注释放开，重新启动alertmanager，一会就可以看到告警了：<br><img src="/images/prometheus15.png" alt="akb48"></p><p>可见模板已经配置上了。</p><h2><span id="故障排错">故障排错</span></h2><p><code>Alertmanager</code>前台启动后，会不停的刷如下的日志：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">level=error ts=<span class="number">2019</span><span class="number">-10</span><span class="number">-25</span>T06:<span class="number">50</span>:<span class="number">16.470</span>Z caller=dispatch.go:<span class="number">266</span> component=dispatcher msg=<span class="string">"Notify for alerts failed"</span> num_alerts=<span class="number">1</span> err=<span class="string">"Post http://127.0.0.1:5001/: dial tcp 127.0.0.1:5001: connect: connection refused"</span></span><br></pre></td></tr></table></figure></p><p>这个的原因是<code>alertmanager.yml</code>默认情况下的配置是所有的告警都走一个叫<code>web.hook</code>的receiver，而这个receiver配置的就是本地5001端口，如下：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">receivers:</span><br><span class="line">- name: <span class="string">'web.hook'</span></span><br><span class="line">  webhook_configs:</span><br><span class="line">  - url: <span class="string">'http://127.0.0.1:5001/'</span></span><br></pre></td></tr></table></figure></p><p>所以这个报警可以无视掉，等你配置了正确的告警方式就解决掉这个问题了。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://www.li-rui.top/2018/11/12/monitor/Prometheus%20Alertmanager%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener">https://www.li-rui.top/2018/11/12/monitor/Prometheus%20Alertmanager%E4%BD%BF%E7%94%A8/</a><br><a href="https://www.qikqiak.com/post/alertmanager-of-prometheus-in-practice/" target="_blank" rel="noopener">https://www.qikqiak.com/post/alertmanager-of-prometheus-in-practice/</a><br><a href="https://www.aneasystone.com/archives/2018/11/prometheus-in-action.html" target="_blank" rel="noopener">https://www.aneasystone.com/archives/2018/11/prometheus-in-action.html</a></p>]]></content>
    
    <summary type="html">
    
      Prometheus将数据采集和报警分成了两个模块，报警规则配置在Prometheus Servers上，然后发送报警信息到AlertManger
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="监控" scheme="http://yoursite.com/tags/%E7%9B%91%E6%8E%A7/"/>
    
      <category term="Prometheus" scheme="http://yoursite.com/tags/Prometheus/"/>
    
  </entry>
  
  <entry>
    <title>国庆武汉长沙五日游</title>
    <link href="http://yoursite.com/2019/10/11/%E5%9B%BD%E5%BA%86%E6%AD%A6%E6%B1%89%E9%95%BF%E6%B2%99%E5%85%AD%E6%97%A5%E6%B8%B8/"/>
    <id>http://yoursite.com/2019/10/11/国庆武汉长沙六日游/</id>
    <published>2019-10-11T13:37:19.000Z</published>
    <updated>2019-11-01T01:54:16.000Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>终于到了国庆，俺跟媳妇趁着中秋苏州的余温，再次选择了出去旅游。原本我打算是去重庆的，但是媳妇已经去过了，于是就拍板这次国庆假期选择去武汉、长沙玩5天，10月2号出发，不耽误看国庆阅兵。</p><p>国庆的安排：<br>10.2 下午7点在杭州东上车，大约11点到武汉站，打车去酒店，酒店周围吃吃夜宵<br>10.3 黎黄陂路街头博物馆+古德寺庙+晴川阁+吉庆街+长江大桥轮渡<br>10.4 黄鹤楼+辛亥革命纪念馆+湖北省博物馆+湖北省美术馆+粮道街+做了一个足浴歇歇脚<br>10.5 汉街+万达，中午一点在武汉站上车，下午两点半到长沙南站，橘子洲头+太平老街+国金中心+黄兴广场<br>10.6 湖南省博物馆+岳麓山，晚上7点长沙南上车返航</p><h2><span id="武汉的玩">武汉的玩</span></h2><p>我住的酒店是洪山区中北路的万达商圈，出门就是汉街。汉街是一条很长的室外购物步行街，曾经跑男来这里做过节目。作为一条网红大街，整条街两侧各色商家开门营业—-摄影馆、书店、星巴克、小饭店、耐克阿迪优衣库、DQ、鸭脖子之类的。杜莎夫人的武汉店也在汉街上，150元一张成人票，由于我之前去过伦敦的杜莎夫人这次就没有去武汉馆了。</p><p>黎黄陂路街头博物馆其实就是一条老街，以宋庆龄故居开始往里走，那一片区域都是各帝国主义列强以前在武汉的租界，能看到有外国风格的老建筑，虽然那些建筑窗户和门都破破旧旧，跟宋庆龄故居对比强烈，但是经过100多年的风雨依旧屹立不倒，他们都已经被围墙围住打算重新修葺，围墙上被各种涂鸦，画的花里胡哨的。除了列强的建筑之外还有中共八七会议的旧址，现在已经被改成了一个小型的博物馆，毛主席著名的“枪杆子里夺政权”就是出自这次会议。在这样一条有历史痕迹的长街，还有不少的咖啡馆和猫舍营业，不少的女生在大街上自拍。街两侧的居民楼里还有老人居住，有卖包子的、有开小卖店的、有做针脚活的。走在这里还真有一种恍若隔世的感觉。</p><p>我去古德寺的时候正值寺庙要搬迁，入门要交6块钱的香火钱，然后进大门烧香拜拜。亲眼见到古德寺的一刹那还真有点蒙，因为它的造型简直就是一个教堂，而且它的部分尖塔顶还有十字架！</p><p>古德寺四周是居民楼，寺里空地上有鸽子走来走去，花盆里有猫懒懒的睡觉，外形印度加波斯风的寺庙和大堂里的佛像搭配在一起，整个的气氛非常的祥和，不亏大隐隐于市这句话。可惜的是，10月初的时候，水池里的荷花已经败掉了。这个寺庙据说现在已经是一个尼姑庵。这座150年的历史的古刹，见证了武汉的50000多天的日日夜夜。它真的就像佛教一样的坚韧，屹立过那么多个是是非非，依旧对各路香客迎来送往。慈悲仁爱。</p><p>我没有去黄鹤楼，因为在网络上听到很多人以及周围朋友对黄鹤楼的吐槽。于是这次选择了晴川阁，第一它免费（囧），第二它是近距离看长江大桥的好地方，且与黄鹤楼隔江相望。晴川阁院里左手边是一个城墙，可以在城墙上看着下面车来车往，那里也是不少婚纱照的拍摄圣地，一对一对的新人穿着大红的服装风，扛个一把大伞搔首弄姿。</p><p>湖北省博物馆有两个镇馆之宝，一个是战国曾侯乙编钟，每天有固定时间会有工作人员表演；还有一个就是越王勾践的宝剑。这两个展厅的人是最多的，文物在展厅里静静的站立着，被一波又一波的游客检阅和拍照。武汉那两天气候太热，很多人都跑到博物馆去避暑，或盘腿坐或干脆躺着。湖北美术馆就在博物馆旁边，可以一波参观。</p><h2><span id="武汉的吃">武汉的吃</span></h2><p>吉庆街的江小城是让我特别有印象的店，它的室内装修风格是武汉街头，对的，进了店门就好像到了老武汉的胡同，墙壁也上贴着各种小广告。</p><p>到了武汉怎能不吃鱼？毛主席写过“才饮长江水，又食武昌鱼”，正是因为这首诗，武昌鱼就成为了樊口鳊鱼的大众名。武汉除了鱼，就是热干面，豆皮、袁大头包子、排骨炖藕汤这些。除了以上这些，我还很喜欢武汉的毛豆，微微的一点辣，下酒挺好！</p><h2><span id="武汉印象">武汉印象</span></h2><p>武汉给我的第一印象是天气真热人真多，我去户部巷的那天，屏幕显示整个户部巷有近20000人！更是让人觉得烦躁难耐，我买了一杯冰镇椰子汁，给媳妇买了一个网红冒烟冰淇淋，逛了一小会就觉得闷热的受不了。而在吉庆街街头大排档总会有一波带着乐器的中年大叔到各桌边演奏献唱，唱一次是否收费我并不了解。不过乐器花样倒是众多，古今中外一应俱全，从吉他到笛子。唱的歌曲嘛，无非就是《好运来》这样的大众歌曲。</p><p>坊间传闻武汉人因为靠江吃江，所以自古码头帮会众多，到了新社会也有一些好勇分子，不过大多数武汉民众都是遵纪守法的好市民，但是武汉人，无论男女的彪悍作风，直爽态度至今还是流传下来的，符合那句“天上九头鸟，地上湖北佬”的评价。武汉是一个基建狂魔，阮成发担任市长期间，从2009~2011年，城建投资超过了1500亿，但是武汉的确有效的建了地铁、修了高架，极大的缓解了市民出行的压力。不过话说回来，武汉的涝一直没有解决，在新闻上也能看到大雨天，武汉水过腰的照片，这是一个很严重的问题。</p><p>武汉市还有很多小景点，比如南洋大楼、瞿秋白故居、毛主席故居、陈潭秋烈士纪念馆、“汉阳造”纪念碑等等。现在的武汉被打造成了一个又红又专的城市，虽然当年国民党也在这里有过很大的动静，而且还一度被汪兆铭做了他的国民政府首都，但是武汉在中共革命历史上是有非常重要的意义的。武汉人说话有股子四川味，而且说活更“冲”，风风火火。可以说武汉话其实是四川话的“母版”，毕竟“两湖填四川”嘛。</p><h2><span id="长沙的玩">长沙的玩</span></h2><p>从武汉到长沙并不算远，高铁90分钟就从湖北跑到了湖南。长沙不算是一个旅游城市，没有什么出众的景点。整个长沙最大的景点就是湖南省博物馆，而湖南省博物馆的镇馆之宝就是马王堆的辛追夫人全家的陪葬以及她本人的尸体。</p><p>除了湖南省博物馆还有岳麓山值得一去，爬上山还是比较累的，对于有运动癌的媳妇儿，我俩只能买车票上山，然后坐一个20分钟左右的缆车慢悠悠观景下来。山上的空气很棒，要进岳麓书院是要单独收费的。</p><p>至于橘子洲头就是在湘江那里的一个大公园而已，除了青年毛主席的头部雕塑没什么特别的。</p><h2><span id="长沙的吃">长沙的吃</span></h2><p>长沙旅游业虽然比较贫乏，但是论吃就是顶级城市了。长沙的臭豆腐是当地一绝，走进太平老街，一股强烈的臭味迎面扑来，我估计如果贾谊在世还住在他那老宅，都能被熏死。</p><p>长沙的辣比武汉更甚，我在长沙两天，先后吃了么子烤肉、费大厨辣椒烧肉、易小厨辣椒炒肉等饭店。么子烤肉的烤五花肉和虾滑很棒！辣椒炒肉都差不多啦，还是比较下饭的，但是真的很辣，我不小心咬破一个辣椒籽，足足喝了两瓶水才把舌尖缓过来。</p><h2><span id="长沙印象">长沙印象</span></h2><p>长沙给我的第一印象就是贫富差距很大，破的地方很破，感觉有好大片楼拆了一半就烂在那里了，破破的在街道边无精打采的耸立着，有的甚至顶层都长半个人高的草。听人说这是因为长沙食物普遍都有辣和炸这两个风格，所以很多饮食的步行街看上去油腻腻脏乎乎，再加上我去那两天长沙天气并不晴朗，所以这种脏破让外人看来更加明显。</p><p>但是长沙高大上的地方又特别高级，比如国金中心，好几层楼，各种国际的奢侈品大牌都在里面有专卖店。国金中心斜对面就是黄兴广场，里面也是有吃有玩，各种champion店在大甩卖，广场的电子屏幕上甚至还有张艺兴的粉丝祝张艺兴生日快乐的滚动视频广告…</p><p>第二印象，长沙的乞丐真的很多。去湖南省博物馆的公交车下车到博物馆大门就趴着至少5位，残疾人、老年人、孤儿、母子、求学，各种各样的。据说早几年还有小孩抱腿的，不给钱就不撒手，给的不够也不撒手…</p><p>第三印象，打麻将真是当地人民喜闻乐见的休闲活动，胡同里的棋牌室基本爆满，不少人是老婆在隔壁商铺做饭，老公在店里打麻将。长沙夏天也是酷热难耐，不少长沙人会在游泳池里摆个桌子打几圈，这也是当地一大特色了。</p><h2><span id="一些tips">一些tips</span></h2><ol><li>多带一点人民币现金，我去的时候长沙公交车恰巧不能刷支付宝的电子公交卡，所以还是人民币买单；</li><li>汉街商圈虽然明文规定是晚10点结束营业，但是其实很多店都是坚持到10点半左右，所以晚上还可以去在那里吃顿夜宵；</li><li>你如果用华为P30，是可以在晴川阁看到对面的黄鹤楼的细节的；</li></ol>]]></content>
    
    <summary type="html">
    
      国庆的温度忽高忽低，弄得人要感冒
    
    </summary>
    
      <category term="坠乱花天" scheme="http://yoursite.com/categories/%E5%9D%A0%E4%B9%B1%E8%8A%B1%E5%A4%A9/"/>
    
    
      <category term="旅游" scheme="http://yoursite.com/tags/%E6%97%85%E6%B8%B8/"/>
    
      <category term="国庆" scheme="http://yoursite.com/tags/%E5%9B%BD%E5%BA%86/"/>
    
      <category term="长沙" scheme="http://yoursite.com/tags/%E9%95%BF%E6%B2%99/"/>
    
      <category term="武汉" scheme="http://yoursite.com/tags/%E6%AD%A6%E6%B1%89/"/>
    
  </entry>
  
  <entry>
    <title>阿里云RDS的内存增高与临时表</title>
    <link href="http://yoursite.com/2019/10/11/%E9%98%BF%E9%87%8C%E4%BA%91RDS%E7%9A%84%E5%86%85%E5%AD%98%E5%A2%9E%E9%AB%98%E7%9A%84%E5%8E%9F%E5%9B%A0/"/>
    <id>http://yoursite.com/2019/10/11/阿里云RDS的内存增高的原因/</id>
    <published>2019-10-11T07:33:07.000Z</published>
    <updated>2019-10-11T13:35:04.000Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="正文">正文</span></h2><p>mysql查看当前内存使用细节的语句是：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">show variables where variable_name <span class="keyword">in</span> (</span><br><span class="line"><span class="string">'innodb_buffer_pool_size'</span>,<span class="string">'innodb_log_buffer_size'</span>,<span class="string">'innodb_additional_mem_pool_size'</span>,<span class="string">'key_buffer_size'</span>,<span class="string">'query_cache_size'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>大部分内存占用告警，都是因为<code>buffer pool</code>增长导致，而<code>buffer pool</code>的增长是正常的，如图：<br><img src="/images/mysql7.png" alt="akb48"></p><p>如果说这个值高的令人发指（超过90%），那么基本就是两种可能：</p><ol><li>当前session太多，<code>show full processlist；</code>看一下是不是有太多空闲的对话，如果有，酌情调整timeout断开；</li><li>session不多，但是session里的私有内存占用过多，那么就要检查一下对应的sql语句，是不是语句里有大量的临时表、sort(排序)和join操作；</li></ol><p>如何判断是否使用了临时表？使用<code>explain</code>查看执行的sql语句，在Extra列看到<code>Using temporary</code>就意味着使用了临时表。比如这个：<br><img src="/images/mysql8.png" alt="akb48"></p><p>一般情况下，用到临时表就意味着性能较低。查看临时表大小的语句是<code>show global variables like &#39;%table_size%&#39;;</code>。</p><p>如果说某个SQL语句，它查询的内容非常的多（select *这种的），然后又对这个查询的内容进行了二次加工（sort或者join)就会生成一个巨大的临时表，那么内存可能就会放不下，导致mysql将这个表全部放到磁盘里，那么这样mysql的IO就会出现飙升、sql执行缓慢的现象。</p><p>查看临时表是在内存还是在磁盘上，可以通过<code>show global status like &#39;%Created_tmp%&#39;;</code>：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MySQL [(none)]&gt;  show <span class="keyword">global</span> status like <span class="string">'%Created_tmp%'</span>;</span><br><span class="line">+-------------------------+-----------+</span><br><span class="line">| Variable_name           | Value     |</span><br><span class="line">+-------------------------+-----------+</span><br><span class="line">| Created_tmp_disk_tables | <span class="number">53585768</span>  |<span class="comment">#服务器在磁盘上创建表（最初或通过转换内存中的表）</span></span><br><span class="line">| Created_tmp_files       | <span class="number">807803</span>    |</span><br><span class="line">| Created_tmp_tables      | <span class="number">167011673</span> |<span class="comment">#服务器创建内部临时表（在内存或磁盘上）</span></span><br><span class="line">+-------------------------+-----------+</span><br><span class="line"><span class="number">3</span> rows <span class="keyword">in</span> set (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p><p>遇到这样的情况，建议是将原语句拆成两个sql，然后用<code>in</code>操作拼接。</p><p>最后结论，MYSQL在上线部署后，导致内存激增，请检查是否出现了临时表。临时表如果大出了指定范围，写入到磁盘里，就会导致IO上升，拖垮SQL执行速度。</p><h2><span id="补充">补充</span></h2><p>在网站开发里，排序究竟是在程序(PHP)里排还是在数据库(mysql)里排？</p><p>在 PHP 中执行排序更优的情况举例如下：</p><ol><li>数据源不在MySQL中，存在硬盘、内存或者来自网络的请求等；</li><li>数据存在MySQL中，量不大，而且没有相应的索引，此时把数据取出来用PHP排序更快；</li><li>数据源来自于多个MySQL服务器，此时从多个MySQL中取出数据，然后在PHP中排序更快；</li><li>除了MySQL之外，存在其他数据源，比如硬盘、内存或者来自网络的请求等，此时不适合把这些数据存入MySQL后再排序。</li></ol><p>必须在MySQL中排序的实例如下：</p><ol><li>MySQL中已经存在这个排序的索引；</li><li>MySQL中数据量较大，而结果集需要其中很小的一个子集，比如1000000行数据，取TOP10；</li><li>对于一次排序、多次调用的情况，比如统计聚合的情形，可以提供给不同的服务使用，那么在MySQL中排序是首选的。另外，对于数据深度挖掘，通常做法是在应用层做完排序等复杂操作，把结果存入MySQL即可，便于多次使用。</li><li>不论数据源来自哪里，当数据量大到一定的规模后，由于占用内存的关系，不再适合PHP中排序了；此时把数据复制、导入或者存在MySQL，并用INDEX优化，是优于PHP的。不过，用Java，甚至C++ 来处理这类操作会更好。</li></ol><p>结论：从网站整体考虑，就必须加入人力和成本的考虑。假如网站规模和负载较小，而人力有限（人数和能力都可能有限），此时在应用层（PHP）做排序要做不少开发和调试工作，耗费时间，得不偿失；不如在 DB 中处理，简单快速。对于大规模的网站，电力、服务器的费用很高，在系统架构上精打细算，可以节约大量的费用，是公司持续发展之必要；此时如果能在应用层 (PHP) 进行排序并满足业务需求，尽量在应用层进行。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://dp.imysql.com:8080/node/97" target="_blank" rel="noopener">https://dp.imysql.com:8080/node/97</a><br><a href="http://mysql.taobao.org/monthly/2019/04/01/" target="_blank" rel="noopener">http://mysql.taobao.org/monthly/2019/04/01/</a><br><a href="http://blog.sae.sina.com.cn/archives/4096" target="_blank" rel="noopener">http://blog.sae.sina.com.cn/archives/4096</a></p>]]></content>
    
    <summary type="html">
    
      这是一个理论学习文章，以备将来不时之需
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="阿里云" scheme="http://yoursite.com/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
      <category term="RDS" scheme="http://yoursite.com/tags/RDS/"/>
    
  </entry>
  
  <entry>
    <title>使用Docker部署Prometheus</title>
    <link href="http://yoursite.com/2019/10/08/%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2Prometheus/"/>
    <id>http://yoursite.com/2019/10/08/使用Docker部署Prometheus/</id>
    <published>2019-10-08T07:10:59.000Z</published>
    <updated>2019-10-31T10:04:30.000Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>关于prometheus的基础内容，可以去看<a href="https://www.hi-linux.com/posts/25047.html" target="_blank" rel="noopener">https://www.hi-linux.com/posts/25047.html</a> 、<a href="https://yunlzheng.gitbook.io/prometheus-book/" target="_blank" rel="noopener">https://yunlzheng.gitbook.io/prometheus-book/</a> 和<a href="https://www.ibm.com/developerworks/cn/cloud/library/cl-lo-prometheus-getting-started-and-practice/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/cloud/library/cl-lo-prometheus-getting-started-and-practice/index.html</a> 。</p><p>服务器说明：阿里云centos 7.6（内网IP：172.31.0.85） + docker 19.03.2 + git 1.8 + go 1.13</p><p>go的安装方法如下，国内可用：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm --<span class="keyword">import</span> https://mirror.go-repo.io/centos/RPM-GPG-KEY-GO-REPO</span><br><span class="line">curl -s https://mirror.go-repo.io/centos/go-repo.repo | tee /etc/yum.repos.d/go-repo.repo</span><br><span class="line">yum install -y golang</span><br></pre></td></tr></table></figure></p><h2><span id="部署prometheus-server">部署Prometheus Server</span></h2><p>首先，创建一个普通用户，比如叫<code>lcshop</code>，然后<code>gpasswd -a lcshop docker</code>，把lcshop用户添加到docker组里。</p><p>然后在<code>/mnt</code>下创建<code>promethues</code>文件夹和子文件夹<code>server</code>，树形结构如下：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[lcshop@lcshop-Prometheus mnt]$ tree</span><br><span class="line">.</span><br><span class="line">└── prometheus</span><br><span class="line">    └── server</span><br><span class="line">        ├── prometheus.yml</span><br><span class="line">        └── rules.yml</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> directories, <span class="number">2</span> files</span><br><span class="line">[lcshop@lcshop-Prometheus mnt]$</span><br></pre></td></tr></table></figure></p><p>其中<code>/mnt/promethues/server/prometheus.yml</code>的内容是这样的：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">global</span>:</span><br><span class="line">  scrape_interval:     <span class="number">60</span>s <span class="comment"># 默认抓取间隔, 60秒向目标抓取一次数据。</span></span><br><span class="line">  external_labels:</span><br><span class="line">    monitor: <span class="string">'codelab-monitor'</span></span><br><span class="line"><span class="comment"># 这里表示抓取对象的配置</span></span><br><span class="line">rule_files:</span><br><span class="line">  <span class="comment">#- 'prometheus.rules'</span></span><br><span class="line">scrape_configs:</span><br><span class="line"> <span class="comment">#这个配置是表示在这个配置内的时间序例，每一条都会自动添加上这个&#123;job_name:"prometheus"&#125;的标签  </span></span><br><span class="line">  - job_name: <span class="string">'prometheus'</span></span><br><span class="line">    scrape_interval: <span class="number">30</span>s <span class="comment">#重写了全局抓取间隔时间，由15秒重写成30秒</span></span><br><span class="line">    static_configs:</span><br><span class="line">      - targets: [<span class="string">'localhost:9090'</span>]</span><br><span class="line">        labels:</span><br><span class="line">          group: <span class="string">'prometheus'</span></span><br></pre></td></tr></table></figure></p><p>至于<code>rules.yml</code>暂时先为空，再把整个<code>/mnt/promethues</code>文件夹及内部所有文件所属组改成<code>lcshop：docker</code>，启动docker进程：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name=prometheus -d -p <span class="number">9090</span>:<span class="number">9090</span> -v /mnt/prometheus/server/prometheus.yml:/etc/prometheus/prometheus.yml -v /mnt/prometheus/server/rules.yml:/etc/prometheus/rules.yml -v /etc/localtime:/etc/localtime:ro prom/prometheus:v2<span class="number">.7</span><span class="number">.2</span> --config.file=/etc/prometheus/prometheus.yml --web.enable-lifecycle</span><br></pre></td></tr></table></figure></p><p>阿里云安全组放行9090端口，在浏览器使用<code>外网IP:9090</code>就会看到Prometheus的界面：<br><img src="/images/prometheus.png" alt="akb48"></p><p>如果输入一些监控值，就会出现对应值的结果：<br><img src="/images/prometheus2.png" alt="akb48"></p><h2><span id="部署prometheus-metrics接口">部署Prometheus metrics接口</span></h2><p>目前我们的server和grafana已经通了，但是仅仅是有一些无实际作用的指标，我们需要收集服务器的指标，收集指标的东西叫<code>node-exporter</code>。这是一个有点类似于zabbix-agent的东西，会帮你收集系统指标和一些软件运行的指标，把指标暴露出去。Prometheus官方是不推荐用Docker来运行 <code>node_exporter</code>的，因为Docker的文件系统和网络都有自己的namespace，收集的数据并不是宿主机真实的指标。所以我们这里还是用常规的方法，安装方法如下：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/ &amp;&amp; mkdir node_exporter</span><br><span class="line">   cd /usr/local/node_exporter</span><br><span class="line">wget https://github.com/prometheus/node_exporter/releases/download/v0<span class="number">.18</span><span class="number">.1</span>/node_exporter<span class="number">-0.18</span><span class="number">.1</span>.linux-amd64.tar.gz</span><br><span class="line">tar -zxvf node_exporter<span class="number">-0.18</span><span class="number">.1</span>.linux-amd64.tar.gz</span><br><span class="line">cd node_exporter<span class="number">-0.18</span><span class="number">.1</span>.linux-amd64</span><br><span class="line">./node_exporter</span><br></pre></td></tr></table></figure></p><p>这个启动是前台启动，监听9100端口。我们要改一下，改成systemctl启动，这样后台启动更好。创建<code>/usr/lib/systemd/system/node_exporter.service</code>如下：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=node_exporter</span><br><span class="line">[Service]</span><br><span class="line">Restart=on-failure</span><br><span class="line">ExecStart=/usr/local/node_exporter/node_exporter<span class="number">-0.18</span><span class="number">.1</span>.linux-amd64/node_exporter<span class="comment">#这里填写的node_exporter 文件的全路径，不然无法启动</span></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure></p><p>保存退出，<code>systemctl daemon-reload</code>之后再<code>systemctl start node_exporter.service</code>就启动了，然后可以<code>curl http://localhost:9100/metrics</code>查看一下是否正常获取服务器指标，如图：<br><img src="/images/prometheus19.png" alt="akb48"></p><p>确认可以正常获取到指标之后，就重新编写一下<code>prometheus.yml</code>:<br>    <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">global:</span><br><span class="line">  scrape_interval:     <span class="number">60s</span> # 默认抓取间隔, <span class="number">60</span>秒向目标抓取一次数据。</span><br><span class="line">  external_labels:</span><br><span class="line">    monitor: <span class="string">'codelab-monitor'</span></span><br><span class="line"># 这里表示抓取对象的配置</span><br><span class="line">rule_files:</span><br><span class="line">  #- <span class="string">'prometheus.rules'</span></span><br><span class="line">scrape_configs:</span><br><span class="line"> #这个配置是表示在这个配置内的时间序例，每一条都会自动添加上这个&#123;job_name:<span class="string">"prometheus"</span>&#125;的标签  </span><br><span class="line">  - job_name: <span class="string">'prometheus'</span></span><br><span class="line">    scrape_interval: <span class="number">30s</span> #重写了全局抓取间隔时间，由<span class="number">15</span>秒重写成<span class="number">30</span>秒</span><br><span class="line">    static_configs:</span><br><span class="line">      - targets: [<span class="string">'localhost:9090'</span>]</span><br><span class="line">        labels:</span><br><span class="line">          group: <span class="string">'prometheus'</span></span><br><span class="line"></span><br><span class="line">  - job_name: <span class="string">'server'</span></span><br><span class="line">    scrape_interval: <span class="number">30s</span></span><br><span class="line">    static_configs:</span><br><span class="line">      - targets: [<span class="string">'172.31.0.85:9100'</span>]#本机IP</span><br><span class="line">        labels:</span><br><span class="line">          group: <span class="string">'server'</span></span><br></pre></td></tr></table></figure></p><p>然后重启prometheus容器，重新载入配置文件。然后在web端的<code>Status -&gt; Targets</code>可以看到添加的<code>node-exporter</code>：<br><img src="/images/prometheus6.png" alt="akb48"></p><p>保存之后，就可以在graph页面里查看一些指标。</p><p>Prometheus针对mysql、nginx、jmx都有官方的指标收集策略，感兴趣可以去看<a href="https://www.aneasystone.com/archives/2018/11/prometheus-in-action.html" target="_blank" rel="noopener">https://www.aneasystone.com/archives/2018/11/prometheus-in-action.html</a> 。</p><h2><span id="接入grafana">接入Grafana</span></h2><p>Docker部署Grafana的语句可见<a href="https://rorschachchan.github.io/2019/08/22/%E6%90%AD%E9%85%8DInfluxDB-CADvisor-Grafana%E7%BB%84%E5%90%88%E7%9B%91%E6%8E%A7Docker/" target="_blank" rel="noopener">https://rorschachchan.github.io/2019/08/22/%E6%90%AD%E9%85%8DInfluxDB-CADvisor-Grafana%E7%BB%84%E5%90%88%E7%9B%91%E6%8E%A7Docker/</a> ，启动之后登录到grafana界面，在<code>Data Source</code>里选择<code>Prometheus</code>，然后就填写对应的url即可：<br><img src="/images/prometheus4.png" alt="akb48"></p><p>点击旁边的Dashboards，就会有三张模板，根据需要import。如果import了<code>prometheus 2.0 stats</code>，那么生成的格式就是这样的：<br><img src="/images/prometheus5.png" alt="akb48"></p><p>页面看上去还是挺有科技感的，保留这个骨架改一下里面具体的监控项就好了。</p><p>Prometheus的监控项跟zabbix的item不一样，它的监控项叫Element，格式是类似这样的：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node_load15&#123;group=<span class="string">"server"</span>,instance=<span class="string">"172.31.0.85:9100"</span>,job=<span class="string">"server"</span>&#125;</span><br></pre></td></tr></table></figure></p><p>这个的意思就是<code>172.31.0.85</code>这个服务器的cpu 15分钟的负载。<code>group、job、instance</code>这些都是这个Element的标签。那么如何找到Element呢？在prometheus的web界面的graph里的console就能看到，如图：<br><img src="/images/prometheus7.png" alt="akb48" title="这个就叫PromQL的表达式"></p><p>然后在grafana页面在对应的表格里添加该element即可：<br><img src="/images/prometheus8.png" alt="akb48"></p><h2><span id="故障排错">故障排错</span></h2><p>在<code>go build</code>的时候，可能会出现大陆特色错误：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go: golang.org/x/sys@v0.0.0-20190927073244-c990c680b611: unrecognized import path "golang.org/x/sys" (https fetch: Get https://golang.org/x/sys?go-get=1: dial tcp 216.239.37.1:443: i/o timeout)</span><br></pre></td></tr></table></figure></p><p>此时需要<code>export GOPROXY=https://goproxy.io</code>就OK，如图：<br><img src="/images/prometheus3.png" alt="akb48"></p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://shockerli.net/post/go-get-golang-org-x-solution/" target="_blank" rel="noopener">https://shockerli.net/post/go-get-golang-org-x-solution/</a><br><a href="https://www.aneasystone.com/archives/2018/11/prometheus-in-action.html" target="_blank" rel="noopener">https://www.aneasystone.com/archives/2018/11/prometheus-in-action.html</a><br><a href="https://blog.xizhibei.me/2017/08/06/monitoring-with-prometheus/" target="_blank" rel="noopener">https://blog.xizhibei.me/2017/08/06/monitoring-with-prometheus/</a><br><a href="https://yunlzheng.gitbook.io/prometheus-book/" target="_blank" rel="noopener">https://yunlzheng.gitbook.io/prometheus-book/</a></p>]]></content>
    
    <summary type="html">
    
      气温一下子就冷下来了...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="监控" scheme="http://yoursite.com/tags/%E7%9B%91%E6%8E%A7/"/>
    
      <category term="Prometheus" scheme="http://yoursite.com/tags/Prometheus/"/>
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat8配置apr</title>
    <link href="http://yoursite.com/2019/09/30/Tomcat8%E9%85%8D%E7%BD%AEapr/"/>
    <id>http://yoursite.com/2019/09/30/Tomcat8配置apr/</id>
    <published>2019-09-30T02:06:35.000Z</published>
    <updated>2019-09-30T04:05:10.000Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="基础知识开场">基础知识开场</span></h2><p>先以一个面试题作为本文的开场白：tomcat与nginx都是<code>Seb Server</code>，他们有什么区别？<br>首先先说明一下Tomcat更应该被叫做<code>Web Container</code>，当然它可以被认为是HTTP服务器，它的主要内容是处理<code>动态请求</code>，而nginx主要是用来处理<code>静态请求</code>。所以一般的设计都是把Nginx放在前端处理静态资源，如果有对应的Java编写的服务器端程序请求，则通过AJP转给后面的Tomcat、Jetty进行处理。</p><h2><span id="tomcat的部署">tomcat的部署</span></h2><p>首先先确认服务器是否有java，没有的话就<code>yum install java-1.8.0-openjdk* -y</code>，然后在/etc/profile最下面添加：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/lib/jvm/java<span class="number">-1.8</span><span class="number">.0</span>-openjdk<span class="number">-1.8</span><span class="number">.0</span><span class="number">.222</span>.b10<span class="number">-1.</span>el7_7.x86_64</span><br><span class="line">export JRE_HOME=$JAVA_HOME/jre</span><br><span class="line">export CLASSPATH=$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATH</span><br><span class="line">export PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH</span><br></pre></td></tr></table></figure></p><p>然后<code>source /etc/profile</code>配置环境变量，然后开始安装。<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/local/tomcat<span class="comment">#创建文件夹</span></span><br><span class="line">wget http://apache.fayea.com/tomcat/tomcat<span class="number">-8</span>/v8<span class="number">.5</span><span class="number">.46</span>/bin/apache-tomcat<span class="number">-8.5</span><span class="number">.46</span>.tar.gz -P /usr/local/tomcat<span class="comment">#直接下载tomcat8到目标文件夹</span></span><br><span class="line">cd /usr/local/tomcat</span><br><span class="line">tar -zxvf apache-tomcat<span class="number">-8.5</span><span class="number">.46</span>.tar.gz</span><br><span class="line">   cd apache-tomcat<span class="number">-8.5</span><span class="number">.46</span>/bin</span><br><span class="line">./catalina.sh start  <span class="comment">#.启动tomcat。使用./catalina.sh stop停止tomcat。</span></span><br></pre></td></tr></table></figure></p><p>为了安全我们都会更改一下默认的8080端口，那么就修改<code>apache-tomcat-8.5.46/conf/server.xml</code>：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector port=<span class="string">"33664"</span> protocol=<span class="string">"HTTP/1.1"</span></span><br><span class="line">           connectionTimeout=<span class="string">"20000"</span></span><br><span class="line">           redirectPort=<span class="string">"8443"</span> </span><br><span class="line">           server=<span class="string">"kan ni daye a kan"</span>/&gt;<span class="comment"># 服务器信息，可以通过curl -I来查看</span></span><br></pre></td></tr></table></figure></p><p>确保iptables和安全组放行33664端口之后，既可以在页面查看情况。<br><img src="/images/tomcat1.png" alt="akb48"></p><p>虽然现在程序已经正常启动了，但是还需要配置开机自启动和service控制开启关闭等其他工作。</p><p>首先要使用service命令控制tomcat启停，新编辑<code>/etc/init.d/tomcat</code>文件：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="comment"># description: Tomcat8 Start Stop Restart</span></span><br><span class="line"><span class="comment"># processname: tomcat8</span></span><br><span class="line"><span class="comment"># chkconfig: 234 20 80</span></span><br><span class="line"></span><br><span class="line">CATALINA_HOME=/usr/local/tomcat/apache-tomcat<span class="number">-8.5</span><span class="number">.46</span></span><br><span class="line"></span><br><span class="line">case $<span class="number">1</span> <span class="keyword">in</span></span><br><span class="line">        start)</span><br><span class="line">                sh $CATALINA_HOME/bin/startup.sh</span><br><span class="line">                ;;</span><br><span class="line">        stop)</span><br><span class="line">                sh $CATALINA_HOME/bin/shutdown.sh</span><br><span class="line">                ;;</span><br><span class="line">        restart)</span><br><span class="line">                sh $CATALINA_HOME/bin/shutdown.sh</span><br><span class="line">                sh $CATALINA_HOME/bin/startup.sh</span><br><span class="line">                ;;</span><br><span class="line">        *)</span><br><span class="line">                echo <span class="string">'please use : tomcat &#123;start | stop | restart&#125;'</span></span><br><span class="line">        ;;</span><br><span class="line">esac</span><br><span class="line">exit <span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>保存之后给予这个tomcat文件可执行权限，就可以通过<code>service tomcat restart/stop/start</code>来控制程序启停了。</p><p>开启自启动比较简单了：<code>chkconfig --add tomcat &amp;&amp; chkconfig tomcat on</code>。</p><p>基本上准备工作就到此为止了。</p><h2><span id="配置apr">配置apr</span></h2><p>Tomcat支持三种接收请求的处理方式：<code>BIO（阻塞式）</code>、<code>NIO（非阻塞式）</code>、<code>APR（基于本地库）</code>。采用APR是比较符合更高要求的场景，连接建立的速度会有50%～100%的提升。直接调用操作系统层果然神速啊，所以强烈推荐使用apr方式！而tomcat8默认情况下使用的是nio模式：<br><img src="/images/tomcat2.png" alt="akb48"></p><p>apr模式本质是使用JNI技术调用操作系统IO接口，需要用到相关API的头文件，先<code>yum install apr-devel openssl-devel gcc make -y</code>安装相关依赖库。</p><p>然后在tomcat的bin文件夹下，会看到一个<code>tomcat-native.tar.gz</code>，解压之。然后在<code>tomcat-native-1.2.23-src/native</code>下执行<code>./configure &amp;&amp; make &amp;&amp; make install</code>安装。</p><p>安装完毕之后，返回到Tomcat的bin里编辑<code>catalina.sh</code>，在虚拟机启动参数<code>JAVA_OPTS</code>中添加<code>java.library.path</code>参数，指定apr库的路径：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVA_OPTS=<span class="string">"$JAVA_OPTS -Djava.library.path=/usr/local/apr/lib"</span></span><br></pre></td></tr></table></figure></p><p>再去tomcat的conf里<code>server.xml</code>修改一下：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector port=<span class="string">"33664"</span> protocol=<span class="string">"org.apache.coyote.http11.Http11AprProtocol"</span></span><br><span class="line">           connectionTimeout=<span class="string">"20000"</span></span><br><span class="line">           redirectPort=<span class="string">"8443"</span></span><br><span class="line">  maxThreads=<span class="string">"800"</span> acceptCount=<span class="string">"1000"</span><span class="comment">#这两个数在下面细说</span></span><br><span class="line">           server=<span class="string">"kan ni daye a kan"</span>/&gt;</span><br></pre></td></tr></table></figure></p><p>重启一下tomcat，就会看到现在使用的是apr模式了：<br><img src="/images/tomcat3.png" alt="akb48"></p><h2><span id="多tomcat负载均衡">多tomcat负载均衡</span></h2><p>复制tomcat成多份，然后修改<code>tomcat路径下/webapps/ROOT/index.jsp</code>的内容作为标识，然后分别启动不同的端口，如：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 1 默认8005改成8008 --&gt;</span><br><span class="line">&lt;Server port=<span class="string">"8008"</span> shutdown=<span class="string">"SHUTDOWN"</span>&gt;</span><br><span class="line">    &lt;!-- 2 Http默认8080 改成自己喜欢的端口 --&gt;</span><br><span class="line">    &lt;Connector port=<span class="string">"第三个端口"</span> protocol=<span class="string">"HTTP/1.1"</span></span><br><span class="line">               connectionTimeout=<span class="string">"20000"</span></span><br><span class="line">               redirectPort=<span class="string">"8443"</span> /&gt;</span><br><span class="line">     &lt;!-- 3 AJP默认8009 改成8011 --&gt;         </span><br><span class="line">    &lt;Connector port=<span class="string">"8011"</span> protocol=<span class="string">"AJP/1.3"</span> redirectPort=<span class="string">"8443"</span> /&gt;</span><br></pre></td></tr></table></figure></p><p>启动之后，一个服务器里就运行了多个tomcat。然后修改<code>nginx.conf</code>：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    <span class="comment"># 省略代码....</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment"># 增加  upstream, 名称为 serverlist</span></span><br><span class="line">    upstream serverlist&#123;</span><br><span class="line">        server localhost:第一个端口 weight=<span class="number">1</span>;  <span class="comment"># weigh表示权重，越大访问的机率越多</span></span><br><span class="line">        server localhost:第二个端口 weight=<span class="number">1</span>;</span><br><span class="line">        server localhost:第三个端口 weight=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 编辑</span></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       <span class="number">80</span>;</span><br><span class="line">        server_name  www.yourdomian.com;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            <span class="comment"># 这里使用定义 serverlist</span></span><br><span class="line">            proxy_pass http://serverlist;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p>重新nginx就能通过你的域名进行访问了，多次刷新就可以看到网站显示是哪个tomcat的内容。</p><p><font color="red">注意！</font>强烈建议不要使用 Tomcat 的虚拟主机，推荐每个站点使用一个实例。即，可以启动多个 Tomcat，而不是启动一个 Tomcat 里面包含多个虚拟主机。因为 Tomcat是多线程，共享内存，任何一个虚拟主机中的应用崩溃，都会影响到所有应用程序。虽然采用多实例的方式会产生过多的开销，但至少保障了应用程序的隔离和安全。</p><h2><span id="运维注意点">运维注意点</span></h2><ol><li><p>不要使用root用户启动tomcat，Java程序与C程序不同。你使用什么用户启动Tomcat，那么Tomcat就会继承该所有者的权限。那么解决这个问题的办法：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">groupadd -g <span class="number">80</span> daemon</span><br><span class="line">adduser -o --home /daemon --shell /sbin/nologin --uid <span class="number">80</span> --gid <span class="number">80</span> -c <span class="string">"Web Server"</span> daemon<span class="comment">#注意/sbin/nologin,意味着该用户不能登录，同时我也没有给它指定密码，这个用户只能用于启动tomcat</span></span><br></pre></td></tr></table></figure></li><li><p>修改tomcat的conf里<code>server.xml</code>：关闭war自动部署<code>unpackWARs=&quot;false&quot; autoDeploy=&quot;false&quot;</code>，防止被植入木马等恶意程序；</p></li><li><code>maxThreads</code>：tomcat起动的最大线程数，即同时处理的任务个数，默认值为200；<code>acceptCount</code>：当tomcat起动的线程数达到最大时，接受排队的请求个数，默认值为100。这俩个值要根据业务合理分配，不是越大越好。一般来说<code>acceptCount</code>的配置是设置的跟<code>maxThreads</code>一样大；</li><li><code>server.xml</code>中定义了可以直接关闭Tomcat实例的管理端口。我们通过telnet连接上该端口之后，输入SHUTDOWN（此为默认关闭指令）即可关闭Tomcat实例（注意，此时虽然实例关闭了，但是进程还是存在的）。所以为了避免这样的情景，就把SHUTDOWN改成乱码： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Server port=<span class="string">"8005"</span> shutdown=<span class="string">"9SDKJ29jksjf23sjf0LSDF92JKS9DKkjsd"</span>&gt;</span><br></pre></td></tr></table></figure></li></ol><h2><span id="参考资料">参考资料</span></h2><p><a href="https://lanjingling.github.io/2015/12/15/tomcat-redis-session/" target="_blank" rel="noopener">https://lanjingling.github.io/2015/12/15/tomcat-redis-session/</a><br><a href="https://qq343509740.gitee.io/2018/07/24/Linux/CentOS/CentOS%207%20&amp;%20Tomcat%208%20%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/#%E6%B7%BB%E5%8A%A0%E9%85%8D%E7%BD%AE" target="_blank" rel="noopener">https://qq343509740.gitee.io/2018/07/24/Linux/CentOS/CentOS%207%20&amp;%20Tomcat%208%20%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/#%E6%B7%BB%E5%8A%A0%E9%85%8D%E7%BD%AE</a><br><a href="https://www.cnblogs.com/meetrice/p/5695127.html" target="_blank" rel="noopener">https://www.cnblogs.com/meetrice/p/5695127.html</a></p>]]></content>
    
    <summary type="html">
    
      实现session共享的集群要点：首先搭建好单机版的tomcat将session持久化到redis中，然后配置nginx轮询tomcat（负载均衡）
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="tomcat" scheme="http://yoursite.com/tags/tomcat/"/>
    
  </entry>
  
  <entry>
    <title>使用GTID主从同步阿里云RDS到自建Mysql</title>
    <link href="http://yoursite.com/2019/09/26/%E4%BD%BF%E7%94%A8GTID%E5%A4%87%E4%BB%BD%E9%98%BF%E9%87%8C%E4%BA%91RDS%E5%88%B0%E8%87%AA%E5%BB%BAMYSQL/"/>
    <id>http://yoursite.com/2019/09/26/使用GTID备份阿里云RDS到自建MYSQL/</id>
    <published>2019-09-26T03:42:09.000Z</published>
    <updated>2019-09-29T09:34:08.000Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="基础概念">基础概念</span></h2><p>传统的MYSQL主从就是主库每做一个操作会在binlog上做一个position，每做一个event就在binlog做一个起始编号、一个终止编号。然后主库把binlog传递给从库，然后从库根据这个binlog的pos值就按照顺序做一样的操作，达到两个数据库保持一致的目的。</p><p>GTID不用这个position的方式，而是用了<code>全局事物标识</code>，这个标识的格式是<code>source_id:transaction_id</code>，如3E11FA47-71CA-11E1-9E33-C80AA9429562:23：</p><ol><li><code>source_id</code>即是<code>server_uuid</code>，在第一次启动时生成(函数 generate_server_uuid)，并持久化到<code>DATADIR/auto.cnf</code>文件里；</li><li><code>transaction_id</code>是顺序化的序列号(sequence number)，在每台 MySQL 服务器上都是从 1 开始<code>自增长</code>的序列，是事务的唯一标识；</li></ol><p>它的主从过程是这样的：主库更新数据时，会在事务前产生GTID，连通sql记录到<code>binlog</code>日志中。从库的<code>i/o</code>线程将变更的<code>binlog</code>写入到<code>relay log</code>中,读取值是根据<code>gitd_next变量</code>，告诉从库下一个执行哪个GTID。从库的sql线程从<code>relay log</code>中获取GTID，然后对比从库的的<code>binlog</code>是否有记录。如果有记录，说明该GTID的事务已经执行，从库会忽略。如果没有记录，从库就会从<code>relay log</code>中执行该GTID的事务，并记录到从库<code>binlog</code>。在解析过程中会判断是否有主键，如果没有就用二级索引，如果没有二级索引就用全部扫描。</p><p>也就是说，无论是级联情况，还是一主多从情况，都可以通过GTID自动找点儿，而无需像之前那样通过<code>binlog</code>和<code>binlog_position</code>找点儿了。更多GTID 原理的知识可以去查看：<a href="https://keithlan.github.io/2016/06/23/gtid/" target="_blank" rel="noopener">https://keithlan.github.io/2016/06/23/gtid/</a> 。</p><p><font color="red">注意！</font>由于RDS for MySQL 5.6版本引入了GTID特性，因此要求应用不能够在事务中创建和删除临时表。那么如何对待临时表？</p><ol><li>将SQL语句里的<code>temporary table</code>语句更改为<code>table</code>，使用普通表替代临时表，规避这个问题；</li><li>修改代码，将临时表的创建和删除操作放在事务外，并且保证会话的参数<code>autocommit=1</code>；</li></ol><p>源RDS地址（内网）：rm-bp12k8yne0909uv68.mysql.rds.aliyuncs.com<br>目标ECS地址（内网）：172.31.0.67</p><h2><span id="工具准备">工具准备</span></h2><p>首先是现在ECS里安装<code>mysql 5.6</code>。由于centos 7默认安装的数据库是mariabd，所以使用tar.gz包安装。<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget -c <span class="string">"http://dev.mysql.com/get/Downloads/MySQL-5.6/mysql-5.6.33-linux-glibc2.5-x86_64.tar.gz"</span></span><br><span class="line">tar zxvf mysql<span class="number">-5.6</span><span class="number">.33</span>-linux-glibc2<span class="number">.5</span>-x86_64.tar.gz -C /usr/local/</span><br><span class="line">cd /usr/local &amp;&amp; ln -s mysql<span class="number">-5.6</span><span class="number">.33</span>-linux-glibc2<span class="number">.5</span>-x86_64 mysql</span><br><span class="line">mkdir -p /home/mysql/data</span><br><span class="line">chown -R mysql.mysql /home/mysql &amp;&amp; chmod -R o=--- /home/mysql<span class="comment"># chmod -o是其他以外的人</span></span><br></pre></td></tr></table></figure></p><p>使用<code>service mysqld start</code>启动，再用<code>mysql -u root -p</code>登录进去，修改掉root的空密码：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update mysql.user set password=password(<span class="string">'123123123'</span>) where user=<span class="string">'root'</span>;</span><br><span class="line">Query OK, <span class="number">4</span> rows affected (<span class="number">0.00</span> sec)</span><br><span class="line">Rows matched: <span class="number">4</span>  Changed: <span class="number">4</span>  Warnings: <span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>要进行GTID，首先要确认阿里云RDS作为主库是否支持GTID，如图：<br><img src="/images/gtid1.png" alt="akb48"></p><p>可见阿里云那一段是没问题的。</p><p>然后安装xtrabackup，由于我们是<code>mysql 5.6</code>，所以xtrabackup的版本是2.3：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.percona.com/downloads/XtraBackup/Percona-XtraBackup<span class="number">-2.3</span><span class="number">.5</span>/binary/redhat/<span class="number">7</span>/x86_64/percona-xtrabackup<span class="number">-2.3</span><span class="number">.5</span><span class="number">-1.</span>el7.x86_64.rpm</span><br><span class="line">yum localinstall percona-xtrabackup<span class="number">-2.3</span><span class="number">.2</span><span class="number">-1.</span>el7.x86_64.rpm</span><br></pre></td></tr></table></figure></p><p>最后，检查RDS白名单，确保ECS与RDS可通。</p><h2><span id="具体操作">具体操作</span></h2><p>登录阿里云的RDS控制台，选择对应的RDS之后，点击左侧栏的<code>备份恢复</code>，将最近的一次备份下载下来：<br><img src="/images/gtid2.png" alt="akb48"></p><p>由于是内网，直接就<code>复制内网地址</code>，在ECS上执行如下操作：<br>    <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget -c <span class="string">'&lt;数据备份文件外网下载地址&gt;'</span> -O /home/mysql/shopoms.tar.gz#注意引号一定要带！</span><br><span class="line">tar -izxvf shopoms.tar.gz -C /home/mysql/shopoms#解压缩</span><br></pre></td></tr></table></figure></p><p>解压缩完毕之后，打开/opt/shopoms看一下文件组成：<br><img src="/images/gtid3.png" alt="akb48"></p><p>用xtrabackup工具恢复解压好的备份文件，于是<code>innobackupex --defaults-file=/home/mysql/data/backup-my.cnf --apply-log /home/mysql/data</code>。稍等一会，解压缩成功，备份一下<code>backup-my.cnf</code>，改名叫<code>slave-oms.cnf</code>：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"><span class="comment"># from rds backup-my.cnf</span></span><br><span class="line">innodb_checksum_algorithm=innodb</span><br><span class="line">innodb_data_file_path=ibdata1:<span class="number">200</span>M:autoextend</span><br><span class="line">innodb_log_files_in_group=<span class="number">2</span></span><br><span class="line">innodb_log_file_size=<span class="number">524288000</span></span><br><span class="line">innodb_undo_directory=.</span><br><span class="line">innodb_undo_tablespaces=<span class="number">0</span></span><br><span class="line"><span class="comment"># need for slave </span></span><br><span class="line">server-id = <span class="number">666</span> <span class="comment"># 从实例的id,不能与master的id相同</span></span><br><span class="line">port=<span class="number">3306</span></span><br><span class="line">master-info-repository = file</span><br><span class="line">relay-log-info_repository = file</span><br><span class="line">binlog-format = ROW<span class="comment"># 这里必须是ROW</span></span><br><span class="line">skip-grant-tables   <span class="comment">##忽略mysql权限问题，免密码直接登录</span></span><br><span class="line"><span class="comment"># GTID</span></span><br><span class="line">gtid-mode = ON<span class="comment"># 打开了gtid模式</span></span><br><span class="line">enforce-gtid-consistency = true</span><br><span class="line">log-bin = hostname-bin</span><br><span class="line">relay-log = /tmp/relay.log<span class="comment">#注意这个文件要被mysql用户读取到，如果这里不设定对，就会有Slave failed to initialize relay log info structure from the repository的错误</span></span><br><span class="line">expire_logs_days=<span class="number">10</span> <span class="comment"># 控制binlog日志文件保留时间</span></span><br><span class="line">max_binlog_size=<span class="number">100</span>M             </span><br><span class="line">replicate-ignore-db=mysql   <span class="comment"># 不需要同步的库  </span></span><br><span class="line">log-slave-updates=<span class="number">1</span></span><br><span class="line"><span class="comment"># Recommended in standard MySQL setup</span></span><br><span class="line">sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES </span><br><span class="line">[mysqld_safe]</span><br><span class="line">log-error=/var/log/mysqld.log</span><br><span class="line">pid-file=/var/run/mysqld/mysqld.pid</span><br><span class="line">socket = /tmp/mysql.sock</span><br></pre></td></tr></table></figure></p><p>同时<code>chown -R mysql:mysql /home/mysql/data</code>修改文件属主，并确定文件所属为MySQL用户。然后执行<code>/usr/local/mysql/bin/mysqld_safe --defaults-file=/home/mysql/data/slave-oms.cnf --user=mysql --basedir=/usr/local/mysql --datadir=/home/mysql/data &amp;</code>启动mysql。如图：<br><img src="/images/gtid7.png" alt="akb48"></p><p>然后使用root账号登陆该mysql：<br><img src="/images/gtid4.png" alt="akb48"></p><p>添加主库信息：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; change master to</span><br><span class="line">    -&gt; master_host='rm-bp12k8yne0909uv68.mysql.rds.aliyuncs.com',</span><br><span class="line">    -&gt; master_user='oms',master_port=3306,master_password='对应密码',</span><br><span class="line">    -&gt; master_auto_position=1;</span><br><span class="line">ERROR <span class="number">1794</span> (HY000): Slave <span class="keyword">is</span> <span class="keyword">not</span> configured <span class="keyword">or</span> failed to initialize properly. You must at least set --server-id to enable either a master <span class="keyword">or</span> a slave. Additional error messages can be found <span class="keyword">in</span> the MySQL error log.</span><br></pre></td></tr></table></figure></p><p>原因是由于RDS的备份文件中包含了RDS的主从复制关系，需要把这些主从复制关系清理掉，清理方法：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; truncate table mysql.slave_relay_log_info;</span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0.14</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; truncate table mysql.slave_master_info;</span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0.03</span> sec)</span><br></pre></td></tr></table></figure></p><p>重启mysql，注意！恢复完成的<code>mysql.user</code>是不包含rds中创建的用户的，需要重新创建：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; delete <span class="keyword">from</span> mysql.db where user&lt;&gt;<span class="string">'root'</span> <span class="keyword">and</span> char_length(user)&gt;<span class="number">0</span>;</span><br><span class="line">Query OK, <span class="number">10</span> rows affected (<span class="number">0.02</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; delete <span class="keyword">from</span> mysql.tables_priv where user&lt;&gt;<span class="string">'root'</span> <span class="keyword">and</span> char_length(user)&gt;<span class="number">0</span>;</span><br><span class="line">Query OK, <span class="number">42</span> rows affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; flush privileges;</span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; change master to</span><br><span class="line">    -&gt; master_host='rm-bp12k8yne0909uv68.mysql.rds.aliyuncs.com',</span><br><span class="line">    -&gt; master_user='oms',master_port=3306,master_password='对应密码',</span><br><span class="line">    -&gt; master_auto_position=1;</span><br><span class="line">ERROR <span class="number">1201</span> (HY000): Could <span class="keyword">not</span> initialize master info structure; more error messages can be found <span class="keyword">in</span> the MySQL error log</span><br></pre></td></tr></table></figure></p><p>这里是因为在<code>/home/mysql/data</code>下有一个<code>master.info</code>，需要先删掉他，然后重新执行<code>change master to ...</code>就可以了，这期间不用停止mysql进程。</p><p>然后就是启动同步：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; reset master;</span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0.03</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; reset slave;</span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; start slave;</span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0.04</span> sec)</span><br></pre></td></tr></table></figure></p><p>使用<code>show slave status\G</code>查看一下主从状态：<br><img src="/images/gtid11.png" alt="akb48"></p><h2><span id="出现1236错误">出现1236错误</span></h2><p>但是此时大概率应该出现了<code>Last_IO_Error: Got fatal error 1236 from master when reading data from binary log: &#39;The slave is connecting using CHANGE MASTER TO MASTER_AUTO_POSITION = 1, but the master has purged binary logs containing GTIDs that the slave requires.&#39;</code>这个错误，如图：<br><img src="/images/gtid9.png" alt="akb48"></p><p>这里要先说两个概念：</p><ol><li>gtid_executed(global)：MySQL数据库已经执行过的Gtid事务，处于内存中。<code>show master status/show slave status</code>中的<code>Executed_Gtid_Set</code>也取自这里；</li><li>gtid_purged(global)：由于binlog文件的删除(如<code>purge binary logs</code>或者超过<code>expire_logs_days</code>设置)已经丢失的Gtid事务，它是<code>gtid_executed</code>的子集；</li></ol><p>明白了上面两个概念，我们再来回溯一下这个过程：</p><ol><li>我们用RDS做的备份集来恢复出一个自建ECS的mysql实例；</li><li>启动主从同步；</li><li>从库在开始同步前,主库会依靠GTID来确认从库在开始同步以后, 能够把每一个主库上执行过的事务(包括slave的SQL Thread)都复现一次,最终保持和主库完全一致;</li><li>但是从库指定的<code>GTID_PURGED</code>并不等于主库的<code>GTID_EXECUTED</code>，为什么呢?因为主库多出来的这些gtid已经purge（丢失）掉了或者是新的从库未指定过<code>GTID_PURGED</code>；</li><li>出现1236的故障报错；</li></ol><p>此时我们分别进入到主从mysql里，执行<code>show global variables like &#39;%gtid%&#39;\G</code>，查询一下<code>gtid_purged</code>，如图：<br><img src="/images/gtid10.png" alt="akb48" title="左边主库rds，右边自建ecs"></p><p>我们先在主库上<code>show global variables like &#39;GTID_EXECUTED&#39;;</code>看一下效果：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show <span class="keyword">global</span> variables like <span class="string">'GTID_EXECUTED'</span>;</span><br><span class="line">+---------------+------------------------------------------------------------------------------------------------+</span><br><span class="line">| Variable_name | Value                                                                                          |</span><br><span class="line">+---------------+------------------------------------------------------------------------------------------------+</span><br><span class="line">| gtid_executed | <span class="number">18e99</span>fbf<span class="number">-5</span>f38<span class="number">-11e8</span><span class="number">-8</span>a6f<span class="number">-6</span>c92bf21d8b5:<span class="number">1</span><span class="number">-1519695</span>, <span class="number">4</span>ccd3917<span class="number">-5</span>f58<span class="number">-11e8</span><span class="number">-8</span>b41<span class="number">-7</span>cd30adfe86a:<span class="number">1</span><span class="number">-9717278</span> |</span><br><span class="line">+---------------+------------------------------------------------------------------------------------------------+</span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> set (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p><p>在从库上执行如下的内容：<br>    <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; stop slave;</span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; reset master;# 这一步是为了把GTID_EXECUTED清空</span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0.03</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show global variables like <span class="string">'GTID_EXECUTED'</span>;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| gtid_executed |       |</span><br><span class="line">+---------------+-------+</span><br><span class="line"><span class="number">1</span> row in set (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set global GTID_PURGED=<span class="string">'18e99fbf-5f38-11e8-8a6f-6c92bf21d8b5:1-1519695,4ccd3917-5f58-11e8-8b41-7cd30adfe86a:1-9717278'</span>;# 把主库的GTID_EXECUTED值填进来</span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0.03</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show global variables like <span class="string">'GTID_EXECUTED'</span>;                                              </span><br><span class="line">+---------------+------------------------------------------------------------------------------------------------+</span><br><span class="line">| Variable_name | Value                                                                                          |</span><br><span class="line">+---------------+------------------------------------------------------------------------------------------------+</span><br><span class="line">| gtid_executed | <span class="number">18e99f</span>bf<span class="number">-5f</span>38<span class="number">-11e8</span><span class="number">-8</span>a6f<span class="number">-6</span>c92bf21d8b5:<span class="number">1</span><span class="number">-1519695</span>, <span class="number">4</span>ccd3917<span class="number">-5f</span>58<span class="number">-11e8</span><span class="number">-8</span>b41<span class="number">-7</span>cd30adfe86a:<span class="number">1</span><span class="number">-9717278</span> |</span><br><span class="line">+---------------+------------------------------------------------------------------------------------------------+</span><br><span class="line"><span class="number">1</span> row in set (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; start slave;</span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure></p><p>再次执行<code>show slave status\G</code>，就好了：<br><img src="/images/gtid12.png" alt="akb48"></p><p>由于mysql的配置文件没有规定<code>readonly</code>，所以我在从库也可以执行insert和update等写操作，但是是不会同步到主库的，而且还会由于主从数据不一致而报错。如果RDS不想要了，直接<code>stop slave</code>，把这个自建mysql当主库就行了。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://www.cnblogs.com/weifeng1463/p/9678303.html" target="_blank" rel="noopener">https://www.cnblogs.com/weifeng1463/p/9678303.html</a><br><a href="https://misakatang.cn/2019/03/02/%E9%98%BF%E9%87%8C%E4%BA%91RDS%E9%80%BB%E8%BE%91%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D%E4%B8%BB%E4%BB%8E/" target="_blank" rel="noopener">https://misakatang.cn/2019/03/02/%E9%98%BF%E9%87%8C%E4%BA%91RDS%E9%80%BB%E8%BE%91%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D%E4%B8%BB%E4%BB%8E/</a><br><a href="https://segmentfault.com/a/1190000015657340" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015657340</a><br><a href="https://help.aliyun.com/knowledge_detail/41817.html" target="_blank" rel="noopener">https://help.aliyun.com/knowledge_detail/41817.html</a></p>]]></content>
    
    <summary type="html">
    
      如果发现/var/log/journal/XXX/system.journal文件过大，可以使用journalctl --vacuum-size=500M 缩小到只有500M
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="阿里云" scheme="http://yoursite.com/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
      <category term="mysql主从" scheme="http://yoursite.com/tags/mysql%E4%B8%BB%E4%BB%8E/"/>
    
      <category term="gtid" scheme="http://yoursite.com/tags/gtid/"/>
    
  </entry>
  
  <entry>
    <title>中秋苏州游记</title>
    <link href="http://yoursite.com/2019/09/23/%E4%B8%AD%E7%A7%8B%E8%8B%8F%E5%B7%9E%E6%B8%B8%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/09/23/中秋苏州游记/</id>
    <published>2019-09-23T01:52:01.000Z</published>
    <updated>2019-09-23T04:47:26.000Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>我之前对苏州的认识并不多，仅仅是“上有天堂,下有苏杭”这样的一个模糊概念。但是一直以来对金庸先生笔下所描写的那个“姑苏”还是有些向往的，于是在这次中秋三天里，我跟媳妇就选择苏州作为度假点，好好的享受了一下这个吴城。</p><h2><span id="苏州的玩">苏州的玩</span></h2><p>苏州论景点最出名的就是三兄弟—“苏州博物馆+忠王府+拙政园”,这三个地方不仅是苏州地标历史景点，而且地理位置还是在一起的。所以到了苏州的第一站，我们就满血冲了过去，苏州博物馆并不大，除了历史文物还有现代艺展，不到100分钟就能粗略浏览完毕。但是那里是著名的网红博物馆，里面到处都是摆造型拍照的女孩子。因为苏州博物馆的确设计的很漂亮，无论是展厅还是中庭，贝聿铭先生对空间的理解真是大师级别。苏州本身并不是一个尖顶建筑众多的城市，但是苏州博物馆是一个尖顶建筑，它整体但不高，天花棚通过条纹晒进阳光，让室内最大限度的透入自然光，使得墙面非常的好看。而且博物馆里的小窗户都是六边形的，可以通过窗看到院子里种的竹子、凉亭、小桥，古朴又不失现代感，更添一份宁静。在苏州博物馆，感受到里面意境和光影不仅仅是一个博物馆，更像是一个创意山水园。<br><img src="/images/苏州博物馆.jpg" alt="akb48"></p><p>苏州博物馆旁边就是忠王府，直接相通，他俩加上拙政园合起来就是天平天国忠王李秀成当年的府邸，忠王府也是迄今为止太平天国历史上保存的最好的建筑物了。一下子从苏州博物馆的艺术氛围跳到王府，画风的转变还是有点快。忠王府里面除了教堂、军事办公室、戏台、大厅和一架大炮之外，还收藏了一些太平天国的历史文物。<br><img src="/images/忠王府大炮.png" alt="akb48"></p><p>忠王府虽然是李秀成的，但是据说他自己却没有完全的住过，因为在同治二年冬（1863年12月），太平天国在苏州的地盘全面失守，当时忠王府的工程仍未完工，只是初具规模而已，李鸿章把忠王府为江苏巡抚行辕。这个建筑后来在1938年，被日本人当做了“江苏省维新政府”驻所。到了1946年，国立社会教育学院借作校舍，解放后收归国有。这幢建筑虽然几次易主，但是大体还算是平安的。相比较而言，它的第一任主人李秀成的命运要比它惨得多。</p><p>从忠王府出来，旁边就是拙政园了。我们同样是在公众号上买票，然后直接安检入门。拙政园就是一个超级大的园林，里面各种树木、池塘、长廊、小亭和假山。鸭子、金鱼在水里随便的游来游去，大片大片的荷叶慵懒的铺在水面上，充足的阳光穿过一层一层的叶子洒落在身上，把人晒得暖洋洋的。拙政园已经是苏州园林的代表，在那里转过之后，那么狮子林和留园等园林也就大同小异了。<br><img src="/images/拙政园长廊.jpg" alt="akb48"></p><p>拙政园离平江路就很近了。平江路作为了一个历史街区，感觉是一个修长的历史画卷。那里面不仅有很多网红店人满为患，还有许多笔直的小里巷，粉墙黛瓦，高低差参，栉比鳞次，有的宽仅一米，狭窄而幽深，空荡荡，看不到一个人。在这里不自觉就会把脚步放慢，一个店一个店慢慢的走过去，在商业化气息严重的今天，还是能感受一下老苏州的质朴。走到夕阳西下，我们花了80块坐了一次小船，摇船的大姐给我们唱了当地的小调—《小城故事多》、《秦淮景》、《四季歌》等等。船在水上，人在画中，小桥流水，倒映着斑驳旧影，垂柳依依，掩映着白墙黑瓦。悠悠水乡，多少沧桑，古朴幽静，船橹摇荡。这就是平江路的夜。</p><p>到了苏州，怎能不听评弹？有一句俗话叫做“宁愿听苏州人吵架，也不听宁波人说话”，用以形容苏州方言的动听。而且随着《都挺好》的热播，苏州平江路上大大小小的评弹店都是挂上了各种各样《都挺好》的因素。我选择了“琵琶语评弹茶座”，虽然店面不算太好找，但是里面却是人气爆棚。价钱很便宜，38块钱叫上一杯绿茶就可以在里面听上几段评弹，还可以有昆曲点播。听不懂苏州的吴侬软语不要怕，墙上有电子屏幕同步显示歌词。几曲咿咿呀呀下来，感觉自己被苏大强附体，不禁得摇头晃脑起来。</p><p>寒山寺也是一个苏州招牌景点，那句“姑苏城外寒山寺，夜半钟声到客船”俨然成了寒山寺的最好的宣传口号。那首诗也在寺里被至少几十个碑被各种历史名流篆刻。诗虽然流传千年，但是现在寒山寺的钟已经不再是当年的那口钟了，寒山寺还是保留着过年敲钟108下的习惯，为整个苏州辞旧迎新，祈祷平安。<br><img src="/images/寒山寺.jpg" alt="akb48"></p><p>寒山寺里就跟一般的寺院差不多，到没有什么特别。走了一圈，让我比较有印象的是寒拾殿。此殿位于藏经楼内，楼的屋脊上雕饰着《西游记》人物故事，是唐僧师徒自西天取得真经而归的形象。<br><img src="/images/寒山寺西游记.png" alt="akb48"></p><p>第一天走完了苏州的古，回到民宿好好泡了脚休息一番。第二天驱车奔向金鸡湖开发区，去感受苏州的新。我们先后逛了苏州中心、东方之门和诚品书店。逛街本身只是例行打卡而已，毕竟苏州有的东西基本杭州都有。不过金鸡湖有直升飞机可以坐，860元一趟（2~4人），可以带你绕金鸡湖飞一圈，一趟下来大约需要20分钟，但是要很早的预约。夜生活的话，如果想去livehouse耍耍，那么观前街和十全街有酒吧可以满足需求，高中低档的一应俱全。<br><img src="/images/诚品书店.jpg" alt="akb48" title="诚品书店不仅仅卖书，看这个大拼图"></p><h2><span id="苏州的吃">苏州的吃</span></h2><p>苏州的吃我并没有特别做攻略下功夫，按照随遇而安的心态，正餐都是在一般的店解决的。第一天到苏州后去琼琳阁吃了有名的焖肉面，晚上是在平江路靠路两边的小吃填饱肚子。第二天中午在苏州中心的南京大排档里尝了鸭血粉丝汤和烤鸭，晚上在石路的小郡肝钢管厂五号的串串店解决。至于最后一天中午，由于要玩VR，我们就在VR店附近的万达广场吃了汉拿山烤肉（囧，这顿饭一点都不苏州）。</p><p>苏州菜跟杭州菜对于东北出身的我来说，感觉师出一路，口味都是精致偏甜，里面的甜相比较用糖更多的是用酱。松鼠桂鱼和蟹黄豆腐基本是每一个苏州菜馆的菜单必备，如果觉得油腻再叫上一壶碧螺春刮刮油。相比较杭州羊肉的匮乏，苏州街边的藏书羊肉店是随处可见，里面羊肉汤羊肉饺子羊肉火锅各种吃法一应俱全。中秋时期还算是吃阳澄湖大闸蟹的季节，但是据说苏州的正餐里是不上大闸蟹的，因为一旦上了大闸蟹，大家的注意力都在拆蟹吃蟹上，宴会的气氛就会冷淡下来。至于小吃，我吃到了平江路的鸡脚旮旯的酱鸡爪，味道蛮好的，但是一定要带汤一起吃，没有汤的鸡爪子是没有灵魂的。除此之外，也吃到了哑巴生煎，感觉跟杭州的生煎味道差不多。<br><img src="/images/鸡脚旮旯.png" alt="akb48"></p><p>最后着重说一下石路上小郡肝钢管厂五区里面的土豆块，真是超级好吃，我后来在杭州的几家小郡肝找了一下都没有这个小菜。所以强烈推荐，到了苏州一定不要错过它！</p><h2><span id="一点小tips">一点小tips</span></h2><ol><li>苏州的老城区是限号的，所以外地车辆在手机地图上应该提前设置好车牌，高德地图就直接把我们导航到了驳接车站那里；</li><li>从苏州北旅游换乘中心做免费车去苏州博物馆，但是最晚一趟车是5点半，所以超过这个点就只能打车回换乘中心了；</li><li>苏州博物馆、拙政园、狮子林等都可以在微信公众号上购票，由于苏州博物馆是免费的，所以推荐先拍下苏州博物馆的票，然后看一下拙政园的情况再买票，买票检查是需要身份证的；</li><li>平江路坐船，撑船大姐唱歌是要付费的，30一次；</li></ol><p>苏州仅仅游玩了三天是不够的，我这一次的行程非常粗浅，并没有包括狮子林、虎丘、留园、苏州大学以及华谊兄弟乐园（能蹦极）等著名景点。但是这短短的两天时间却让我喜欢上了这个南方小城，它就像杭州的姐妹，既有温婉可人的一面也有工业发展的一面。最后就用刘以达的一首《我的天使》作为结局吧，这段歌词特别符合我这个初行者对苏州的印象：<br>    <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">爱似浓郁咖啡 围裙除去 晚妆一卸</span><br><span class="line">拥抱一夜 以後百夜 亦暖些</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      江南风情甲天下，苏州园林甲江南
    
    </summary>
    
      <category term="坠乱花天" scheme="http://yoursite.com/categories/%E5%9D%A0%E4%B9%B1%E8%8A%B1%E5%A4%A9/"/>
    
    
      <category term="旅游" scheme="http://yoursite.com/tags/%E6%97%85%E6%B8%B8/"/>
    
      <category term="苏州" scheme="http://yoursite.com/tags/%E8%8B%8F%E5%B7%9E/"/>
    
  </entry>
  
  <entry>
    <title>Linux运维工程师笔试题第二十套</title>
    <link href="http://yoursite.com/2019/09/16/Linux%E8%BF%90%E7%BB%B4%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%AC%94%E8%AF%95%E9%A2%98%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%A5%97/"/>
    <id>http://yoursite.com/2019/09/16/Linux运维工程师笔试题第二十套/</id>
    <published>2019-09-16T08:10:28.000Z</published>
    <updated>2019-09-23T09:32:46.000Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="试题正文">试题正文</span></h2><ol><li><p>请解释Deployment、ReplicaSets、StatefulSets、Pod、Job、CronJob的不同用途<br><code>Deployment</code>的应用场景： 无状态的、轻量级应用<br><code>StatefulSets</code>的应用场景： 有状态的应用，每个节点有固定的的身份ID、Pod的启动有先后顺序、存储使用持久化存储卷（PV/PVC）；<br><code>Deployment</code>和<code>Statefulset</code>之间很显著的区别是deployment的pod名每次重启之后会变，而stateful不会变，另外statefuset的启动是有顺序的。<br><code>Job</code>的应用场景： 负责处理任务，即仅执行一次的任务，它保证批处理任务的一个或多个Pod成功结束；<br><code>CronJob</code>的应用场景: 在给定的时间点运行一个任务，也可以周期性地在给定时间点运行；</p></li><li><p>Kubernetes 如何处理持久性？<br>根据独立的存储系统如NFS、iSCSI、cephfs、glusterfs等，创建动态/静态PV，然后对应绑定PVC，然后在POD里使用PVC即可。</p></li><li><p>什么是sidecar容器？你能给出一个用例，说明你为什么要使用它么？<br>将应用程序的功能划分为单独的进程可以被视为 Sidecar 容器。Sidecar的设计模式允许你为应用程序添加许多功能，而无需额外第三方组件的配置和代码。<br>实际的应用场景是比如一些服务，还要搭配<code>监控、日志、集中化配置和网络服务</code>这样的附属服务的时候，就可以考虑用sidecar模式。</p></li><li><p>kubernetes包含几个组件。 各个组件的功能是什么。组件之间是如何交互的。<br>k8s大致分为3个部分：Master节点、Node节点、应用。</p></li></ol><p>Master节点提供集群的控制面板，其下组件有：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kube-apiserver 提供k8s的API调用服务。</span><br><span class="line">etcd 数据中心，存储集群的所有数据。</span><br><span class="line">kube-scheduler 调度器，负责给新创建的容器分配节点等。</span><br><span class="line">kube-controller-manager 控制管理器，负责监控和维护集群状态。</span><br><span class="line">cloud-controller-manager 是提供给第三方开发k8s特性的。</span><br></pre></td></tr></table></figure></p><p>其中controller又包含：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Node Controller 报告节点健康状态。</span><br><span class="line">Replication Controller 维护rc的pod个数，pod挂掉又控制重启。</span><br><span class="line">Endpoints Controller 填充Endpoint对象，主要是给Service和Pod。</span><br><span class="line">Service Account &amp; Token Controllers 创建帐号和Token。</span><br></pre></td></tr></table></figure></p><p>Node节点组件：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubelet 管理Pod里面的容器。</span><br><span class="line">kube-proxy 管理网络路由规则。</span><br><span class="line">container runtime 容器运行环境，如Docker等。</span><br></pre></td></tr></table></figure></p><p>应用都是部署在<code>kube-system</code>这个命名空间下的。如：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DNS dns服务。</span><br><span class="line">Dashboard web管理界面。</span><br><span class="line">Container Resource Monitoring 容器资源管理和监控，如cAdvisor、Prometheus。</span><br><span class="line">Cluster-level Logging 日志收集分节点、集群、应用三种类型，可用elk或fluentd等。</span><br></pre></td></tr></table></figure></p><ol><li><p>k8s中的pod内几个容器之间的关系是什么。<br>一个Pod是一组容器的集合，像豌豆荚于豌豆。提供容器间存储和网络的共享，和一系列运行规范。Pod里面的容器共享网络，因此可使用localhost通讯。由于也共享存储，所以可以使用IPC和共享内存进行通讯。</p></li><li><p>如何在 Kubernetes 中实现负载均衡？<br>通过创建service来实现负载均衡，<code>Service Cluster IP</code> 是一个虚拟 IP，它与<code>pod IP</code>的映射关系是通过<code>iptables</code>，而且用的是使用类似轮询的负载均衡策略（iptables规则里有–probability 0.33332999982这样的标记）。</p></li><li><p>Deployment、Rc、Rs有什么区别。 其使用方式使用条件和原理是什么。<br><code>Replication Controller</code>是最早的部署、升级Pod的管理工具，他能保证pod的健康个数。<br><code>Replication Set</code>包含RC的所有功能，它比RC强的地方就是RC只支持等式的seletor，而RS的用法更丰富。<br><code>Deployment</code>比RS还高级，而且支持历史回溯、回滚、查看事件状态、暂停启动升级等功能，而且它支持两种升级方案：Recreate（全毁重建）、RollingUpdate（默认，逐步替换）</p></li><li><p>Cgroup中的cpu有哪几种限制方式。<br>Cgroup限制CPU的方式有三种：<code>cpuset</code>、<code>cpuquota</code>、<code>cpushares</code>，具体如下：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cpuset隔离方式是以分配核心的方式进行资源隔离，可以提供的资源分配最小粒度是核心，不能提供更细粒度的资源隔离，但是隔离之后运算的相互影响最低。需要注意的是在服务器开启了超线程的情况下，要小心选择分配的核心，否则不同cgroup间的性能差距会比较大。</span><br><span class="line">cpuquota给我们提供了一种比cpuset可以更细粒度的分配资源的方式，并且保证了cgroup使用cpu比率的上限，相当于对cpu资源的硬限制。</span><br><span class="line">cpushares给我们提供了一种可以按权重比率弹性分配cpu时间资源的手段：当cpu空闲的时候，某一个要占用cpu的cgroup可以完全占用剩余cpu时间，充分利用资源。而当其他cgroup需要占用的时候，每个cgroup都能保证其最低占用时间比率，达到资源隔离的效果。</span><br></pre></td></tr></table></figure></li></ol><p>注意！Linux cgroup和Docker都将CPU核心数分成了1024个时间片（shares），而Kubernetes将它分成了1000个shares。所以有时候用docker inspect和kubectl查看有小小的误差。</p><ol><li><p>k8s是如何使用实现request和limit的？<br>CPU 资源限制和内存资源限制一样都是由cgroup控制</p></li><li><p>kubectl run这个命令敲下去会有什么过程？<br>首先kubectl会先进行客户端验证的操作，kubectl run会自己判断创建的资源类型，比如当<code>-–replicas=1</code>的时候<code>--restart=Never</code>，那么生成的就是pod。如果有指定参数<code>--generator</code>，可以来部署其他多种资源类型。</p></li></ol><p>然后通过<code>apiVersion</code>字段生成REST路径并且真正地发送HTTP请求。一旦请求发送到kube-apiserver之后获得成功的响应，kube-apiserver将对HTTP请求进行反序列化，然后利用得到的结果构建运行时对象的信息（有点像kubectl生成器的逆过程），并保存到etcd中。</p><p>此时Scheduler开始调度，第一轮算法是淘汰掉不满足pod需求的节点，第二轮算法是在符合要求的候选节点上进行优选，将结果打分。一旦找到了合适的节点，Scheduler就会创建一个Binding对象，该对象的Name和Uid与Pod相匹配，然后通过POST请求发送给apiserver。apiserver会把该资源与对应的node记录到etcd里。</p><p>Kubelet服务进程会根据度结果先创建pause容器，然后再进行业务Pod的创建。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://juejin.im/post/5d28508ff265da1b7638ceeb" target="_blank" rel="noopener">https://juejin.im/post/5d28508ff265da1b7638ceeb</a> （kubectl 创建 Pod 背后到底发生了什么？）<br><img src="/images/幼詹助攻里基戴维斯.gif" alt="paradin" title="幼詹放弃扣篮，助攻里基代维斯"></p>]]></content>
    
    <summary type="html">
    
      这次是跟K8S相关的题
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="大牛之路" scheme="http://yoursite.com/tags/%E5%A4%A7%E7%89%9B%E4%B9%8B%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>解决Mysql的CPU过高的问题</title>
    <link href="http://yoursite.com/2019/09/11/%E8%A7%A3%E5%86%B3Mysql%E7%9A%84CPU%E8%BF%87%E9%AB%98%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/09/11/解决Mysql的CPU过高的问题/</id>
    <published>2019-09-11T13:29:58.000Z</published>
    <updated>2019-10-18T10:05:10.000Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="正文">正文</span></h2><p>今儿发现AWS有一个mysql5.6.40数据库从库（2核16G，最大IOPS 2000）的CPU很不正常，如图：<br><img src="/images/mysql4.png" alt="paradin"></p><p>先查看了一下mysql的总体情况：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Uptime: <span class="number">10471685</span>  Threads: <span class="number">894</span>  Questions: <span class="number">58466385559</span>  Slow queries: <span class="number">2466</span>  Opens: <span class="number">321642</span>  Flush tables: <span class="number">1</span>  Open tables: <span class="number">2000</span>  Queries per second avg: <span class="number">5583.283</span><span class="comment">#Questions是已执行的由客户端发出的语句</span></span><br><span class="line"></span><br><span class="line">MySQL [easyip]&gt; show status where `variable_name` = <span class="string">'Threads_running'</span>;</span><br><span class="line">+-----------------+-------+</span><br><span class="line">| Variable_name   | Value |</span><br><span class="line">+-----------------+-------+</span><br><span class="line">| Threads_running | <span class="number">2</span>     |</span><br><span class="line">+-----------------+-------+</span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> set (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p><p>跑到里用<code>show full processlist</code>一看，发现几乎都是sleep，只有偶尔才会刷出来一两条Query。</p><p>使用<code>tcpdump -s 65535 -x -nn -q -tttt -c 500000 -i any port 3306 &gt; mysql.txt</code>抓一个500M大小的包，然后<code>wget percona.com/get/pt-query-digest</code>和<code>chmod u+x pt-query-digest</code>来安装<code>pt-query-digest</code>，一会我们用它分析一下这个包。</p><p>插播一句，如果使用<code>pt-query-digest</code>的时候爆<code>Can&#39;t locate Digest/MD5.pm in @INC</code>这样的错误，请执行<code>yum install perl-Digest-MD5.x86_64</code>。</p><p>然后执行<code>./pt-query-digest --type tcpdump --watch-server=&#39;mysql的IP地址:3306&#39; mysql.txt &gt;3306.log</code>，打开这个<code>3306.log</code>一探究竟：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 91.2s user time, 4.1s system time, 38.76M rss, 203.35M vsz</span></span><br><span class="line"><span class="comment"># Current date: Wed Sep 11 13:25:02 2019</span></span><br><span class="line"><span class="comment"># Hostname: ip-10-10-153-64.eu-central-1.compute.internal</span></span><br><span class="line"><span class="comment"># Files: mysql.txt</span></span><br><span class="line"><span class="comment"># Overall: 107.03k total, 96 unique, 2.94k QPS, 2.89x concurrency ________</span></span><br><span class="line"><span class="comment"># Time range: 2019-09-11 13:22:21.774093 to 13:22:58.211771</span></span><br><span class="line"><span class="comment"># Attribute          total     min     max     avg     95%  stddev  median</span></span><br><span class="line"><span class="comment"># ============     ======= ======= ======= ======= ======= ======= =======</span></span><br><span class="line"><span class="comment"># Exec time           105s       0    73ms   984us     3ms     2ms   424us</span></span><br><span class="line"><span class="comment"># Rows affecte           0       0       0       0       0       0       0</span></span><br><span class="line"><span class="comment"># Query size        19.41M      18   1.59k  190.15  346.17  109.64  158.58</span></span><br><span class="line"><span class="comment"># Warning coun           0       0       0       0       0       0       0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Profile</span></span><br><span class="line"><span class="comment"># Rank Query ID                      Response time Calls R/Call V/M   Item</span></span><br><span class="line"><span class="comment"># ==== ============================= ============= ===== ====== ===== ====</span></span><br><span class="line"><span class="comment">#    1 0x17439B73926DAFE4B1F7504E... 62.6518 59.5% 62408 0.0010  0.01 SELECT macuserinfo pcs_sys_user</span></span><br><span class="line"><span class="comment">#    2 0x221ABFF7BE95D0B83774ECE7...  7.7099  7.3%  4374 0.0018  0.01 SELECT device_channel_config_info</span></span><br><span class="line"><span class="comment">#    3 0x8D042CE60A67A30092CD7CFD...  6.9497  6.6%  4978 0.0014  0.01 SELECT push_client_info pcs_user_dev_link pcs_sys_user</span></span><br><span class="line"><span class="comment">#    4 0xEBBF1DEAACA1353A4DD445F3...  4.5713  4.3%  3952 0.0012  0.00 SELECT pcs_adm_dev_storage_strategy</span></span><br><span class="line"><span class="comment">#    5 0x49348052DEA8C471AD64477C...  4.1641  4.0%  5227 0.0008  0.00 SELECT pcs_user_dev_link pcs_sys_user</span></span><br><span class="line"><span class="comment">#    6 0xF96D9A42E1EFE0A84717B273...  3.8453  3.7%  4970 0.0008  0.00 SELECT user_authorize_info</span></span><br><span class="line"><span class="comment">#    7 0x40FC0DACAACA50F36466B100...  2.7108  2.6%  4132 0.0007  0.00 SELECT pcs_adm_dev_storage_strategy</span></span><br><span class="line"><span class="comment">#    8 0x24A6818C09D884D5B2DD04FB...  2.2897  2.2%  2095 0.0011  0.01 SELECT device_config_info macuserinfo device_config_info</span></span><br><span class="line"><span class="comment">#    9 0x6E5549936C772E40EBAE1FEE...  1.8566  1.8%  3355 0.0006  0.00 SELECT macinfo</span></span><br><span class="line"><span class="comment">#   10 0x238C2BAB786EE59102CF0654...  1.7066  1.6%  2077 0.0008  0.01 SELECT pcs_user_dev_link pcs_sys_user</span></span><br><span class="line"><span class="comment">#   11 0x327C32C0EBADC5D17957E04C...  0.9152  0.9%  1771 0.0005  0.00 SELECT device_config_info</span></span><br><span class="line"><span class="comment">#   12 0x7190F54D663D68CFE1680408...  0.6966  0.7%  1021 0.0007  0.00 SELECT pcs_adm_dev_storage_strategy</span></span><br><span class="line"><span class="comment"># MISC 0xMISC                         5.2609  5.0%  6669 0.0008   0.0 &lt;84 ITEMS&gt;</span></span><br><span class="line"><span class="comment"># Query 1: 2.71k QPS, 1.72x concurrency, ID 0x17439B73926DAFE4B1F7504E191657C8 at byte 287906107</span></span><br><span class="line"><span class="comment"># This item is included in the report because it matches --limit.</span></span><br><span class="line"><span class="comment"># Scores: V/M = 0.01</span></span><br><span class="line"><span class="comment"># Time range: 2019-09-11 13:22:21.774093 to 13:22:58.211613</span></span><br><span class="line"><span class="comment"># Attribute    pct   total     min     max     avg     95%  stddev  median</span></span><br><span class="line"><span class="comment"># ============ === ======= ======= ======= ======= ======= ======= =======</span></span><br><span class="line"><span class="comment"># Count         58   62408</span></span><br><span class="line"><span class="comment"># Exec time     59     63s   171us    69ms     1ms     3ms     2ms   424us</span></span><br><span class="line"><span class="comment"># Rows affecte   0       0       0       0       0       0       0       0</span></span><br><span class="line"><span class="comment"># Query size    50   9.88M     159     179  166.01  158.58    0.63  158.58</span></span><br><span class="line"><span class="comment"># Warning coun   0       0       0       0       0       0       0       0</span></span><br><span class="line"><span class="comment"># String:</span></span><br><span class="line"><span class="comment"># Hosts        10.10.153.64</span></span><br><span class="line"><span class="comment"># Query_time distribution</span></span><br><span class="line"><span class="comment">#   1us</span></span><br><span class="line"><span class="comment">#  10us</span></span><br><span class="line"><span class="comment"># 100us  ################################################################</span></span><br><span class="line"><span class="comment">#   1ms  #############</span></span><br><span class="line"><span class="comment">#  10ms  #</span></span><br><span class="line"><span class="comment"># 100ms</span></span><br><span class="line"><span class="comment">#    1s</span></span><br><span class="line"><span class="comment">#  10s+</span></span><br><span class="line"><span class="comment"># Tables</span></span><br><span class="line"><span class="comment">#    SHOW TABLE STATUS LIKE 'macuserinfo'\G</span></span><br><span class="line"><span class="comment">#    SHOW CREATE TABLE `macuserinfo`\G</span></span><br><span class="line"><span class="comment">#    SHOW TABLE STATUS LIKE 'pcs_sys_user'\G</span></span><br><span class="line"><span class="comment">#    SHOW CREATE TABLE `pcs_sys_user`\G</span></span><br><span class="line"><span class="comment"># EXPLAIN /*!50100 PARTITIONS*/</span></span><br><span class="line">select  b.id As user_id, b.PROJECT As project, a.user AS user  <span class="keyword">from</span> macuserinfo a, pcs_sys_user b where a.user=b.username <span class="keyword">and</span> a.devsequence=<span class="string">'4L05B49PAZE5806'</span> limit <span class="number">1</span>;\G</span><br><span class="line"></span><br><span class="line"><span class="comment"># Query 2: 120.17 QPS, 0.21x concurrency, ID 0x221ABFF7BE95D0B83774ECE7A62FCB96 at byte 319100665</span></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>从文件里可以看出这个select语句在本次分析中总的时间占比高达60%，但是单次调用耗时极少，不过QPS（每秒执行的查询次数）却高达2.71k QPS，这个应该是CPU高的原因。</p><p>执行一下explain看一下：<br><img src="/images/mysql5.png" alt="paradin"></p><p>然后有用<code>show columns from pcs_sys_user;</code>、<code>show index from pcs_sys_user;</code>和<code>show columns from macuserinfo;</code>、<code>show index from macuserinfo;</code>查看一下是否有漏建索引，发现没有，比如：<br><img src="/images/mysql6.png" alt="paradin"></p><p>这种就是典型的“QPS高导致CPU使用率高”的场景：查询语句比较简单、执行效率高、SQL优化余地小。一般解决的方法就是从应用架构、实例规格等方面入手：</p><ol><li>升级实例规格，增加CPU资源；</li><li>做了分库分表，将查询压力分担到多个RDS实例上；</li><li>使用批量操作，将多个操作合并为一次请求，但此种方式需要考虑是否可以一次批量的数据有多大，避免造成慢sql；</li></ol><h2><span id="后续措施">后续措施</span></h2><p>如上文所说，这个数据库里的sleep的进程也太多了，大量的sleep进程无法及时释放，也拖累系统性能，不过也不能把这个指设置的过小，否则可能会遭遇到<code>MySQL has goneaway</code>之类的问题，默认的等待时间是28000秒，如下：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MySQL [easyip]&gt; show <span class="keyword">global</span> variables like <span class="string">'wait_timeout'</span>;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| wait_timeout  | <span class="number">28800</span> |</span><br><span class="line">+---------------+-------+</span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> set (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p><p>改成3600就够用了…</p><p>注意！本文中的例子里where条件是经常变化的，所以这种场合没有打开<code>query_cache</code>。对于经常修改的表，使用查询缓存可能会加大副本滞后，因为缓存已锁定且会频繁刷新。而对于查询数据比较静态、查询重复度高、查询结果集小于3MB的场景，才考虑开启查询缓存。</p><p>最后，本次故障排查感谢arstercz大神的鼎力相助！<br><img src="/images/樱木扣阿牧.png" alt="akb48"></p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://docs.aws.amazon.com/zh_cn/AmazonRDS/latest/UserGuide/CHAP_Troubleshooting.html" target="_blank" rel="noopener">https://docs.aws.amazon.com/zh_cn/AmazonRDS/latest/UserGuide/CHAP_Troubleshooting.html</a><br><a href="https://aws.amazon.com/cn/blogs/china/pt-query-digest-rds-mysql-slow-searchnew/" target="_blank" rel="noopener">https://aws.amazon.com/cn/blogs/china/pt-query-digest-rds-mysql-slow-searchnew/</a><br><a href="https://jin-yang.github.io/post/mysql-monitor.html" target="_blank" rel="noopener">https://jin-yang.github.io/post/mysql-monitor.html</a><br><a href="https://tech.kujiale.com/shu-ju-ku-cpushi-yong-lu-100-pai-cha-ji/" target="_blank" rel="noopener">https://tech.kujiale.com/shu-ju-ku-cpushi-yong-lu-100-pai-cha-ji/</a><br><a href="http://mysql.taobao.org/monthly/2015/05/02/" target="_blank" rel="noopener">http://mysql.taobao.org/monthly/2015/05/02/</a> （强力推荐！）</p>]]></content>
    
    <summary type="html">
    
      其实很多执行几十几百毫秒的查询使用show full processlist是看不到的，十来个一百多毫秒的查询把2核的数据库CPU搞起来也不是什么奇怪的事儿
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="AWS" scheme="http://yoursite.com/tags/AWS/"/>
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="主从同步" scheme="http://yoursite.com/tags/%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5/"/>
    
  </entry>
  
</feed>
