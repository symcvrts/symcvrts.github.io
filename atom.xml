<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chris Chan&#39;s BLOG</title>
  
  <subtitle>那些在阳光下挥洒青春的日子啊！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-04-27T14:37:57.212Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Chris Chan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>记一次阿里云oss云存储删除失败的问题</title>
    <link href="http://yoursite.com/2018/04/27/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%98%BF%E9%87%8C%E4%BA%91oss%E4%BA%91%E5%AD%98%E5%82%A8%E5%88%A0%E9%99%A4%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/04/27/记一次阿里云oss云存储删除失败的问题/</id>
    <published>2018-04-27T14:24:58.000Z</published>
    <updated>2018-04-27T14:37:57.212Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>公司每天云存储都要删除过期的内容，工作细节是这样的：每天零点，采集模块开始收集应该删除掉的内容，然后把这个消息传给阿里云MQ，阿里云MQ又把消息传给删除模块，删除模块拿到名单之后，开始调用阿里云OSS的删除API进行删除。架构如图：<br><img src="/images/oss6.png" alt="paradin"></p><p>但是今天登陆监控平台发现，昨天oss没有删除，上涨了80多个T，如图：<br><img src="/images/oss1.png" alt="paradin"></p><p>老板一看，我操这怎么可以，80多个T的存储费用可是不容小视的，于是责令追查一下为啥会发生这样的情况。</p><p>昨天我的手机又没有收到任何阿里云消息队列告警的信息，可见MQ应该是没问题的，查看一下是否有MQ的产生和消费情况，如下图：<br><img src="/images/oss2.png" alt="paradin" title="这个是消息产生情况"></p><p><img src="/images/oss3.png" alt="paradin" title="这个是消息消费情况"></p><p>产生的消息基本都消费掉了，之前的过程都应该是OK的，查看一下会不会是删除模块外网带宽到期的问题，此时发现两天的流量有显著的不同：<br><img src="/images/oss7.png" alt="paradin" title="这个是正常的流量情况"></p><p><img src="/images/oss8.png" alt="paradin" title="这个是异常的流量情况"></p><p>再到执行OSS删除API的模块上去抓了几个包，里面情况如下：<br><img src="/images/oss4.png" alt="paradin"></p><p>但是跑到阿里云对应的bucket里看一下文件情况，比如<code>https://lechangecloud.oss-cn-hangzhou.aliyuncs.com/lechange/4B01F1FPAGE4E9D_img/Alarm/20180427000913997_0_fa62bec6dee24cc0bee42e1ee3e75743_thumb_qcif.dav</code>这个文件，这个文件明明还在里面躺着好好的。如图：<br><img src="/images/oss5.png" alt="paradin"></p><p>文件00：27的时候就在了，但是2：53分的时候调用阿里云OSS的API去删除，明明返回了200，但是文件却没有真正的从OSS删除掉。</p><p>又回到刚刚的那个包里，我发现里面还有一些返回的内容是这样的：<br><img src="/images/oss9.png" alt="paradin"></p><p>这个图跟之前的图明显路径上不同，而这些文件在OSS上确认是被成功删除掉的，可见的确是文件路径的问题：失败的文件路径是完全路径，而成功的都是相对路径。于是就告诉开发赶快整改代码，把路径统一…</p><p><img src="/images/朝韩会面.png" alt="paradin"></p>]]></content>
    
    <summary type="html">
    
      金三胖和文在寅，
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="阿里云" scheme="http://yoursite.com/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>在安装docker私有仓库的时候遇到的openssl问题</title>
    <link href="http://yoursite.com/2018/04/21/%E5%9C%A8%E5%AE%89%E8%A3%85docker%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E7%9A%84%E6%97%B6%E5%80%99%E9%81%87%E5%88%B0%E7%9A%84openssl%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/04/21/在安装docker私有仓库的时候遇到的openssl问题/</id>
    <published>2018-04-20T16:45:39.000Z</published>
    <updated>2018-04-26T15:30:53.852Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>按照<a href="http://wiki.jikexueyuan.com/project/docker-technology-and-combat/local_repo.html" target="_blank" rel="noopener">http://wiki.jikexueyuan.com/project/docker-technology-and-combat/local_repo.html</a> 的方法本地安装一个私有仓库，在执行<code>sudo pip install docker-registry</code>这一步的时候，出现了这样的一个错误：<br><img src="/images/openssl1.png" alt="paradin"></p><p>既然说我没有swig，于是我<code>yum install swig -y</code>，安装的是<code>2.0.10-5.el7</code>版本。然后再次<code>pip install docker-registry</code>，一顿噼里啪啦之后，这次成了这样：<br><img src="/images/openssl2.png" alt="paradin"></p><p>又说没有openssl的文件，那执行<code>yum install openssl-devel</code>，OK了之后再次<code>pip install docker-registry</code>，再一次噼里啪啦，如下：<br><img src="/images/openssl3.png" alt="paradin"></p><p>反馈我：<code>/usr/include/openssl/opensslconf.h:44: Error: CPP #error &quot;&quot;This openssl-devel package does not work your architecture?&quot;&quot;. Use the -cpperraswarn option to continue swig processing.</code>,这个提示大意是说openssl-devel版本不适合你的系统架构，也就是x86的去找x86的头文件，x86_64的去找x86_64文件，但现在是互相找不到对方。</p><p>既然说<code>/usr/include/openssl/opensslconf.h</code>这个第44行有错误，那我们就打开这个文件去看看第44行写的是啥：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">41 #elif defined(__x86_64__)</span><br><span class="line">42 #include "opensslconf-x86_64.h"</span><br><span class="line">43 #else</span><br><span class="line">44 #error "This openssl-devel package does not work your architecture?"</span><br><span class="line">45 #endif</span><br><span class="line"><span class="number">46</span> </span><br><span class="line">47 #undef openssl_opensslconf_multilib_redirection_h</span><br></pre></td></tr></table></figure></p><p>这里我把第44行改成了这样：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">41 #elif defined(__x86_64__)</span><br><span class="line">42 #include &quot;opensslconf-x86_64.h&quot;</span><br><span class="line">43 #else</span><br><span class="line">44 #include &quot;opensslconf.h&quot;    #去掉了原来的error提示，改成了安装opensslconf.h文件。</span><br><span class="line">45 #endif</span><br><span class="line">46 </span><br><span class="line">47 #undef openssl_opensslconf_multilib_redirection_h</span><br></pre></td></tr></table></figure></p><p>这一次重新执行<code>sudo pip install docker-registry</code>，终于成功…<br><img src="/images/openssl4.png" alt="paradin"></p><p><img src="/images/agirl.gif" alt="akb48"></p>]]></content>
    
    <summary type="html">
    
      这破玩意查了半天...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
      <category term="容器技术" scheme="http://yoursite.com/tags/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>在国王杯前夕评巴萨</title>
    <link href="http://yoursite.com/2018/04/21/%E5%9C%A8%E5%9B%BD%E7%8E%8B%E6%9D%AF%E5%89%8D%E5%A4%95%E8%AF%84%E5%B7%B4%E8%90%A8/"/>
    <id>http://yoursite.com/2018/04/21/在国王杯前夕评巴萨/</id>
    <published>2018-04-20T16:44:17.000Z</published>
    <updated>2018-04-20T17:40:54.008Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>今天凌晨的马竞在西甲意外输给了皇家社会，巴萨的积分优势扩大到了12分。这个周末巴萨要跟塞维利亚打国王杯决赛，4月30号对拉科鲁尼亚的西甲联赛巴萨只要获胜，就会拿到今年的西甲联赛冠军，从而以冠军姿态在诺坎普迎接本赛季第二场国家德比。</p><h2><span id="巴尔韦德的困境">巴尔韦德的困境</span></h2><p>巴萨今年可以说是低姿态开始：从内马尔突然的离开到西超杯被皇马灌了5个，不可为说不惨。但是巴尔韦德在联赛却目前保持不败，这个成绩单可以说是相当不错的，这中间还有在伯纳乌的三球胜利。</p><p>赛季中前段，巴萨三线顺风顺水，前有塞梅多惊艳开场，后有大祭司维尔马伦扎实顶上，主教练巴尔韦德也给了阿奈斯这样小将出场机会，哪怕登贝莱那时候养伤，报纸媒体一片其乐融融。如果保利尼奥再有进球，更是一片狂欢。</p><p>然后巴尔韦德的保守开始慢慢让人所诟病，他是一个重视防守的教练，这很好，但是他有了库迪尼奥也有了归来的登贝莱，结果反而不敢搞轮换，甚至坚持让布教授打封闭出场，虽然不少人抱怨，但是由于球队整体战绩还算平稳，所以没有大规模的重视。可是巴萨欧冠的结果跟恩里克的第二个赛季一样，倒在了与罗马的第二回合比赛里，连续三年没有闯入欧冠四强。</p><p>其实对战罗马的第一回合，巴萨的4：1已经是靠意志拼下来的比赛，球员难免在第二回合的心态上有所轻敌，这种心态上的轻敌难免会影响到身体，但是巴尔韦德的临场指挥也让人严重不满。落下这耻辱一战，媒体和球迷之前的“忍气吞声”一并爆发，狂轰滥炸，直到现在依旧有人说“哪怕真的赛季双冠，也会因为欧冠的失利而让那两冠索然无味”。<br><img src="/images/fcb4.png" alt="paradin"></p><p>所以，巴尔韦德要在这个周日的国王杯决赛和对阵拉科鲁尼亚的西甲联赛里稳扎稳打，把国王杯和西甲冠军彻底拿到手里，这样整个人也能轻松一些。可是说来说去罗马一役这一个跟头摔得太疼了，在那么重大的比赛里失败，肯定需要在一个同样重大的比赛里胜利以挽回颜面，第二回合的国家德比无疑就是一个好的机会，如果巴尔韦德成功捍卫了诺坎普，“联赛双杀皇马+国内双冠”也能成为一个功劳。但是如果那场比赛，一心要打破巴萨不败金身的皇马真的成功了，那巴尔韦德势必在巴萨主帅的位置上也是飘摇。</p><p>所以巴帅，请务必要拿下国王杯冠军+西甲冠军！在第二个国家德比里也请拼尽全力！这样才能多少挽回一点“罗马之耻”的颜面。<br><img src="/images/fcb1.png" alt="paradin"></p><h2><span id="夏季转会展望">夏季转会展望</span></h2><p>我个人认为，巴萨很有可能在今年夏天卖掉如下几个人：西莱森、戈麦斯、小苏亚雷斯、艾尔卡塞尔、比达尔，自由走人的可能会是小白。这些人能套现7000万应该就满足了。</p><p>巴萨后卫现在四个人皮克和维尔马伦属于潜藏的伤员病号，米纳技术还是太糙，稍微让人放心的就是乌姆蒂蒂，他的续约问题肯定是休赛期的一个大事。不过我觉得米纳其实可以再留一年看看，他身体素质很好，而且人还年轻没伤病，只要心态练得沉稳，当一个合格的中后卫不难。</p><p>至于中场，个人希望小白再踢一年，现在我也觉得一个满血的小白应付普通的联赛、欧冠小组赛和杯赛都不是什么难事。但是目前的媒体趋势是小白赛季结束会来中超重庆队，即使这样巴萨也需要一个山寨的坎特和一个山寨的埃里克森，而罗贝托集这两个属性于一身，所以他就是一个“奉献的砖”，但是这样如果比达尔真的不留下来的话，巴萨还需要补进一个右后卫跟塞梅多良性竞争，这个右后卫的人选就比较挠头了。贝莱林？或许是一个选择，但是这个选择跟当年小法一样—要是双输就不好了。</p><p>前场如果能拿下格里兹曼肯定是好的，艾尔卡塞尔这种“躲着后卫”的踢法，虽然进球效率可以，但是没有真正起到轮换苏亚雷斯的作用。这样巴萨还需要在板凳上补充一个中锋（不用多能进球，哪怕搅屎棍也可以），同时也做好登贝莱/苏亚雷斯/梅西/格里兹曼（假设他真的来）的轮换。</p><p>总而言之，现在巴萨还是回归433比较好，配合442和4312的变化。那么休赛期最重要的补强就是格里兹曼+能抗中卫的前锋+一个中场+一个优秀的边后卫。</p><p>我个人希望的引援名单如下：<br>中场是魏格尔和B队的阿莱尼亚，埃里克森、博格巴和维拉蒂这三个不算是好的选择，要么太贵，要么节奏太慢。至于伊斯科、大卫席尔瓦、皮亚尼奇，那想都别想了，母队不会放人的。至于格雷茨卡，拜仁不是善茬；<br>边后卫可以考虑贝莱林，这个要看一下阿森纳的新教练是谁，摩纳哥的法比尼奥也可以，我知道他现在改中场了，也不耽误来一下跟罗贝托交叉换位…<br>前锋的话，我个人推荐B队阿奈斯试试看，其他的人选估计就是在西甲联赛内部找了；<br>这几个位置，最重要就是中场！梅西当初在哈白布的配合下威力无穷，一旦巴萨的中场重新掌握了控制力，不用频繁回撤的梅西依旧会进球如麻，这一点毋庸置疑。<br><img src="/images/fcb3.png" alt="paradin"></p><h2><span id="温格会来">温格会来？</span></h2><p>我个人首先不希望巴尔韦德下课，毕竟现在巴萨联赛冠军十拿九稳，国王杯如果也揽入怀中，这样一个成绩单也是一个80分，如果这个分数都炒掉主教练，那么继任者的压力势必很大，所以我个人倾向巴尔韦德留任，好好想一下，等阿图尔以及可能会来的格里兹曼到位了，巴萨应该怎么打。</p><p>不过如果温格真的来了，我个人也是赞成的，因为阿森纳的球风本来跟巴萨相似，相信温格跟梅西等人也会无缝接入，到时候教授或许真的可以在巴萨圆了欧冠梦想，不过这个想法成真的可能性低于5%，想想就得了。</p><h2><span id="下赛季的任务">下赛季的任务</span></h2><p>1.进攻体系依旧围绕梅西建队，让梅西继续火力全开的同时保证休息，欧冠要他有大用；<br>2.新球员（包括库蒂尼奥和登贝莱）适应巴萨的风格和体系，让皮克和布教授也能轮换得到休息；<br>3.欧冠一定要进入四强；<br>4.欧冠四强的基础上，西甲联赛冠军和国王杯能拿还是要拿，同时最好也能阻击皇马；<br><img src="/images/fcb2.png" alt="paradin"></p>]]></content>
    
    <summary type="html">
    
      这几天的巴萨真是风雨飘摇，操碎我的心
    
    </summary>
    
      <category term="追乱花天" scheme="http://yoursite.com/categories/%E8%BF%BD%E4%B9%B1%E8%8A%B1%E5%A4%A9/"/>
    
    
      <category term="国际足坛" scheme="http://yoursite.com/tags/%E5%9B%BD%E9%99%85%E8%B6%B3%E5%9D%9B/"/>
    
      <category term="巴塞罗那" scheme="http://yoursite.com/tags/%E5%B7%B4%E5%A1%9E%E7%BD%97%E9%82%A3/"/>
    
  </entry>
  
  <entry>
    <title>国内Docker的加速方法</title>
    <link href="http://yoursite.com/2018/04/20/%E5%9B%BD%E5%86%85Docker%E7%9A%84%E5%8A%A0%E9%80%9F%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2018/04/20/国内Docker的加速方法/</id>
    <published>2018-04-19T16:00:04.000Z</published>
    <updated>2018-04-19T16:17:09.102Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>由于大陆政府的特殊政策，国内想访问一些国外的资源是非常的曲折和痛苦，比较有代表性的就是亚马逊的云存储以及docker，尤其在<code>docker pull</code>一些镜像的时候，更是心惊胆战，祈求不要出现timout，然而现实往往很骨感。如下图：<br><img src="/images/jiasu.png" alt="paradin"></p><p>那么应该如何达到加速的效果呢？</p><p>在<code>CentOS 7</code>里，对于使用<code>systemd</code>的系统，请在<code>/etc/docker/daemon.json</code>中写入如下内容：（如果文件不存在请新建该文件）<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"registry-mirrors"</span>: [</span><br><span class="line">    <span class="string">"https://registry.docker-cn.com"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意，一定要保证该文件符合 json 规范，否则 Docker 将不能启动。</p><p>之后重新启动服务。<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></table></figure></p><p>注意：如果您之前查看旧教程，修改了<code>docker.service</code>文件内容，请去掉您添加的内容（–registry-mirror=<a href="https://registry.docker-cn.com）。" target="_blank" rel="noopener">https://registry.docker-cn.com）。</a></p><p>配置加速之后，如果拉取镜像仍然十分缓慢，请手动检查加速器配置是否生效，在命令行执行<code>docker info |grep &#39;Registry Mirrors&#39; -A</code>，如果从结果中看到了如下内容，说明配置成功。<br><img src="/images/jiasu2.png" alt="paradin"></p><p>现在再重新尝试一下<code>docker pull training/webapp</code>，看看效果：<br><img src="/images/jiasu3.png" alt="paradin"></p><p>仅用17秒就pull了几乎400MB的镜像，高下立判！</p>]]></content>
    
    <summary type="html">
    
      墙内想干点事的确挺费劲
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>在Grafana里添加worldping插件</title>
    <link href="http://yoursite.com/2018/04/19/%E5%9C%A8Grafana%E9%87%8C%E6%B7%BB%E5%8A%A0worldping%E6%8F%92%E4%BB%B6/"/>
    <id>http://yoursite.com/2018/04/19/在Grafana里添加worldping插件/</id>
    <published>2018-04-19T02:41:18.000Z</published>
    <updated>2018-04-19T03:53:34.284Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="安装插件">安装插件</span></h2><p>worldping是一个监控网站的dns、ping、http响应、https响应的插件，要安装它很简单，在granafa服务器里执行如下命令：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grafana-cli plugins install raintank-worldping-app</span><br><span class="line">systemctl restart grafana-server.service</span><br></pre></td></tr></table></figure></p><p>执行完毕之后在grafana的界面里选择<code>Plugins</code>，然后在<code>APP</code>里找到<code>worldping</code>，启动它，但是此时发现需要一个api，如图：<br><img src="/images/worldping.png" alt="paradin"></p><p>此时你需要登录grafana的官网，然后点击<code>api keys</code>和<code>ADD API KEY</code>，就可以生成一个<code>API KEY</code>，名字可以随便起，如下：<br><img src="/images/worldping2.png" alt="paradin"></p><p>将生成的api key保存好，并且填回到grafana的api key里，这样worldping插件就可以使用了，如图：<br><img src="/images/worldping3.png" alt="paradin"></p><h2><span id="监控网站节点">监控网站节点</span></h2><p>此时点击黄色旋涡，发现多了worldping的选项，点击<code>worldping Home</code>，如图：<br><img src="/images/worldping4.png" alt="paradin"></p><p>然后点击<code>+ New Endpoint</code>，这里我输入我公司的官网域名，然后<code>begin auto-discovery</code>，如图：<br><img src="/images/worldping5.png" alt="paradin"></p><p>生成了结果之后，点击add，此时开始检查几个大城市，如芝加哥、东京、纽约、巴黎等大城市连接到刚刚输入的域名的情况，如图：<br><img src="/images/worldping6.png" alt="paradin"></p><p>大约需要1~2分钟后，数据检查完成，可以点击<code>GO to Summary Dashboard</code>，就会看到图像了：<br><img src="/images/worldping7.png" alt="paradin"></p><p>为什么我这个图里没有http?因为在nginx里我们做了http强制rewrite跳转到https，所以是读不到值的。</p><h2><span id="删除网站节点">删除网站节点</span></h2><p>如果要删除网站节点，还是在worldping里点击要删除网站后面的齿轮图标，如图：<br><img src="/images/worldping8.png" alt="paradin"></p><p>然后选择<code>configuration</code>，这里可以修改网站域名，要删除的话，选择最下面的<code>destory</code>，输入DELETE确认，然后就可以点击<code>DELETE</code>删除了，如图：<br><img src="/images/worldping9.png" alt="paradin"></p>]]></content>
    
    <summary type="html">
    
      这个搭配zabbix的网站监控，双重check!
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="grafana" scheme="http://yoursite.com/tags/grafana/"/>
    
      <category term="图像监控" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%83%8F%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>用非root用户启动tomcat进程</title>
    <link href="http://yoursite.com/2018/04/18/%E4%BD%BF%E7%94%A8%E6%99%AE%E9%80%9A%E7%94%A8%E6%88%B7%E5%90%AF%E5%8A%A8tomcat/"/>
    <id>http://yoursite.com/2018/04/18/使用普通用户启动tomcat/</id>
    <published>2018-04-18T14:19:34.000Z</published>
    <updated>2018-04-19T14:05:04.577Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>使用非root用户启动进程是运维安全的一个主要环节，拿tomcat进程来说，如果是使用root用户去启动了tomcat，那么有一个严重的问题，那就是tomcat具有root权限。这意味着你的任何一个jsp脚本都具有root权限，所以那些不怀好意的人可以轻易地用jsp脚本去搞破坏，甚至删除你整个硬盘里的东西！所以为了活着，我们要极力避免这种现象。很多的软件都自带的用户/用户组，比如nginx、zabbix、elasticsearch，但是也有很多的软件没有这么贴心的服务，这就需要我们手动的更改了。</p><h2><span id="使用非root用户启动tomcat">使用非root用户启动tomcat</span></h2><p>以tomcat为例，打算用chris账号(属于chen这个group)启动。那么首先先创建账号和组，如下：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@chen-docker ~]groupadd chen    #创建chen这个组</span><br><span class="line">[root@chen-docker ~]useradd -s /bin/bash -g chen chris    #在这个组里面添加chris这个用户</span><br><span class="line">[root@chen-docker ~]passwd chris    #给这个用户设定密码</span><br><span class="line">[root@chen-docker ~]# id chris</span><br><span class="line">uid=1000(chris) gid=1002(chen) groups=1002(chen)    #可见添加成功</span><br></pre></td></tr></table></figure></p><p><code>su chris</code>切换到chris用户，在<code>/home/chris</code>里使用<code>wget http://apache.fayea.com/tomcat/tomcat-9/v9.0.7/bin/apache-tomcat-9.0.7.tar.gz</code>下载tomcat。然后解压缩在/home/chris里，因为chris用户在这里是有权限的。然后进行如下的操作：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd  ~<span class="regexp">/ 代表用户所在目录</span></span><br><span class="line"><span class="regexp">mkdir -p ~/</span>shell-script</span><br><span class="line">cd ~<span class="regexp">/shell-script/</span></span><br><span class="line">touch start.sh</span><br><span class="line">toush stop.sh</span><br></pre></td></tr></table></figure></p><p>这个<code>start.sh</code>的内容很简单，如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#/bin/bash</span><br><span class="line">if [ "root" == "$USER" ]    #不让root启动</span><br><span class="line">then</span><br><span class="line">    echo <span class="string">"can't start with user 'root',retry after change user!"</span></span><br><span class="line">    exit <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    cd /home/chris/apache-tomcat<span class="number">-9.0</span><span class="number">.7</span>/bin/    &amp;&amp; ./start.sh</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p><p><code>shutdown.sh</code>的内容同理：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#/bin/bash</span><br><span class="line">if [ "root" == "$USER" ]    #不让root启动</span><br><span class="line">then</span><br><span class="line">    echo <span class="string">"can't start with user 'root',retry after change user!"</span></span><br><span class="line">    exit <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    cd /home/chris/apache-tomcat<span class="number">-9.0</span><span class="number">.7</span>/bin/    &amp;&amp; ./shutdown.sh</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p><p><code>chmod +x *.sh</code>给上面两个脚本可执行权限，但是现在执行startup.sh或者shutdown.sh会出现一个问题：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Neither the JAVA_HOME nor the JRE_HOME environment variable is defined</span><br><span class="line">At least one <span class="keyword">of</span> these environment variable is needed to run <span class="keyword">this</span> program</span><br></pre></td></tr></table></figure></p><p>这是因为chris用户没有权限去启动java这个可执行程序，如果使用<code>java -version</code>回答是<code>bash: java: command not found</code>，这个时候怎么办？</p><p>编辑<code>~/.bash_profile</code>，在末尾处加上如下的内容：<br><img src="/images/noroot2.png" alt="paradin"></p><p>然后<code>source .bash_profile</code>，再使用<code>java -version</code>确认一下应该是OK了。这个时候也是可以使用chris用户去启动刚刚的那个start.sh和shutdown.sh的。<br><img src="/images/noroot3.png" alt="paradin"></p><p>由于我们的tomcat是源码解压缩，所以要使用root用户去创建一下<code>/etc/init.d/tomcat</code>。里面内容如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">case</span> $<span class="number">1</span> <span class="keyword">in</span></span><br><span class="line">start)</span><br><span class="line">su - chris -lc "sh /home/chris/shell-script/start.sh";;     #如果要root启动，那就是su - root -lc "sh /home/utomcat/shell-script/start.sh";;</span><br><span class="line">stop)</span><br><span class="line">su - chris -lc <span class="string">"sh /home/chris/shell-script/shutdown.sh"</span>;;</span><br><span class="line">*)</span><br><span class="line">echo <span class="string">"parameter error, usage:(start|stop)"</span>;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure></p><p>保存之后，执行一下<code>service tomcat start</code>看看效果。<br><img src="/images/noroot4.png" alt="paradin"></p><p>如果要设置开机自启动，别忘了<code>chkconfig --add tomcat</code>和<code>chkconfig tomcat on</code>，在浏览器打开<code>ip:8080</code>看见汤姆猫~<br><img src="/images/noroot5.png" alt="paradin"></p><h2><span id="当普通用户要使用1024以下的端口">当普通用户要使用1024以下的端口</span></h2><p>众所周知，linux默认是不准许普通用户调用1024以下的端口的，那么遇到这样的需求怎么办呢？最好的方法是使用iptables。</p><p>首先让程序运行在非root帐户下，并绑定高于1024的端口，在确保能正常工作的时候，将低端口通过端口转发，将低端口转到高端口，从而实现非root运行的程序绑定低端口。要使用此方法可以使用下面的方式：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w net.ipv4.ip_forward=1        #要长久保存，需要在/etc/sysctl.conf文件内修改，然后sysctl -p /etc/sysctl.conf</span><br><span class="line">iptables -F -t nat</span><br><span class="line">iptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to:8088    #将80端口转发到8088</span><br><span class="line">iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 8080    #这句话也可以</span><br></pre></td></tr></table></figure></p><p>这么操作在速度上没有任何影响。</p>]]></content>
    
    <summary type="html">
    
      chmod u+s 就是给某个程序的所有者以suid权限，可以像root用户一样操作
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="centos" scheme="http://yoursite.com/tags/centos/"/>
    
      <category term="运维安全" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>使用docker做一个主从同步的redis集群</title>
    <link href="http://yoursite.com/2018/04/18/%E4%BD%BF%E7%94%A8docker%E5%81%9A%E4%B8%80%E4%B8%AA%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E7%9A%84redis%E9%9B%86%E7%BE%A4/"/>
    <id>http://yoursite.com/2018/04/18/使用docker做一个主从同步的redis集群/</id>
    <published>2018-04-17T16:14:44.000Z</published>
    <updated>2018-04-19T03:51:26.430Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="查看容器内部信息">查看容器内部信息</span></h2><p>之前用<code>docker run -it --name redis-master redis /bin/bash</code>创建了一个redis的docker，现在登陆发现状态已经是exit，于是就使用<code>docker container start 容器ID号or容器名称</code>来重新启动。如图：<br><img src="/images/docker4.png" alt="paradin"></p><p>然后书里说到要用<code>docker inspect</code>来查看所挂载volume的情况，使用命令:<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@chen-docker ~]# docker inspect --format &quot;&#123;&#123; .Volumes &#125;&#125;&quot; f391531120b0</span><br></pre></td></tr></table></figure></p><p>但是很不幸，系统反馈给我一个错误：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Template parsing error: template: :1:3: executing &quot;&quot; at &lt;.Volumes&gt;: map has no entry for key &quot;Volumes&quot;</span><br></pre></td></tr></table></figure></p><p>没有这个<code>Volumes</code>，那就干脆查看一下这个容器的所有信息：<code>docker inspect f391531120b0</code>，这个命令里面有<code>Config、Mounts</code>、<code>HostConfig</code>、<code>NetworkSettings</code>等等整个容器的所有信息，比如看一下NetworkSettings相关的内容，如图：<br><img src="/images/docker6.png" alt="paradin"></p><p>此时使用如下命令：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@chen-docker ~]# docker inspect --format &quot;&#123;&#123; .NetworkSettings.IPAddress &#125;&#125;&quot; f391531120b0    #注意前面的.</span><br><span class="line">192.168.0.2</span><br><span class="line">[root@chen-docker ~]# docker inspect --format &quot;&#123;&#123; .NetworkSettings.MacAddress &#125;&#125;&quot; f391531120b0</span><br><span class="line">02:42:c0:a8:00:02</span><br></pre></td></tr></table></figure></p><p>这样就可以获取到内网IP和mac地址，同理换成<code>docker inspect f391531120b0 | grep Mounts -A 10</code>，看一下挂载信息，如图：<br><img src="/images/docker5.png" alt="paradin"></p><p>原来容器里的/data其实就是宿主机的<code>/var/lib/docker/volumes/94b3c20a6d269c7498ab59ee45c560e84fed64a636767a4baa54fa7befbcd4ff/_data</code>这个文件夹。为了验证这一点，我先到宿主机去创建一个叫aaa文件，如下：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@f391531120b0:/data# cat aaa </span><br><span class="line">123123</span><br></pre></td></tr></table></figure></p><p>再返回到宿主机上看：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@chen-docker ~]# cd /var/lib/docker/volumes/94b3c20a6d269c7498ab59ee45c560e84fed64a636767a4baa54fa7befbcd4ff/_data</span><br><span class="line">[root@chen-docker _data]# ls</span><br><span class="line">aaa</span><br><span class="line">[root@chen-docker _data]# cat aaa </span><br><span class="line">123123</span><br></pre></td></tr></table></figure></p><p>这就搞定了！</p><h2><span id="主从同步排错">主从同步排错</span></h2><p>就是按书里写的开始配置和启动<code>redis-slave</code>，但是却发现同步没有成功，在<code>redis-slave</code>日志里发现这样的话：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">32677:S 08 Feb 16:14:40.952 * Connecting to MASTER 172.168.10.70:6379</span><br><span class="line">32677:S 08 Feb 16:14:40.952 * MASTER &lt;-&gt; SLAVE sync started</span><br><span class="line">32677:S 08 Feb 16:14:40.953 # Error condition on socket for SYNC: Connection refused</span><br></pre></td></tr></table></figure></p><p>这个的原因就是redis主服务器绑定了127.0.0.1，那么跨服务器IP的访问就会失败，从服务器用IP和端口访问主的时候，主服务器发现本机6379端口绑在了127.0.0.1上，也就是只能本机才能访问，外部请求会被过滤。所以需要修改<code>redis-master</code>的<code>redis.conf</code>，注释掉<code>bind 127.0.0.1</code>，如果是线上生产环境建议绑定IP地址。</p><p>重新启动redis之后，发现同步依然失败，日志变成了这样：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">90:S 17 Apr 09:27:35.906 * Non blocking connect for SYNC fired the event.</span><br><span class="line">90:S 17 Apr 09:27:35.907 # Error reply to PING from master: &apos;-DENIED Redis is running in protected mode because protected mode is enabled, no bind address was specified, no authentication password is requested to clients. In this mode connections are only accepted from the loopback interface. If you want to connect&apos;</span><br><span class="line">90:S 17 Apr 09:27:36.908 * Connecting to MASTER 192.168.0.2:6379</span><br><span class="line">90:S 17 Apr 09:27:36.909 * MASTER &lt;-&gt; SLAVE sync started</span><br><span class="line">90:S 17 Apr 09:27:36.909 * Non blocking connect for SYNC fired the event.</span><br><span class="line">90:S 17 Apr 09:27:36.909 # Error condition on socket for SYNC: Connection reset by peer</span><br></pre></td></tr></table></figure></p><p>这个日志的意思是说redis在没有开启bind和密码的情况下，保护模式被开启。然后Redis的只接受来自环回IPv4和IPv6地址的连接。于是还是要修改redis-master的<code>redis.conf</code>关闭保护模式：<code>portected-mode no</code>，然后重启redis-master即可。</p><h2><span id="容器内安装ping">容器内安装ping</span></h2><p>先检查你的容器是使用什么系统的景象，如果是ubantu那就是<code>apt-get</code>，安装ping的命令如下：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install inetutils-ping</span><br></pre></td></tr></table></figure></p><h2><span id="如何让容器一直启动">如何让容器一直启动</span></h2><p>如果用了一段时间的docker就会发现，我们的容器经常用了一段时间就自动退出了，<code>docker ps</code>已经找不到了，在<code>docker ps -a</code>里面了，如图：<br><img src="/images/docker7.png" alt="paradin"></p><p>然后我们<code>docker start containerId</code>想重新开启这个容器，可能这次来的更快，没几分钟容器又自己关了，由这个问题又可能引发其它很多的问题。</p><p><code>docker run</code>指定的命令如果不是那些一直挂起的命令（比如运行top，不断echo），就是会自动退出的。<code>-d</code>命令是设置detach为<code>true</code>，根据官方的文档，意思是让这个命令在后台运行，但并不是一直运行，Docker容器后台运行,就必须有一个前台进程。主线程结束，容器会退出。</p><p>我们启动容器的时候不要<code>-d</code>命令启动，用<code>-dit</code>就好了，例如：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d hello-world(不要这么做)</span><br><span class="line">docker run -dit hello-world(推荐)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      从《容器与容器云》 的第19页开始...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
      <category term="主从同步" scheme="http://yoursite.com/tags/%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>使用zabbix监控memcache</title>
    <link href="http://yoursite.com/2018/04/03/%E4%BD%BF%E7%94%A8zabbix%E7%9B%91%E6%8E%A7memcache/"/>
    <id>http://yoursite.com/2018/04/03/使用zabbix监控memcache/</id>
    <published>2018-04-03T11:00:58.000Z</published>
    <updated>2018-04-03T11:05:46.074Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>监控memcache的原理跟监控redis差不多，都是通过一个类似info的东西可以查询到memcache的状态值，然后通过脚本去获取这些值给zabbix，当发现某值不正常就发出告警。</p><p>查询当年memcache状态的命令是<code>echo stats |nc 127.0.0.1  11211</code>，如果没有<code>nc</code>命令，那就<code>yum install -y nc</code>。</p><p>获得到的结果是这个样子的：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">[root@lconline-ec2 ~]# echo stats |nc 127.0.0.1  11211</span><br><span class="line">STAT pid <span class="number">1859</span>        memcache服务进程ID</span><br><span class="line">STAT uptime <span class="number">491093</span>    服务器已运行秒数</span><br><span class="line">STAT time <span class="number">1522740969</span>    服务器当前Unix时间戳</span><br><span class="line">STAT version <span class="number">1.4</span><span class="number">.25</span>        memcache版本</span><br><span class="line">STAT libevent <span class="number">1.4</span><span class="number">.13</span>-stable</span><br><span class="line">STAT pointer_size <span class="number">64</span>        操作系统指针大小</span><br><span class="line">STAT rusage_user <span class="number">14.321822</span>        进程累计用户时间</span><br><span class="line">STAT rusage_system <span class="number">14.095857</span>        进程累计系统时间</span><br><span class="line">STAT curr_connections <span class="number">5</span>        当前连接数量</span><br><span class="line">STAT total_connections <span class="number">51010</span>    Memcached运行以来连接总数</span><br><span class="line">STAT connection_structures <span class="number">8</span>    Memcached分配的连接结构数量</span><br><span class="line">STAT reserved_fds <span class="number">20</span></span><br><span class="line">STAT cmd_get <span class="number">0</span>        get命令请求次数</span><br><span class="line">STAT cmd_set <span class="number">0</span>        set命令请求次数</span><br><span class="line">STAT cmd_flush <span class="number">0</span>    flush命令请求次数</span><br><span class="line">STAT cmd_touch <span class="number">0</span>    touch命令请求次数</span><br><span class="line">STAT get_hits <span class="number">0</span>        get命令命中次数</span><br><span class="line">STAT get_misses <span class="number">0</span>    get命令未命中次数</span><br><span class="line">STAT delete_misses <span class="number">0</span>    <span class="keyword">delete</span>命令未命中次数</span><br><span class="line">STAT delete_hits <span class="number">0</span>        <span class="keyword">delete</span>命令命中次数</span><br><span class="line">STAT incr_misses <span class="number">0</span>        incr命令未命中次数</span><br><span class="line">STAT incr_hits <span class="number">0</span>        incr命令命中次数</span><br><span class="line">STAT decr_misses <span class="number">0</span>        decr命令未命中次数</span><br><span class="line">STAT decr_hits <span class="number">0</span>        decr命令命中次数</span><br><span class="line">STAT cas_misses <span class="number">0</span>        cas命令未命中次数</span><br><span class="line">STAT cas_hits <span class="number">0</span>            cas命令命中次数</span><br><span class="line">STAT cas_badval <span class="number">0</span>        使用擦拭次数</span><br><span class="line">STAT touch_hits <span class="number">0</span></span><br><span class="line">STAT touch_misses <span class="number">0</span></span><br><span class="line">STAT auth_cmds <span class="number">0</span>        认证命令处理的次数    </span><br><span class="line">STAT auth_errors <span class="number">0</span>        认证失败数目</span><br><span class="line">STAT bytes_read <span class="number">357040</span>        读取总字节数    </span><br><span class="line">STAT bytes_written <span class="number">60197691</span>        发送总字节数</span><br><span class="line">STAT limit_maxbytes <span class="number">1073741824</span>        分配的内存总大小（字节）</span><br><span class="line">STAT accepting_conns <span class="number">1</span>        服务器是否达到过最大连接（<span class="number">0</span>/<span class="number">1</span>）</span><br><span class="line">STAT listen_disabled_num <span class="number">0</span>        失效的监听数</span><br><span class="line">STAT time_in_listen_disabled_us <span class="number">0</span></span><br><span class="line">STAT threads <span class="number">4</span>        当前线程数</span><br><span class="line">STAT conn_yields <span class="number">0</span>        连接操作主动放弃数目</span><br><span class="line">STAT hash_power_level <span class="number">16</span></span><br><span class="line">STAT hash_bytes <span class="number">524288</span>        当前存储占用的字节数</span><br><span class="line">STAT hash_is_expanding <span class="number">0</span></span><br><span class="line">STAT malloc_fails <span class="number">0</span>    </span><br><span class="line">STAT bytes <span class="number">0</span>        当前存储占用的字节数</span><br><span class="line">STAT curr_items <span class="number">0</span>        当前存储的数据总数</span><br><span class="line">STAT total_items <span class="number">0</span>        启动以来存储的数据总数</span><br><span class="line">STAT expired_unfetched <span class="number">0</span>    </span><br><span class="line">STAT evicted_unfetched <span class="number">0</span></span><br><span class="line">STAT evictions <span class="number">0</span>        LRU释放的对象数目</span><br><span class="line">STAT reclaimed <span class="number">0</span>        已过期的数据条目来存储新数据的数目</span><br><span class="line">STAT crawler_reclaimed <span class="number">0</span></span><br><span class="line">STAT crawler_items_checked <span class="number">0</span></span><br><span class="line">STAT lrutail_reflocked <span class="number">0</span>    </span><br><span class="line">END</span><br></pre></td></tr></table></figure></p><p>修改<code>zabbix_agentd.conf</code>，添加一个新的自定义项：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UserParameter=memcached.stat[*],(echo stats; sleep <span class="number">1</span>) | telnet <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">11211</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span> | awk <span class="string">'/STAT $1 / &#123;print $NF&#125;'</span></span><br></pre></td></tr></table></figure></p><p>然后重启<code>zabbix-agent</code>，模板就用github里的就好，看到的效果如下：<br><img src="/images/check-memcached.png" alt="paradin"></p>]]></content>
    
    <summary type="html">
    
      上帝抛弃了吃不饱饭的人民
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="zabbix" scheme="http://yoursite.com/tags/zabbix/"/>
    
      <category term="memcached" scheme="http://yoursite.com/tags/memcached/"/>
    
  </entry>
  
  <entry>
    <title>使用zabbix去监控网站和tcp连接</title>
    <link href="http://yoursite.com/2018/04/02/%E4%BD%BF%E7%94%A8zabbix%E5%8E%BB%E7%9B%91%E6%8E%A7%E7%BD%91%E7%AB%99/"/>
    <id>http://yoursite.com/2018/04/02/使用zabbix去监控网站/</id>
    <published>2018-04-02T01:42:45.000Z</published>
    <updated>2018-04-03T11:58:22.848Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="网页状态码监控">网页状态码监控</span></h2><p>在zabbix的web界面，<code>配置</code>–<code>主机</code>–选择一个有外网权限的服务器，比如选择zabbix server–<code>Web检测</code>，如图：<br><img src="/images/checkweb1.png" alt="paradin"></p><p>然后点击右上角的<code>创建Web场景</code>，然后依次填入<code>名称</code>，<code>间隔</code>，<code>客户端</code>等等，如图：<br><img src="/images/checkweb2.png" alt="paradin"></p><p>然后编辑<code>步骤</code>，先<code>添加</code>，填入对应的url，然后写上200状态码，意思就是返回200是OK的。<br><img src="/images/checkweb4.png" alt="paradin"><br>保存即可，如果还有http认证，那么就继续填写认证。</p><p>至此，一个简单的监控官网状态码的配置过程就结束了，剩下就是增添一下触发器，如下：<br><img src="/images/checkweb3.png" alt="paradin"></p><h2><span id="tcp连接监控">tcp连接监控</span></h2><p>首先在<code>zabbix-agentd.conf</code>里添加一个新的自定义监控项：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UserParameter=tcp.status[*],netstat -a | awk <span class="string">'/^tcp/ &#123;++y[$NF]&#125; END &#123;for(i in y) print i,y[i]&#125;'</span> |  grep $<span class="number">1</span> | awk <span class="string">'&#123;print $NF&#125;'</span></span><br></pre></td></tr></table></figure></p><p>然后<code>service zabbix-agent restart</code>重启客户端，模板就是<a href="https://gitee.com/careyjike_173/zabbix/tree/master/template" target="_blank" rel="noopener">https://gitee.com/careyjike_173/zabbix/tree/master/template</a> 里的<code>zbx_tcp_status_templates.xml</code>，直接导入即可。如图：<br><img src="/images/checkweb5.png" alt="paradin"></p><p>然后自己配置一下<code>time_wait</code>/<code>close_wait</code>的告警阈值。</p><p><img src="/images/裤子卡世界波.gif" alt="akb48" title="裤子卡中圈世界波"></p>]]></content>
    
    <summary type="html">
    
      我可算是那个zabbix监控模板扒个精光...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="zabbix" scheme="http://yoursite.com/tags/zabbix/"/>
    
      <category term="web监控" scheme="http://yoursite.com/tags/web%E7%9B%91%E6%8E%A7/"/>
    
      <category term="tcp连接" scheme="http://yoursite.com/tags/tcp%E8%BF%9E%E6%8E%A5/"/>
    
  </entry>
  
  <entry>
    <title>使用zabbix去监控php-fpm</title>
    <link href="http://yoursite.com/2018/04/02/%E4%BD%BF%E7%94%A8zabbix%E5%8E%BB%E7%9B%91%E6%8E%A7php-fpm/"/>
    <id>http://yoursite.com/2018/04/02/使用zabbix去监控php-fpm/</id>
    <published>2018-04-02T01:42:36.000Z</published>
    <updated>2018-04-03T11:58:46.168Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="开启状态统计">开启状态统计</span></h2><p>nginx有一个status来获取nginx处理信息的总览情况，php-fpm也有一个状态统计。要打开这个状态统计，需要先打开php-fpm.conf，将<code>pm.status_path = /status</code>前面的注释去掉。</p><p>然后跑到nginx里，在<code>nginx.conf</code>里添加一个location：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   location ~ ^<span class="regexp">/(status|ping) &#123;</span></span><br><span class="line"><span class="regexp">       fastcgi_pass 127.0.0.1:9000;</span></span><br><span class="line"><span class="regexp">       include fastcgi.conf;</span></span><br><span class="line"><span class="regexp">       access_log off;</span></span><br><span class="line"><span class="regexp">       allow 127.0.0.1;</span></span><br><span class="line"><span class="regexp">       deny all;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p><p>然后重启一下php-fpm和nginx，在命令行里输入<code>curl -s http://127.0.0.1:80/status</code>，就会看到php的状态统计，如下图：<br><img src="/images/checkphp.png" alt="paradin"></p><h2><span id="php-fpm-status详解">php-fpm status详解</span></h2><p><code>pool</code> - fpm池子名称，大多数为www<br><code>process manager</code> – 进程管理方式,值：static, dynamic<br><code>start time</code>– 启动日期,如果reload了php-fpm，时间会更新<br><code>start since</code> – 运行时长<br><code>accepted conn</code> – 当前池子接受的请求数<br><code>listen queue</code> – 请求等待队列，如果这个值不为0，那么要增加FPM的进程数量<br><code>max listen queue</code> – 请求等待队列最高的数量<br><code>listen queue len</code> – socket等待队列长度<br><code>idle processes</code> – 空闲进程数量<br><code>active processes</code> – 活跃进程数量<br><code>total processes</code> – 总进程数量<br><code>max active processes</code> – 最大的活跃进程数量（FPM启动开始算）<br><code>max children reached</code> - 大道进程最大数量限制的次数，如果这个数量不为0，那说明你的最大进程数量太小了，请改大一点。<br><code>slow requests</code> – 启用了php-fpm slow-log，缓慢请求的数量 </p><h2><span id="配置监控">配置监控</span></h2><p>跑到<code>zabbix-agentd.conf</code>里添加一个自定义监控项，如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UserParameter=php-fpm.status[*],/usr/bin/curl -s <span class="string">"http://127.0.0.1/php-fpm_status?xml"</span> | grep <span class="string">"&lt;$1&gt;"</span> | awk -F<span class="string">'&gt;|&lt;'</span> <span class="string">'&#123; print $$3&#125;'</span></span><br></pre></td></tr></table></figure></p><p>然后重启一下<code>zabbix-agent</code>，模板就是<a href="https://gitee.com/careyjike_173/zabbix/tree/master/template" target="_blank" rel="noopener">https://gitee.com/careyjike_173/zabbix/tree/master/template</a> 里的<code>zbx_php-fpm_templates.xml</code>，直接导入即可！</p><p>效果如下图：<br><img src="/images/checkphp2.png" alt="paradin"></p><p><img src="/images/百年美洲杯对委内瑞拉助攻伊瓜因.gif" alt="paradin" title="梅西百年美洲杯对委内瑞拉助攻伊瓜因"></p>]]></content>
    
    <summary type="html">
    
      php-fpm得多一点了解，不然即使有报警了也不知道怎么办
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="zabbix" scheme="http://yoursite.com/tags/zabbix/"/>
    
      <category term="php-fpm" scheme="http://yoursite.com/tags/php-fpm/"/>
    
  </entry>
  
  <entry>
    <title>使用zabbix去监控nginx</title>
    <link href="http://yoursite.com/2018/04/02/%E4%BD%BF%E7%94%A8zabbix%E5%8E%BB%E7%9B%91%E6%8E%A7nginx/"/>
    <id>http://yoursite.com/2018/04/02/使用zabbix去监控nginx/</id>
    <published>2018-04-02T01:42:24.000Z</published>
    <updated>2018-04-03T11:58:00.111Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="准备工作">准备工作</span></h2><p>zabbix监控nginx，首先要确认nginx里是否有<code>http_stub_status_module</code>这个模块，一般来说，这个模块是自动安装的，<code>nginx -V</code>如下图：<br><img src="/images/checknginx1.png" alt="paradin"></p><p>如果你的nginx没有这个模块，请去看<a href="https://rorschachchan.github.io/2018/01/03/Nginx动态编译新的模块/" target="_blank" rel="noopener">https://rorschachchan.github.io/2018/01/03/Nginx动态编译新的模块/</a> 。</p><p>然后在<code>nginx.conf</code>里添加一段话：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> location = <span class="regexp">/nginx-status  &#123;</span></span><br><span class="line"><span class="regexp">    stub_status   on;</span></span><br><span class="line"><span class="regexp">    access_log   off;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p><p><code>nginx -s reload</code>一下，然后在命令行输入<code>curl http://127.0.0.1/nginx-status</code>，就会看到如下的界面：<br><img src="/images/checknginx2.png" alt="paradin"></p><p>这样就可以通过<code>http_stub_status_module</code>检查nginx情况了！</p><h2><span id="nginx-status详解">nginx status详解</span></h2><p>以上图的<code>nginx status</code>来做例子说明一下各个数字的意思：<br><code>active connections</code> – 活跃的连接数量<br><code>accepts</code> — 总共处理了3832000个连接<br><code>handled</code> — 成功创建3832000次握手<br><code>requests</code> —  总共处理了3295877个请求<br><code>reading</code> — 读取客户端的连接数<br><code>writing</code> — 响应数据到客户端的数量<br><code>waiting</code> — 开启<code>keep-alive</code>的情况下,这个值等于<code>active – (reading+writing)</code>, 意思就是 Nginx 已经处理完正在等候下一次请求指令的驻留连接</p><h2><span id="配置监控">配置监控</span></h2><p>有了模块，还需要添加一个脚本，然后就可以获取上面的数值了，脚本如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"># Method of use</span><br><span class="line"></span><br><span class="line">HOST=<span class="string">"127.0.0.1"</span></span><br><span class="line">PORT="80"#这个根据实际情况填写</span><br><span class="line">URL=<span class="string">"http://$&#123;HOST&#125;:$&#123;PORT&#125;/nginx-status"</span></span><br><span class="line"></span><br><span class="line">active() &#123;</span><br><span class="line">       curl <span class="string">"$&#123;URL&#125;"</span> <span class="number">2</span>&gt;<span class="regexp">/dev/</span><span class="literal">null</span> | grep  <span class="string">"Active"</span> | awk <span class="string">'&#123;print $NF&#125;'</span></span><br><span class="line">&#125;</span><br><span class="line">reading() &#123;</span><br><span class="line">       curl <span class="string">"$&#123;URL&#125;"</span> <span class="number">2</span>&gt;<span class="regexp">/dev/</span><span class="literal">null</span> | grep <span class="string">"Reading"</span> | awk <span class="string">'&#123;print $2&#125;'</span></span><br><span class="line">&#125;</span><br><span class="line">writing() &#123;</span><br><span class="line">       curl <span class="string">"$&#123;URL&#125;"</span> <span class="number">2</span>&gt;<span class="regexp">/dev/</span><span class="literal">null</span> | grep <span class="string">"Writing"</span> | awk <span class="string">'&#123;print $4&#125;'</span></span><br><span class="line">&#125;</span><br><span class="line">waiting() &#123;</span><br><span class="line">       curl <span class="string">"$&#123;URL&#125;"</span> <span class="number">2</span>&gt;<span class="regexp">/dev/</span><span class="literal">null</span> | grep <span class="string">"Waiting"</span> | awk <span class="string">'&#123;print $NF&#125;'</span></span><br><span class="line">&#125;</span><br><span class="line">accepts() &#123;</span><br><span class="line">       curl <span class="string">"$&#123;URL&#125;"</span> <span class="number">2</span>&gt;<span class="regexp">/dev/</span><span class="literal">null</span> | awk NR==<span class="number">3</span> | awk <span class="string">'&#123;print $1&#125;'</span></span><br><span class="line">&#125;</span><br><span class="line">handled() &#123;</span><br><span class="line">       curl <span class="string">"$&#123;URL&#125;"</span> <span class="number">2</span>&gt;<span class="regexp">/dev/</span><span class="literal">null</span> | awk NR==<span class="number">3</span> | awk <span class="string">'&#123;print $2&#125;'</span></span><br><span class="line">&#125;</span><br><span class="line">requests() &#123;</span><br><span class="line">       curl <span class="string">"$&#123;URL&#125;"</span> <span class="number">2</span>&gt;<span class="regexp">/dev/</span><span class="literal">null</span> | awk NR==<span class="number">3</span> | awk <span class="string">'&#123;print $NF&#125;'</span></span><br><span class="line">&#125;</span><br><span class="line">ping() &#123;</span><br><span class="line">       ps -ef | grep nginx | grep -v grep -c</span><br><span class="line">&#125;</span><br><span class="line">$<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>然后再去<code>zabbix_agentd.conf</code>里添加一句话:<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UserParameter=nginx.status[*],/usr/local/zabbix/script/nginx_status.sh $<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>然后<code>service zabbix-agent restart</code>，自定义项就搞定了。</p><p>如果要导入模板，<a href="https://gitee.com/careyjike_173/zabbix" target="_blank" rel="noopener">https://gitee.com/careyjike_173/zabbix</a> 这个朋友的模板已经非常全面了，根据实际情况修改之后再导入他的xml就好，感谢前人付出！</p><p><img src="/images/埃里克森落叶球.gif" alt="paradin" title="埃尔克森远射破蓝军"></p>]]></content>
    
    <summary type="html">
    
      这一周又要把zabbix重新搭建并且搞起来了！
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
      <category term="zabbix" scheme="http://yoursite.com/tags/zabbix/"/>
    
  </entry>
  
  <entry>
    <title>金山云api调用的两个例子</title>
    <link href="http://yoursite.com/2018/03/29/%E9%87%91%E5%B1%B1%E4%BA%91api%E8%B0%83%E7%94%A8%E7%9A%84%E4%B8%A4%E4%B8%AA%E4%BE%8B%E5%AD%90/"/>
    <id>http://yoursite.com/2018/03/29/金山云api调用的两个例子/</id>
    <published>2018-03-29T14:55:09.000Z</published>
    <updated>2018-03-29T15:26:45.306Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>今天另外一个运维要看一下金山云API返回的格式，于是就临时写了两个demo，也顺便记录下来，说不定以后开发脚本的时候可能用的着。</p><h2><span id="查询数据库的脚本">查询数据库的脚本</span></h2><p>需要先获取<code>https://github.com/kscdb/krds_openapi_sdk.git</code>，然后执行<code>python setup.py install</code>安装所用的金山库。</p><p>这个脚本是查询某个数据库的具体情况：<br><img src="/images/ksapi4.png" alt="paradin"></p><p>脚本如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line"># -*- encoding:utf-8 -*-</span><br><span class="line"><span class="keyword">from</span> kscore.session <span class="keyword">import</span> get_session</span><br><span class="line"><span class="keyword">from</span> krds_client <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">#密钥</span><br><span class="line">ACCESS_KEY_ID = <span class="string">"这里填写ak"</span></span><br><span class="line">SECRET_ACCESS_KEY = <span class="string">"这里填写sk"</span></span><br><span class="line"></span><br><span class="line">#连接</span><br><span class="line">s = get_session()</span><br><span class="line">krds_client = KRDSClient(ACCESS_KEY_ID, SECRET_ACCESS_KEY, <span class="string">'地域名'</span>)</span><br><span class="line">r = krds_client.DescribeDBInstances(DBInstanceIdentifier='5c664b16-fbfe-4373-8a00-67c9476e7386',DBInstanceType='HA')#DBInstanceIdentifier后面是实例ID</span><br><span class="line">print r</span><br></pre></td></tr></table></figure></p><p>执行脚本之后，可以看到返回的结果包括数据库里很多的资料，如图：<br><img src="/images/ksapi1.png" alt="paradin" title="执行效果"></p><p>如果不加参数的话，就是返回账号内所有的数据库情况。</p><h2><span id="查询服务器的脚本">查询服务器的脚本</span></h2><p>需要先获取<code>https://github.com/KscSDK/ksc-sdk-python.git</code>，然后执行<code>python setup.py install</code>安装所用的金山库。</p><p>这个脚本是查询下面这个服务器的情况：<br><img src="/images/ksapi3.png" alt="paradin"></p><p>脚本如下：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line"># -*- encoding:utf-8 -*-</span><br><span class="line"><span class="keyword">from</span> kscore.session <span class="keyword">import</span> get_session</span><br><span class="line"></span><br><span class="line">#密钥</span><br><span class="line">ACCESS_KEY_ID = <span class="string">"这里填写ak"</span></span><br><span class="line">SECRET_ACCESS_KEY = <span class="string">"这里填写sk"</span></span><br><span class="line"></span><br><span class="line">#连接</span><br><span class="line">s = get_session()</span><br><span class="line">client = s.create_client(<span class="string">"kec"</span>, <span class="string">"地域名"</span>, use_ssl=True,ks_access_key_id=ACCESS_KEY_ID, ks_secret_access_key=SECRET_ACCESS_KEY)</span><br><span class="line">print client.describe_instances(Search=['js-online-hlsproxy-20'])#Search后面接实例名</span><br></pre></td></tr></table></figure></p><p>执行脚本之后，可以看到返回的结果包括数据库里很多的资料，如图：<br><img src="/images/ksapi2.png" alt="paradin" title="执行效果"></p><p>如果不加参数的话，就是返回账号内所有的服务器情况。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://github.com/KscSDK/ksc-sdk-python" target="_blank" rel="noopener">https://github.com/KscSDK/ksc-sdk-python</a><br><a href="https://github.com/kscdb/krds_openapi_sdk" target="_blank" rel="noopener">https://github.com/kscdb/krds_openapi_sdk</a></p>]]></content>
    
    <summary type="html">
    
      留下两个例子，日后说不定用得着
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="金山云" scheme="http://yoursite.com/tags/%E9%87%91%E5%B1%B1%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>使用pandas来做html表格</title>
    <link href="http://yoursite.com/2018/03/27/%E4%BD%BF%E7%94%A8pandas%E6%9D%A5%E5%81%9Ahtml%E8%A1%A8%E6%A0%BC/"/>
    <id>http://yoursite.com/2018/03/27/使用pandas来做html表格/</id>
    <published>2018-03-27T15:31:28.000Z</published>
    <updated>2018-03-27T15:56:17.698Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="前言">前言</span></h2><p>最近电子商城慢sql问题引了小BOSS的重视，于是就打算给开发们搞一个表格，在表格里可以看到前一天阿里云数据库的慢sql。这一次我不打算用html邮件了，因为慢sql数量不固定，今天可能三个，明天可能五个，后天抽风可能就一百个。而html邮件的格式是要事先写死的，于是我就用pandas来做这个表格，直接生成一个html文件，通过访问浏览器去让开发看慢sql。</p><h2><span id="慢日志脚本">慢日志脚本</span></h2><p>我要承认，阿里云自带的api在线调试工具真是一个好东西，有了它，脚本demo可以直接生成，地址是：<a href="https://api.aliyun.com/?spm=a2c4g.750001.952925.6.1QrDYe" target="_blank" rel="noopener">https://api.aliyun.com/?spm=a2c4g.750001.952925.6.1QrDYe</a> ，于是乎，阿里云获取慢日志脚本<code>test.py</code>如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line">#coding=utf-8</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore <span class="keyword">import</span> client</span><br><span class="line"><span class="keyword">from</span> aliyunsdkrds.request.v20140815 <span class="keyword">import</span> DescribeSlowLogRecordsRequest</span><br><span class="line"></span><br><span class="line">clt = client.AcsClient(<span class="string">'这里是ak'</span>,<span class="string">'这里是sk'</span>,<span class="string">'这里是地域'</span>)</span><br><span class="line"></span><br><span class="line"># 设置参数</span><br><span class="line">request = DescribeSlowLogRecordsRequest.DescribeSlowLogRecordsRequest()</span><br><span class="line">request.set_accept_format(<span class="string">'json'</span>)</span><br><span class="line"></span><br><span class="line">request.add_query_param(<span class="string">'DBInstanceId'</span>, <span class="string">'RDS的ID号'</span>)</span><br><span class="line">request.add_query_param('StartTime', '2018-03-26T08:00Z')#3月26日早上8点开始</span><br><span class="line">request.add_query_param('EndTime', '2018-03-27T08:00Z')#3月27日早上8点结束</span><br><span class="line">request.add_query_param(<span class="string">'DBName'</span>, <span class="string">'对应的数据库名'</span>)</span><br><span class="line">request.add_query_param('PageSize', 100)#这个值只能是30/50/100</span><br><span class="line"></span><br><span class="line"># 发起请求</span><br><span class="line">response = clt.do_action_with_exception(request)</span><br><span class="line">print response</span><br><span class="line"></span><br><span class="line">#把json格式的返回值改成dict格式</span><br><span class="line">slow_log=json.loads(response)</span><br><span class="line">num = slow_log[<span class="string">'TotalRecordCount'</span>]</span><br><span class="line">Hostaddress = []</span><br><span class="line">LockTimes = []</span><br><span class="line">ParseRowCounts = []</span><br><span class="line">QueryTimes = []</span><br><span class="line">SQLText = []</span><br><span class="line"></span><br><span class="line">#将有用的值做成list</span><br><span class="line"><span class="keyword">if</span> num &lt; <span class="number">100</span>:</span><br><span class="line">       <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,num):</span><br><span class="line">               Hostaddress.append(slow_log[<span class="string">'Items'</span>][<span class="string">'SQLSlowRecord'</span>][i][<span class="string">'HostAddress'</span>])</span><br><span class="line">               LockTimes.append(slow_log[<span class="string">'Items'</span>][<span class="string">'SQLSlowRecord'</span>][i][<span class="string">'LockTimes'</span>])</span><br><span class="line">               ParseRowCounts.append(slow_log[<span class="string">'Items'</span>][<span class="string">'SQLSlowRecord'</span>][i][<span class="string">'ParseRowCounts'</span>])</span><br><span class="line">               QueryTimes.append(slow_log[<span class="string">'Items'</span>][<span class="string">'SQLSlowRecord'</span>][i][<span class="string">'QueryTimes'</span>])</span><br><span class="line">               SQLText.append(slow_log[<span class="string">'Items'</span>][<span class="string">'SQLSlowRecord'</span>][i][<span class="string">'SQLText'</span>])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">       <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">100</span>):</span><br><span class="line">               Hostaddress.append(slow_log[<span class="string">'Items'</span>][<span class="string">'SQLSlowRecord'</span>][i][<span class="string">'HostAddress'</span>])</span><br><span class="line">               LockTimes.append(slow_log[<span class="string">'Items'</span>][<span class="string">'SQLSlowRecord'</span>][i][<span class="string">'LockTimes'</span>])</span><br><span class="line">               ParseRowCounts.append(slow_log[<span class="string">'Items'</span>][<span class="string">'SQLSlowRecord'</span>][i][<span class="string">'ParseRowCounts'</span>])</span><br><span class="line">               QueryTimes.append(slow_log[<span class="string">'Items'</span>][<span class="string">'SQLSlowRecord'</span>][i][<span class="string">'QueryTimes'</span>])</span><br><span class="line">               SQLText.append(slow_log[<span class="string">'Items'</span>][<span class="string">'SQLSlowRecord'</span>][i][<span class="string">'SQLText'</span>])</span><br></pre></td></tr></table></figure></p><p>这个<code>response</code>的格式是一个<code>json</code>，在<code>www.json.cn</code>里查看是这个样子：<br><img src="/images/pandas1.png" alt="paradin"></p><p>可以看到返回值里面<code>TotalRecordCount</code>就是总返回值，如果这个值大于<code>PageSize</code>，那么就会有第二篇，需要手动翻篇。所以我这里直接最大值就是100，一篇100已经够开发看了…</p><h2><span id="脚本如下">脚本如下</span></h2><p>在上面的脚本里可以获取到所有慢sql的<code>json</code>格式，那么就可以再写一个脚本把<code>json</code>转化成<code>html</code>格式并且生成一个<code>html</code>文件，然后在nginx里直接把这个文件展示出来。既然用到了<code>pandas</code>库，那么就要先安装<code>pandas</code>,方法如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pip install --upgrade pip</span><br><span class="line">pip install pandas</span><br><span class="line">如果有“Please upgrade numpy to &gt;= <span class="number">1.9</span><span class="number">.0</span> to use <span class="keyword">this</span> pandas version”的反应，那么执行下一句</span><br><span class="line">pip install -U numpy</span><br></pre></td></tr></table></figure></p><p>生成html的整个脚本如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line">#coding=utf-8</span><br><span class="line">from test import Hostaddress,LockTimes,ParseRowCounts,QueryTimes,SQLText#从刚写的test.py里得到那些list变量</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">def convertToHtml(result,title):</span><br><span class="line">    #将数据转换为html的table</span><br><span class="line">    #result是list[list1,list2]这样的结构</span><br><span class="line">    #title是list结构；和result一一对应。titleList[0]对应resultList[0]这样的一条数据对应html表格中的一列</span><br><span class="line">    d = &#123;&#125;</span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> title:</span><br><span class="line">        d[t]=result[index]</span><br><span class="line">        index = index+<span class="number">1</span></span><br><span class="line">    pd.set_option('max_colwidth',200)#默认的行长度是50，这里我调成了200</span><br><span class="line">    df = pd.DataFrame(d)</span><br><span class="line">    df = df[title]</span><br><span class="line">    h = df.to_html(index=False)</span><br><span class="line">    <span class="keyword">return</span> h</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    result = [Hostaddress,LockTimes,ParseRowCounts,QueryTimes,SQLText]</span><br><span class="line">    title = [u<span class="string">'HostAddress'</span>,u<span class="string">'LockTimes'</span>,u<span class="string">'ParseRowCounts'</span>,u<span class="string">'QueryTimes'</span>,u<span class="string">'SQLText'</span>]</span><br><span class="line">    #生成一个叫biaoge.html</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'/nginxhtml路径/biaoge.html'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(convertToHtml(result,title))</span><br><span class="line">        print <span class="string">"html文件已经生成！"</span></span><br></pre></td></tr></table></figure></p><h2><span id="执行效果">执行效果</span></h2><p>将这个<code>biaoge.html</code>直接生成到nginx的html文件夹里，在浏览器里打开这个html就看到效果了，如图：<br><img src="/images/pandas2.png" alt="paradin"></p>]]></content>
    
    <summary type="html">
    
      最近各种画图，都快吐了...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="pandas" scheme="http://yoursite.com/tags/pandas/"/>
    
      <category term="大数据分析" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>记录一次nginx出现了502的问题</title>
    <link href="http://yoursite.com/2018/03/26/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1nginx%E5%87%BA%E7%8E%B0%E4%BA%86502%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/03/26/记录一次nginx出现了502的问题/</id>
    <published>2018-03-26T11:01:24.000Z</published>
    <updated>2018-03-26T11:12:29.110Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="背景交待">背景交待</span></h2><p>市场运营在手机APP端推送了一个“家装节，部分商品优惠打折”消息，用户可以通过点击这个消息，在APP进入到商城界面，如果是已经登录的用户将通过免登陆直接跳转，如果是没有登录的用户会登陆到登陆界面。但是刚推送就发现，通过这个推送点击，没有正常登陆到商城界面，而是返回了502。</p><p>nginx 502的错误，一般来说就是<code>php-fpm</code>的问题，我登陆到电商服务器发现，<code>php-fpm</code>运行正常而且<code>php-fpm</code>的进程数也很正常。但是查看到mysql，发现mysql的CPU飙升，如图：<br><img src="/images/nginx5021.png" alt="paradin"></p><p>于是登陆到数据库里，使用<code>show processlist</code>一看，数据库里有大量的语句处于<code>sending data</code>状态，而且执行时间令人发指（<code>command</code>项处于<code>Sleep</code>状态的进程表示其正在等待接受查询，因此它并没有消耗任何资源，是无害的）：<br><img src="/images/nginx5022.png" alt="paradin"></p><p>先赶快通知运营先把推送的消息界面停用掉，不要让更多的用户登陆失败。然后写了一个脚本批量的kill掉这些进程，看看能不能让数据库恢复正常，过程如下。</p><p>首先先得到<code>show processlist</code>展现的所有的情况:<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p密码 -h数据库地址 -e <span class="string">"show processlist"</span> | grep -i <span class="string">'Locked'</span> &gt; locked_log.txt</span><br></pre></td></tr></table></figure></p><p>然后获得前面的进程号，并且加上kill的指令:<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#/bin/bash</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="string">`cat locked_log.txt | awk '&#123;print $1&#125;'`</span></span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">   echo <span class="string">"kill $line;"</span> &gt;&gt; kill_thread_id.sql</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><p>在登陆到数据库，然后执行上面生成的<code>kill_thread_id.sql</code>：:<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;source kill_thread_id.sql</span><br></pre></td></tr></table></figure></p><p>但是发现，kill掉一批之后，又有了新的慢sql出现，CPU依旧高居不下，于是只能跟产品经理说明情况，在征得了产品经理无奈的同意之后，重启了数据库，幸好时间没有很长，就耽误二三分钟而已。重启了之后，CPU就降下去了。赶快叫开发童鞋在线补充一个索引给用户登录的表来解决这个慢sql问题，没有了慢sql就没有了502。</p><h2><span id="补充nginx499">补充nginx499</span></h2><p>nginx如果爆错499的话，代表<code>客户端主动关闭连接</code>，原因就是后端脚本执行的时间太长了or数据库有慢mysql，调用方超出了<code>timeout</code>的时间，关闭了连接。</p><p>这个时候需要更改一下<code>nginx.conf</code>:<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">proxy_read_timeout <span class="number">10</span>s;</span><br><span class="line">proxy_send_timeout <span class="number">10</span>s;</span><br></pre></td></tr></table></figure></p><p>把上面两个值适度调大然后重启nginx即可。或者就是<code>proxy_ignore_client_abort  on;</code>，这话就是让代理服务端不要主动关闭客户端的连接。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://blog.csdn.net/zhuxineli/article/details/14455029" target="_blank" rel="noopener">https://blog.csdn.net/zhuxineli/article/details/14455029</a><br><a href="https://segmentfault.com/a/1190000012326158" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012326158</a></p>]]></content>
    
    <summary type="html">
    
      据说php可以改变数据表结构？？？
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>使用python调用redis的基本操作</title>
    <link href="http://yoursite.com/2018/03/26/%E4%BD%BF%E7%94%A8python%E8%B0%83%E7%94%A8redis%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2018/03/26/使用python调用redis的基本操作/</id>
    <published>2018-03-26T10:52:37.000Z</published>
    <updated>2018-03-27T16:05:00.036Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="前言">前言</span></h2><p>最近有一个需求，里面涉及到把<code>python</code>获取到的数值存储到<code>redis</code>里，于是就简单研究一下<code>python</code>调用<code>redis</code>的方法。</p><p><code>python</code>要调用redis的时候，需要先安装redis模块，有两个方法。第一个方法就是<code>pip install redis</code>，第二个方法就是<code>easy_install redis</code>，模块装完之后，就可以创建redis连接了。</p><p><code>redis-py</code>提供两个类<code>Redis</code>和<code>StrictRedis</code>来实现Redis的命令，<code>StrictRedis</code>用于实现大部分官方的命令，并使用官方的语法和命令（比如，<code>SET</code>命令对应与<code>StrictRedis.set</code>方法）。 <code>Redis</code>是<code>StrictRedis</code>的子类，用于向后兼容旧版本的<code>redis-py</code>。 <font color="red">官方推荐使用<code>StrictRedis</code>方法，所以我这里只说<code>StrictRedis</code></font>。</p><h2><span id="如何连接">如何连接</span></h2><p>连接的代码如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line">#这里是redis的基本情况</span><br><span class="line">&gt;&gt;&gt; host = <span class="string">'这里填写redis的host地址'</span></span><br><span class="line">&gt;&gt;&gt; port = 6379        #根据实际情况更改端口</span><br><span class="line">&gt;&gt;&gt; password = <span class="string">'redis对应的密码'</span></span><br><span class="line"></span><br><span class="line">#使用StrictRedis去连接到目标redis</span><br><span class="line">&gt;&gt;&gt; r = redis.StrictRedis(host=host, port=6379, password=password, db=0) #db为选定的数据库，db=0代表选择了0号数据库。redis默认有16个数据库，在conf里面可以配置。如果没有指定的数据库，可以不写。</span><br><span class="line">&gt;&gt;&gt; r.set(<span class="string">'age'</span>, <span class="string">'88'</span>)</span><br><span class="line">&gt;&gt;&gt; r.get(<span class="string">'age'</span>)</span><br><span class="line"><span class="string">'88'</span></span><br></pre></td></tr></table></figure></p><p>关系型数据库都有一个<code>连接池</code>的概念：对于大量redis连接来说，如果使用直接连接redis的方式的话，将会造成大量的TCP的重复连接，所以，就引入<code>连接池</code>来解决这个问题。在使用连接池连接上redis之后，可以从该连接池里面生成连接，调用完成之后，该链接将会返还给连接池，供其他连接请求调用，这样将减少大量redis连接的执行时间，那么使用<code>StrictRedis</code>的连接池的实现方式如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pool = redis.ConnectionPool(host=host, port=<span class="number">6379</span>, password=password)</span><br><span class="line">r = redis.StrictRedis(connection_pool=pool</span><br></pre></td></tr></table></figure></p><p>或者使用<code>pipeline</code>（管道），通过<code>缓冲多条命令，然后一次性执行</code>的方法减少<code>服务器-客户端</code>之间TCP数据库包，从而提高效率，方法如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">接上文</span><br><span class="line">pipe = r.pipeline()</span><br><span class="line">#插入数据</span><br><span class="line">&gt;&gt;&gt; pipe.hset(<span class="string">"hash_key"</span>,<span class="string">"leizhu900516"</span>,<span class="number">8</span>)</span><br><span class="line">Pipeline&lt;ConnectionPool&lt;Connection&lt;host=<span class="number">192.168</span><span class="number">.8</span><span class="number">.176</span>,port=<span class="number">6379</span>,db=<span class="number">0</span>&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; pipe.hset(<span class="string">"hash_key"</span>,<span class="string">"chenhuachao"</span>,<span class="number">9</span>)</span><br><span class="line">Pipeline&lt;ConnectionPool&lt;Connection&lt;host=<span class="number">192.168</span><span class="number">.8</span><span class="number">.176</span>,port=<span class="number">6379</span>,db=<span class="number">0</span>&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; pipe.hset(<span class="string">"hash_key"</span>,<span class="string">"wanger"</span>,<span class="number">10</span>)</span><br><span class="line">Pipeline&lt;ConnectionPool&lt;Connection&lt;host=<span class="number">192.168</span><span class="number">.8</span><span class="number">.176</span>,port=<span class="number">6379</span>,db=<span class="number">0</span>&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; pipe.execute()</span><br><span class="line">[<span class="number">1</span>L, <span class="number">1</span>L, <span class="number">1</span>L]</span><br></pre></td></tr></table></figure></p><p><img src="/images/redis1.png" alt="paradin" title="查看插入的结果"></p><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    #批量读取数据</span><br><span class="line">    &gt;&gt;&gt; pipe.hget(<span class="string">"hash_key"</span>,<span class="string">"leizhu900516"</span>)</span><br><span class="line">    Pipeline&lt;ConnectionPool&lt;Connection&lt;host=<span class="number">192.168</span><span class="number">.8</span><span class="number">.176</span>,port=<span class="number">6379</span>,db=<span class="number">0</span>&gt;&gt;&gt;</span><br><span class="line">    &gt;&gt;&gt; pipe.hget(<span class="string">"hash_key"</span>,<span class="string">"chenhuachao"</span>)</span><br><span class="line">    Pipeline&lt;ConnectionPool&lt;Connection&lt;host=<span class="number">192.168</span><span class="number">.8</span><span class="number">.176</span>,port=<span class="number">6379</span>,db=<span class="number">0</span>&gt;&gt;&gt;</span><br><span class="line">    &gt;&gt;&gt; pipe.hget(<span class="string">"hash_key"</span>,<span class="string">"wanger"</span>)</span><br><span class="line">    Pipeline&lt;ConnectionPool&lt;Connection&lt;host=<span class="number">192.168</span><span class="number">.8</span><span class="number">.176</span>,port=<span class="number">6379</span>,db=<span class="number">0</span>&gt;&gt;&gt;</span><br><span class="line">    &gt;&gt;&gt; result = pipe.execute()</span><br><span class="line">    &gt;&gt;&gt; print result</span><br><span class="line">    ['8', '9', '10']   #有序的列表</span><br><span class="line">    <span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span>pipeline<span class="string">`的命令可以写在一起，如`</span>p.set(<span class="string">'hello'</span>,<span class="string">'redis'</span>).sadd(<span class="string">'faz'</span>,<span class="string">'baz'</span>).incr(<span class="string">'num'</span>).execute()<span class="string">`，其实它的意思等同于是：</span></span><br><span class="line"><span class="string">    `</span><span class="string">``</span>js</span><br><span class="line">    &gt;&gt;&gt; p.set(<span class="string">'hello'</span>,<span class="string">'redis'</span>)</span><br><span class="line">    &gt;&gt;&gt; p.sadd(<span class="string">'faz'</span>,<span class="string">'baz'</span>)</span><br><span class="line">    &gt;&gt;&gt; p.incr(<span class="string">'num'</span>)</span><br><span class="line">    &gt;&gt;&gt; p.execute()</span><br><span class="line">    [True, <span class="number">1</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure></code></pre><p>利用<code>pipeline</code>取值3500条数据，大约需要900ms，如果配合线程or协程来使用，每秒返回1W数据是没有问题的，基本能满足大部分业务。</p><h2><span id="如何存储">如何存储</span></h2><p>上面已经举了一个<code>age：88</code>的例子，可见创建一个<code>string</code>类型的key并放入value是使用<code>set</code>方法，比如再多存几个名字：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; r.set(<span class="string">'name'</span>, <span class="string">'lilei'</span>)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; r.get(<span class="string">'name'</span>)</span><br><span class="line"><span class="string">'lilei'</span></span><br><span class="line">&gt;&gt;&gt; r.set(<span class="string">'name2'</span>, <span class="string">'zhaowei'</span>)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; r.set(<span class="string">'name3'</span>, <span class="string">'james'</span>)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; r.set(<span class="string">'name4'</span>, <span class="string">'yaoming'</span>)</span><br><span class="line">True</span><br><span class="line">#列出以name开头的所有key</span><br><span class="line">&gt;&gt;&gt; print r.keys(<span class="string">"name*"</span>)</span><br><span class="line">[<span class="string">'name3'</span>, <span class="string">'name4'</span>, <span class="string">'name2'</span>, <span class="string">'name'</span>]</span><br><span class="line">#列出所有key</span><br><span class="line">&gt;&gt;&gt; print r.keys()</span><br><span class="line">&gt;&gt;&gt; r.dbsize()         #当前数据库包含多少条数据       </span><br><span class="line"><span class="number">4</span>L</span><br><span class="line">&gt;&gt;&gt; r.delete(<span class="string">'name'</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line">&gt;&gt;&gt; r.save()               #执行“检查点”操作，将数据写回磁盘。保存时阻塞</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; r.get(<span class="string">'name'</span>)</span><br><span class="line">&gt;&gt;&gt; r.flushdb()        #清空r中的所有数据</span><br><span class="line">True</span><br></pre></td></tr></table></figure></p><p>还有其他类型的存储方法，简单举例子如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#创建一个hash</span><br><span class="line">r.hset(<span class="string">'abc:def'</span>, <span class="string">'name'</span>, <span class="string">"abcde"</span>)</span><br><span class="line">#获取一个hash的所有值</span><br><span class="line">print r.hgetall(<span class="string">'abc:def'</span>)</span><br><span class="line">#获取一个hash的所有key    </span><br><span class="line">print r.hkeys(<span class="string">'abc:def'</span>) </span><br><span class="line">#创建list</span><br><span class="line">r.sadd(<span class="string">'abcd:ef'</span>,<span class="string">'nihao'</span>)</span><br><span class="line">r.sadd(<span class="string">'abcd:ef'</span>,<span class="string">'hello'</span>)</span><br><span class="line">r.sadd(<span class="string">'xxxx'</span>,<span class="string">'nihao'</span>)</span><br><span class="line">r.sadd(<span class="string">'xxxx'</span>,<span class="string">'good'</span>)</span><br><span class="line">#打印出该key中的值 list</span><br><span class="line">print r.smembers(<span class="string">'abcd:ef'</span>)</span><br><span class="line">#查询两个list中相同的值</span><br><span class="line">print r.sinter(<span class="string">'abcd:ef'</span>, <span class="string">'xxxx'</span>)</span><br><span class="line">#给两个list取并集</span><br><span class="line">print r.sunion(<span class="string">'abcd:ef'</span>, <span class="string">'xxxx'</span>)</span><br></pre></td></tr></table></figure></p><p><code>setnx</code>是<code>SET if Not eXists</code>的缩写，也就是只有不存在的时候才设置，可以利用它来实现锁的效果。python要使用它也是<code>r.setnx(key,value)</code>，当发现没有这个key的时候，就会插入这个新的key以及对应的value，如果发现有了个这个key了，那这条就等于没加。</p><h2><span id="如何删除">如何删除</span></h2><p><code>py-redis</code>中有个<code>delete</code>接口，既可以删除单个key，也可以全删除key，如果要删除几个key，用法是:<code>r.delete(&#39;age&#39;)</code>、<code>r.delete(&#39;sex&#39;, &#39;age&#39;)</code>，如果要全删除，那就是<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">keys = r.keys()</span><br><span class="line">r.delete(*keys)</span><br></pre></td></tr></table></figure></p><p>执行之后的效果等于<code>flushall</code>。</p><p>redis里默认情况下是不支持通配符的，那么要批量删除key怎么做呢？答案就是搭配<code>xargs</code>，比如要删除掉所有<code>2018-03-</code>开头的key：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -hredis地址 -a密码 keys <span class="string">"2018-03-*"</span>|xargs redis-cli -hredis地址 -a密码 del</span><br></pre></td></tr></table></figure></p><h2><span id="python将两个list元素一一对应转换为dict">python将两个list元素一一对应转换为dict</span></h2><p>使用python的<code>zip</code>函数和强大的集合操作可以方便的将两个list元素一一对应转换为dict，如下示例代码：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">'n1'</span>,<span class="string">'n2'</span>,<span class="string">'n3'</span>]</span><br><span class="line">values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">nvs = zip(names,values)</span><br><span class="line">nvDict = dict( (name,value) <span class="keyword">for</span> name,value <span class="keyword">in</span> nvs)</span><br></pre></td></tr></table></figure></p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://github.com/andymccurdy/redis-py" target="_blank" rel="noopener">https://github.com/andymccurdy/redis-py</a><br><a href="http://xiaorui.cc/2014/11/10/%E4%BD%BF%E7%94%A8redis-py%E7%9A%84%E4%B8%A4%E4%B8%AA%E7%B1%BBredis%E5%92%8Cstrictredis%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/" target="_blank" rel="noopener">http://xiaorui.cc/2014/11/10/%E4%BD%BF%E7%94%A8redis-py%E7%9A%84%E4%B8%A4%E4%B8%AA%E7%B1%BBredis%E5%92%8Cstrictredis%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/</a><br><a href="http://debugo.com/python-redis/" target="_blank" rel="noopener">http://debugo.com/python-redis/</a></p>]]></content>
    
    <summary type="html">
    
      把数据存到redis里，任我蹂躏...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>使用python调用echart画图</title>
    <link href="http://yoursite.com/2018/03/22/%E4%BD%BF%E7%94%A8python%E8%B0%83%E7%94%A8echart%E7%94%BB%E5%9B%BE/"/>
    <id>http://yoursite.com/2018/03/22/使用python调用echart画图/</id>
    <published>2018-03-22T15:24:32.000Z</published>
    <updated>2018-03-23T11:02:46.366Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="前言">前言</span></h2><p>之前说了如何使用阿里云的SDK获取云存储的值然后发送表格邮件，但是最近领导又发话了，说这个邮件每天一封看的有点审美疲劳，要顺应“数据可视化”的趋势，于是就要求画图，力求直观，要做到“从众多数据中突出特别数据，从特别数据中突出高价值数据”。我之前用<code>python</code>的<code>matplotlib</code>画过，这一次尝试用<code>echart</code>来做图！</p><p><code>echart</code>是不太良心的百度良心的开源作品，提供各种各样精美的作图方案，分分钟把图片做的高大上，吸引周围人的目光。不过我对前端的了解非常浅薄，但是没关系。这次使用<code>pyechart</code>插件！这个插件可以让<code>python</code>直接调用<code>echart</code>接口，选择需要的图形之后，直接往里查数据就好，简单粗暴见效快，而且支持3D，可以说是居家旅行常备物品。可以说，有了它，作图能力顶呱呱。感谢开发者大神们的辛苦工作！</p><h2><span id="作图">作图</span></h2><p>首先先需要安装<code>pyecharts</code>插件，命令是<code>pip install pyecharts</code>。</p><p>然后我们就可以写一个简单的案例，如下：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line">#coding=utf-8</span><br><span class="line">from pyecharts import Bar    #导入第三方库</span><br><span class="line"></span><br><span class="line">#attr = ["&#123;&#125;day".format(i) for i in range(1, 8)]    #这样的话X坐标就是1day、2day、3day...</span><br><span class="line">attr = ["Mon", "Feb", "Wed", "Thu", "Fri", "Sat", "Sun"]    #这样X坐标就是星期</span><br><span class="line">v1 = [<span class="number">1.49</span>, <span class="number">2.09</span>, <span class="number">4.03</span>, <span class="number">2.23</span>, <span class="number">5.26</span>, <span class="number">7.71</span>, <span class="number">7.56</span>]        </span><br><span class="line">v2 = [<span class="number">0.3</span>, <span class="number">0.9</span>, <span class="number">0.2</span>, <span class="number">0.4</span>, <span class="number">0.7</span>, <span class="number">0.7</span>, <span class="number">0.6</span>]</span><br><span class="line">v3 = [<span class="number">18.15</span>, <span class="number">13.22</span>, <span class="number">11.28</span>, <span class="number">17.99</span>, <span class="number">18.7</span>, <span class="number">19.7</span>, <span class="number">15.6</span>]</span><br><span class="line"></span><br><span class="line">bar = Bar("乐橙云存储情况总览", "本图表展示过去一周的云存储情况")        #这里是主标题和副标题</span><br><span class="line">bar.add("录像分享文件", attr, v1, mark_line=["average"], mark_point=["max", "min"])    #每一个值的名称以及要展现平均值和最大最小值</span><br><span class="line">bar.add(<span class="string">"视频直播文件"</span>, attr, v2, mark_line=[<span class="string">"average"</span>], mark_point=[<span class="string">"max"</span>, <span class="string">"min"</span>])</span><br><span class="line">bar.add(<span class="string">"云录像、报警图片、全景图片"</span>, attr, v3, mark_line=[<span class="string">"average"</span>], mark_point=[<span class="string">"max"</span>, <span class="string">"min"</span>])    </span><br><span class="line">bar.render('/tmp/111.html')        #在/tmp文件夹里生成一个111.html文件</span><br></pre></td></tr></table></figure></p><p>如果服务器里有<code>nginx</code>，那么把这个html文件放到<code>nginx/html</code>路径里，再在浏览器里打开就会看到这样的图：<br><img src="/images/pyechart.png" alt="paradin"></p><p>而且还可以通过点击网页上“A值”、“B值”、“C值”就可以达到屏蔽相应值的效果，而且如果点击红色箭头的“数据视图”，还可以直接看到对应的数据，非常贴心非常屌，如图：<br><img src="/images/pyechart2.png" alt="paradin"></p><p>如果你觉得图片有点小，那么可以修改这个地方：<code>bar = Bar(&quot;XXX情况总览&quot;, &quot;本图表展示过去一周的ABC情况&quot;，width=1000,height=900)</code>，我这里把宽和高分别从默认值调成了1000和900。</p><p>如果想要在一个html里做多个图，比如要做三个柱状图，那么example如下：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line">#coding=utf-8</span><br><span class="line"><span class="keyword">from</span> pyecharts <span class="keyword">import</span> Bar, Grid</span><br><span class="line"></span><br><span class="line">attr = [<span class="string">"一班"</span>, <span class="string">"二班"</span>, <span class="string">"三班"</span>, <span class="string">"四班"</span>]</span><br><span class="line">v1 = [<span class="number">54</span>, <span class="number">81</span>, <span class="number">32</span>, <span class="number">32</span>] </span><br><span class="line">v2 = [<span class="number">68</span>, <span class="number">69</span>, <span class="number">27</span>, <span class="number">32</span>] </span><br><span class="line">bar = Bar(<span class="string">"赞成票"</span>,<span class="string">"本图表展示赞成票情况"</span>)</span><br><span class="line">bar.add(<span class="string">"年纪长"</span>, attr, v1, mark_point=[<span class="string">"max"</span>, <span class="string">"min"</span>])</span><br><span class="line">bar.add(<span class="string">"副年纪长"</span>, attr, v2, mark_point=[<span class="string">"max"</span>, <span class="string">"min"</span>])</span><br><span class="line"></span><br><span class="line">attr2 = [<span class="string">"一班"</span>, <span class="string">"二班"</span>, <span class="string">"三班"</span>, <span class="string">"四班"</span>]</span><br><span class="line">x1 = [<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">x2 = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>]</span><br><span class="line">bar2 = Bar("反对票","本图表展示反对票情况",title_top='bottom',title_color='#1d12eb')            #title_color是标题颜色，这个跟html的颜色取值一样</span><br><span class="line">bar2.add(<span class="string">"年纪长"</span>, attr2, x1, mark_point=[<span class="string">"max"</span>, <span class="string">"min"</span>])</span><br><span class="line">bar2.add(<span class="string">"副年纪长"</span>, attr2, x2, mark_point=[<span class="string">"max"</span>, <span class="string">"min"</span>])</span><br><span class="line"></span><br><span class="line">attr3 = [<span class="string">"一班"</span>, <span class="string">"二班"</span>, <span class="string">"三班"</span>, <span class="string">"四班"</span>]</span><br><span class="line">y1 = [<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">y2 = [<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">bar3 = Bar("弃权票","本图表展示弃权票情况",title_pos='right',title_color='#eb1212')             #title_pos是标题的位置，如果不特殊说明，会重叠</span><br><span class="line">bar3.add(<span class="string">"年纪长"</span>, attr3, y1, mark_point=[<span class="string">"max"</span>, <span class="string">"min"</span>])    </span><br><span class="line">bar3.add(<span class="string">"副年纪长"</span>, attr3, y1, mark_point=[<span class="string">"max"</span>, <span class="string">"min"</span>])</span><br><span class="line"></span><br><span class="line">grid = Grid()    </span><br><span class="line">grid.add(bar, grid_width="40%", grid_height="30%", grid_bottom="60%", grid_right="55%")        #grid_height和grid_width是每一个小图的大小</span><br><span class="line">grid.add(bar2, grid_width="40%", grid_height="30%", grid_bottom="60%", grid_left="55%")        #grid_bottom和grid_top是垂直位置</span><br><span class="line">grid.add(bar3, grid_width="40%", grid_height="30%", grid_top="60%", grid_right="55%")        #grid_right和grid_left是水平位置</span><br><span class="line">grid.render('/tmp/grid.html')    #在/tmp文件夹里生成一个grid.html文件</span><br></pre></td></tr></table></figure></p><p><img src="/images/pyechart3.png" alt="paradin"></p><p>例子中的数字都是我虚拟的，实际情况中，这些数字都应该是存储在redis这样的数据库里，然后取出来使用。</p><p>上面的两个例子仅仅是<code>pyechart</code>使用的冰山一角，如果想更多的了解，请去看一下文末<code>pyechart</code>的中文说明文档，无论是柱状图、雷达图、曲线图、3D图都有相关的使用讲解，内容特别丰富！</p><h2><span id="参考资料">参考资料</span></h2><p><a href="http://echarts.baidu.com" target="_blank" rel="noopener">http://echarts.baidu.com</a><br><a href="http://pyecharts.org/#/zh-cn/prepare" target="_blank" rel="noopener">http://pyecharts.org/#/zh-cn/prepare</a></p>]]></content>
    
    <summary type="html">
    
      有了pyechart加持，准保你的大数据图案美观简洁又大方！
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="echart" scheme="http://yoursite.com/tags/echart/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ的安装、配置与启动</title>
    <link href="http://yoursite.com/2018/03/19/RabbitMQ%E7%9A%84%E5%AE%89%E8%A3%85%E3%80%81%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%90%AF%E5%8A%A8/"/>
    <id>http://yoursite.com/2018/03/19/RabbitMQ的安装、配置与启动/</id>
    <published>2018-03-19T01:59:05.000Z</published>
    <updated>2018-03-19T03:35:49.323Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="前言">前言</span></h2><p>环境介绍：<code>Centos 7</code> + <code>RabbitMQ：3.6.12</code> + <code>Erlang：20.0</code></p><h2><span id="安装erlang">安装erlang</span></h2><p>由于RabbitMQ使用erlang语言编写的，所以要先安装erlang语言环境。但是yum源里的erlang版本太老了，于是这里选择手动安装，使用Erlang官方推荐的<code>Erlang Solutions</code>安装方法如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum install gcc gcc-c++ glibc-devel make ncurses-devel openssl-devel autoconf java-1.8.0-openjdk-devel git wget wxBase.x86_64#先把其他模块准备好</span><br><span class="line">wget https:<span class="comment">//packages.erlang-solutions.com/erlang-solutions-1.0-1.noarch.rpm</span></span><br><span class="line">rpm -Uvh erlang-solutions<span class="number">-1.0</span><span class="number">-1.</span>noarch.rpm</span><br><span class="line">rpm --<span class="keyword">import</span> https:<span class="comment">//packages.erlang-solutions.com/rpm/erlang_solutions.asc</span></span><br></pre></td></tr></table></figure></p><p>此时，查看<code>/etc/yum.repos.d/erlang_solutions.repo</code>，应该是这个样子：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[erlang-solutions]</span><br><span class="line">name=CentOS $releasever - $basearch - Erlang Solutions</span><br><span class="line">baseurl=https:<span class="comment">//packages.erlang-solutions.com/rpm/centos/$releasever/$basearch</span></span><br><span class="line">gpgcheck=<span class="number">1</span></span><br><span class="line">gpgkey=https:<span class="comment">//packages.erlang-solutions.com/rpm/erlang_solutions.asc</span></span><br><span class="line">enabled=<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>这个时候可以yum安装了：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y esl-erlang</span><br></pre></td></tr></table></figure></p><p>此时得到的erlang就是20.0版本的了，如图：<br><img src="/images/rabbitmq1.png" alt="paradin"></p><p>如果不想使用这个办法，可以使用源码安装的方式，<a href="https://packages.erlang-solutions.com/erlang/" target="_blank" rel="noopener">https://packages.erlang-solutions.com/erlang/</a> 这里面有Erlang官方的下载包，拆包解压缩然后<code>make &amp;&amp; make install</code>即可。</p><h2><span id="安装rabbitmq">安装RabbitMQ</span></h2><p>安装RabbitMQ跟其他普通软件差不多，先去官网下载目前较稳定的rpm包，然后安装，步骤如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https:<span class="comment">//dl.bintray.com/rabbitmq/all/rabbitmq-server/3.7.4/rabbitmq-server-3.7.4-1.el7.noarch.rpm</span></span><br><span class="line">yum install -y rabbitmq-server<span class="number">-3.7</span><span class="number">.4</span><span class="number">-1.</span>el7.noarch.rpm</span><br></pre></td></tr></table></figure></p><p>如果出现了<code>Transaction Check Error</code>的错误：<br><img src="/images/rabbitmq2.png" alt="paradin"></p><p>可见是要安装的包与已有的包相冲突，此时需要<code>yum list|grep erlang</code>，如图：</p><p><img src="/images/rabbitmq3.png" alt="paradin"><br>再<code>yum remove esl-erlang.x86_64</code>，然后重新执行yum install那一步即可。</p><p>如果出现<code>Requires: socat</code>的错误，如图：<br><img src="/images/rabbitmq6.png" alt="paradin"></p><p>此时需要执行如下命令即可：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y install epel-release</span><br><span class="line">yum -y install socat</span><br></pre></td></tr></table></figure></p><h2><span id="配置rabbitmq">配置RabbitMQ</span></h2><p>RabbitMQ安装完毕，先<code>chkconfig rabbitmq-server on</code>设置开机启动。然后，配置一下用户名。我这个机器的用户名不规范，需要把hostname里的中文去掉，比如改成：<code>3-dvl-hlsproxy-001</code>，那么就要在/etc/hosts里添加一句：</p><pre><code>内网IP地址 3-dvl-hlsproxy-001</code></pre><p>然后执行<code>rabbitmq-plugins enable rabbitmq_management</code>来安装WEB图形界面，然后拷贝<code>rabbitmq.config.example</code>到<code>/etc/rabbitmq/</code>里，并且改名叫<code>rabbitmq.config</code>，命令如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/share/doc/rabbitmq-server<span class="number">-3.7</span><span class="number">.4</span>/rabbitmq.config.example /etc/rabbitmq/</span><br><span class="line">cd /etc/rabbitmq/</span><br><span class="line">mv rabbitmq.config.example rabbitmq.config</span><br></pre></td></tr></table></figure></p><p>编辑<code>rabbitmq.config</code>这个文件，把<code>%%{loopback_users, []}.</code>改成<code>{loopback_users, []}</code>，保存之后，执行<code>service rabbitmq-server restart</code>来启动RabbitMQ。</p><p>如果启动之后，执行<code>rabbitmqctl status</code>不断的刷<code>Error when reading /var/lib/rabbitmq/.erlang.cookie: eacces</code>的错误的话，执行<code>chown rabbitmq:rabbitmq /var/lib/rabbitmq/.erlang.cookie</code>。</p><p>在浏览器里登录<code>外网IP:15672</code>就会看到RabbitMQ的WEB配置界面了，<br><img src="/images/rabbitmq4.png" alt="paradin"></p><p>账号和密码都是guest，输入之后就会看到如下的界面，可以在界面里看到<code>3-dvl-hlsproxy-001</code>的情况了，如图：<br><img src="/images/rabbitmq5.png" alt="paradin"></p><p>RabbitMQ 3.0以后版本的WEB端口是<code>15672</code>,服务的端口是<code>5672</code>,这俩都可以在配置文件里面更改。至此RabbitMQ的安装与配置结束了，但是这个仅仅是最简单的配置，RabbitMQ自身有一套很详细的用户管理规则以及它支持Python等很多语言的管理，这些内容以后再详细说明。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://packages.erlang-solutions.com/erlang/" target="_blank" rel="noopener">https://packages.erlang-solutions.com/erlang/</a><br><a href="https://laucyun.com/9849587ce75f31d534d52f906c94368f.html" target="_blank" rel="noopener">https://laucyun.com/9849587ce75f31d534d52f906c94368f.html</a><br><a href="https://www.rabbitmq.com/access-control.html" target="_blank" rel="noopener">https://www.rabbitmq.com/access-control.html</a></p><p><img src="/images/salahe.gif" alt="paradin" title="大四喜的萨拉赫"></p>]]></content>
    
    <summary type="html">
    
      这个MQ是给activemq当备胎的
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="消息队列" scheme="http://yoursite.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="RabbitMQ" scheme="http://yoursite.com/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>使用nginx开启http2协议</title>
    <link href="http://yoursite.com/2018/03/16/%E4%BD%BF%E7%94%A8nginx%E5%BC%80%E5%90%AFhttp2%E5%8D%8F%E8%AE%AE/"/>
    <id>http://yoursite.com/2018/03/16/使用nginx开启http2协议/</id>
    <published>2018-03-16T14:34:44.000Z</published>
    <updated>2018-03-16T16:24:29.939Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="部署过程">部署过程</span></h2><p><code>HTTP/2</code>是建立在TLS的基础上的，那么先要查看nginx的版本和openssl的版本，如果<code>nginx</code>版本在<code>1.10.0</code>以上且需要<code>openssl</code>版本在<code>1.0.2</code>以上那么就可以进行下一步了：<br><img src="/images/http2-10.png" alt="paradin"></p><p>如果版本并不符合要求，可以按照<a href="https://rorschachchan.github.io/2018/01/03/Nginx动态编译新的模块/" target="_blank" rel="noopener">https://rorschachchan.github.io/2018/01/03/Nginx动态编译新的模块/</a> 里的方法升级对应的模块版本。</p><p>先编辑https（443端口）对应的<code>conf</code>文件：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 443 ssl http2;    #这里多加一句http2</span><br><span class="line">        server_name  cuntao.lechange.com *.lechange.com;    #这里填写实际的域名，我这里以cuntao.lechange.com为例</span><br><span class="line"></span><br><span class="line">        ssl_certificate /实际路径/server-com.crt;        </span><br><span class="line">        ssl_certificate_key /实际路径/server-com.key;</span><br><span class="line"></span><br><span class="line">        ssl_session_timeout  30m;        #客户端会话缓存时间</span><br><span class="line">        ssl_protocols  TLSv1 TLSv1.1 TLSv1.2;    #允许的协议</span><br><span class="line">        ssl_ciphers  EECDH+CHACHA20:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5;    #加密算法(CloudFlare 推荐的加密套件组)</span><br><span class="line">        ssl_prefer_server_ciphers   on;        #优化 SSL 加密套件</span><br><span class="line">        ssl_session_cache builtin:1000 shared:SSL:10m;        #SSL会话缓存类型和大小</span><br><span class="line">        ssl_buffer_size 1400;        #每个MTU大小1400b</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page  <span class="number">404</span>              /<span class="number">404.</span>html;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>保存之后再编辑http（80端口）对应的<code>conf</code>文件：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen <span class="number">80</span> <span class="keyword">default</span>;</span><br><span class="line">    add_header Strict-Transport-Security max-age=<span class="number">15768000</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">301</span> https:<span class="comment">//$host$request_uri;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后使用<code>nginx -t</code>检查一下是否文件有错误，如果是OK的话，那么就<code>nginx -s reload</code>平滑重启一下nginx即可。</p><p>验证<code>HTTP/2</code>协议是否开启很简单，有两个方法：<br>1）登陆<code>https://tools.keycdn.com/http2-test</code>，将你的域名填写进去，查看一下配置成功：<br><img src="/images/http2-11.png" alt="paradin"></p><p>2)在Chrome浏览器上可以通过安装<code>HTTP/2 and SPDY indicator</code>插件来检验，网址是<a href="https://chrome.google.com/webstore/detail/http2-and-spdy-indicator/mpbpobfflnpcgagjijhmgnchggcjblin" target="_blank" rel="noopener">https://chrome.google.com/webstore/detail/http2-and-spdy-indicator/mpbpobfflnpcgagjijhmgnchggcjblin</a>  ，如果地址栏出现蓝色的闪电就是该网站开启了<code>HTTP/2</code>协议，灰色的话就是<code>HTTP/2</code>协议没开启。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://www.nginx.com/blog/nginx-1-9-5/" target="_blank" rel="noopener">https://www.nginx.com/blog/nginx-1-9-5/</a><br><a href="https://blog.fazero.me/2017/01/06/upgrate-nginx-and-use-http2/" target="_blank" rel="noopener">https://blog.fazero.me/2017/01/06/upgrate-nginx-and-use-http2/</a><br><a href="https://iyaozhen.com/nginx-http2-conf.html" target="_blank" rel="noopener">https://iyaozhen.com/nginx-http2-conf.html</a></p>]]></content>
    
    <summary type="html">
    
      普通的HTTPS网站浏览会比HTTP网站稍微慢一些，因为需要处理加密任务，而配置了HTTP/2的HTTPS，在低延时的情况下速度会比HTTP更快更稳定！
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
      <category term="http协议" scheme="http://yoursite.com/tags/http%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>关于HTTP 2.0应该知道的事</title>
    <link href="http://yoursite.com/2018/03/16/%E5%85%B3%E4%BA%8EHTTP-2%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8B/"/>
    <id>http://yoursite.com/2018/03/16/关于HTTP-2应该知道的事/</id>
    <published>2018-03-16T13:44:45.000Z</published>
    <updated>2018-03-16T16:28:45.398Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="http-20的优势">HTTP 2.0的优势</span></h2><p>相比<code>HTTP/1.x</code>，<code>HTTP/2</code>在底层传输做了很大的改动和优化：<br>1.每个服务器只用一个连接：<code>HTTP/2</code>对每个服务器只使用一个连接，而不是每个文件一个连接。这样，就省掉了多次建立连接的时间，这个时间对TLS尤其明显，因为TLS连接费时间;<br>2.加速TLS交付：<code>HTTP/2</code>只需一次耗时的TLS握手，并且通过一个连接上的多路利用实现最佳性能。<code>HTTP/2</code>还会压缩首部数据，省掉<code>HTTP/1.x</code>时代所需的一些优化工作，比如拼接文件，从而提高缓存利用率;<br>3.简化Web应用：使用<code>HTTP/2</code>可以让Web开发者省很多事，因为不用再做那些针对<code>HTTP/1.x</code>的优化工作了;<br>4.适合内容混杂的页面：<code>HTTP/2</code>特别适合混合了HTML、CSS、JavaScript、图片和有限多媒体的传统页面。浏览器可以优先安排那些重要的文件请求，让页面的关键部分先出现、快出现，而且根本不会发生“浏览器明明在等关键的CSS和JS，而服务器还在发送黄图”的尴尬局面;<br>5.更安全：通过减少TLS的性能损失，可以让更多应用使用TLS，从而让用户信息更安全。</p><h2><span id="http-20性能增强之二进制分帧">HTTP 2.0性能增强之二进制分帧</span></h2><p>HTTP的定义大家都知道，叫<code>超文本协议</code>，也就是说<code>http1.x</code>的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多。但是在<code>HTTP/2</code>里这里做了比较重大的改动—<code>二进制分帧</code>，<code>HTTP/2</code>在应用层(HTTP)和传输层(TCP or UDP)之间增加一个二进制分帧层。在这个新增的二进制分帧层里<code>HTTP/2</code>会将所有传输的信息分割为更小的消息和帧,并对它们采用二进制格式的编码 ，其中<code>HTTP1.x</code>的首部信息会被封装到<code>Headers</code>帧，而我们的<code>request body</code>则封装到<code>Data</code>帧里面。二进制与之前的文本不同，二进制只认0和1的组合。基于这种考虑<code>http2.0</code>的协议解析决定采用二进制格式，实现方便且健壮。<br><img src="/images/http2-1.png" alt="paradin" title="对比一下http1.x和http2的报文格式"></p><p><code>HTTP/2</code>的格式定义十分高效且精简。<code>length</code>定义了整个<code>frame</code>的大小，<code>type</code>定义<code>frame</code>的类型（一共10种），<code>flags</code>用<code>bit</code>位定义一些重要的参数，<code>stream id</code>用作流控制，<code>payload</code>就是<code>request</code>的正文，如下图：<br><img src="/images/http2-2.png" alt="paradin" title="二进制层是夹在回话层和应用层之间的"></p><h2><span id="http-20性能增强之首部压缩">HTTP 2.0性能增强之首部压缩</span></h2><p>虽然<code>HTTP/2</code>引入了二进制分帧的概念，但是试想如果所有的二进制帧都会带上<code>Headers</code>帧，这是多大的数据冗余传送啊。于是<code>HTTP/2</code>针对这个需求又搞出来一个东东—“首部表”。</p><p>“首部表”来跟踪和存储之前发送的<code>键-值</code>对，对于相同的数据，不再通过每次请求和响应发送；通信期间几乎不会改变的通用<code>键-值</code>对(用户代理、可接受的媒体类型等等)只需发送一次。事实上,如果请求中不包含首部(例如对同一资源的轮询请求)，那么首部开销就是零字节。此时所有首部都自动使用之前请求发送的首部。如果首部发生变化了，那么只需要发送变化了数据在<code>Headers</code>帧里面，新增或修改的首部帧会被追加到“首部表”。首部表在<code>HTTP/2</code>的连接存续期内始终存在,由客户端和服务器共同渐进地更新。</p><h2><span id="http-20性能增强之tcp请求集中">HTTP 2.0性能增强之TCP请求集中</span></h2><p>TCP的优势是很直白的：面向连接、提供可靠的数据传输服务、流量控制。那么有效地使用TCP连接的方法就是<strong>长时间连接传输大块数据</strong>。于是<code>HTTP/2</code>就尽大化的把这一特点发扬：所有<code>HTTP/2</code>通信都是在一个TCP连接上完成。前面说过，HTTP/2把HTTP协议通信的基本单位缩小为一个一个的帧，这些帧对应着逻辑流中的消息，并行地在同一个TCP连接上双向交换消息(注意这个“双向交换消息”)。举个例子，请求一个页面<code>https://www.google.com</code>，页面上所有的资源请求都是客户端与服务器上的一条TCP上请求和响应的！</p><p>这样“单链接多资源”的方式，使到至上而下的层面都得到了好处：<br>    1.可以减少服务链接压力,内存占用少了,连接吞吐量大了；<br>    2.由于TCP连接减少而使网络拥塞状况得以改观;<br>    3.慢启动时间减少,拥塞和丢包恢复速度更快。</p><p>综上所述，“资源合并减少请求”对于<code>HTTP/2</code>是无用的优化手段。</p><p>上面的文字说了要注意“双向交换消息”，那么啥是“双向交换消息”？</p><p>就是把HTTP消息分解为独立的帧,交错发送,然后在另一端重新组装。专业一点说就是“一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的id将request再归属到各自不同的服务端请求里面”。这是<code>HTTP/2</code>重要的一项增强。事实上,这个机制会在整个Web技术栈中引发一系列连锁反应, 从而带来巨大的性能提升,因为：</p><pre><code>可以并行交错地发送请求,请求之间互不影响;可以并行交错地发送响应,响应之间互不干扰;只使用一个连接即可并行发送多个请求和响应;消除不必要的延迟,从而减少页面加载的时间;</code></pre><p><img src="/images/http2-3.png" alt="paradin" title="“域名分区”这种优化手段对于HTTP2.0是无用的，因为资源都是并行交错发送，且没有限制，不需要额外的多域名并行下载"></p><h2><span id="keep-alive与http2集中tcp的区别">Keep Alive与HTTP/2集中TCP的区别</span></h2><p><code>HTTP1.1</code>的<code>keep-alive</code>是为了尽可能使用持久链接，以消除TCP握手和慢启动。但是<code>keep-alive</code>使用多了同样会给服务端带来大量的性能压力，并且对于单个文件被不断请求的服务(例如图片存放网站)，<code>keep-alive</code>可能会极大的影响性能，因为它在文件被请求之后还保持了不必要的连接很长时间。</p><p>举个例子：下载<code>a.js</code>创建一个TCP链接，就会需要TCP握手和慢启动而产生了约300ms下载延迟。当<code>a.js</code>下载完成后这时候<code>b.js</code>也要下载，如果<code>a.js</code>创建TCP链接是<code>keep-alive</code>的，<code>b.js</code>就可以复用其TCP而不需要重新TCP握手和慢启动（没有了那300ms）。</p><p>而<code>HTTP/2</code>是使用一个TCP链接的，其慢启动和握手只在第一次链接的时候产生一次，其后面链接都是持久化的。并且一个TCP下载多个资源，可以将TCP吞吐量最大化来提升性能，这方面可以参考一下TCP的拥塞预防及控制。<br><img src="/images/http2-4.png" alt="paradin"></p><p><img src="/images/http2-5.png" alt="paradin"></p><h2><span id="nginx上如何配制http2">NGINX上如何配制HTTP/2</span></h2><p>上面说了这么多HTTP/2这个好那个好，是未来的趋势blablabla，但是要实现<code>HTTP/2</code>，还是需要“客户端和服务器都开启了HTTP/2”这一个首要条件。不过现在客户端（浏览器）大多数都已经支持<code>HTTP/2</code>，那么主要就是在服务器端如何开启<code>HTTP/2</code>，nginx的配置方法请见：<a href="https://rorschachchan.github.io/2018/03/16/使用nginx开启http2协议/" target="_blank" rel="noopener">https://rorschachchan.github.io/2018/03/16/使用nginx开启http2协议/</a> 。</p><p>按照这样的操作下来，服务器就开了<code>HTTP/2</code>协议，那些支持<code>HTTP/2</code>的浏览器在请求页面的时候就会走<code>HTTP/2</code>模式，而不支持HTTP/2的浏览器会议就按照<code>HTTP/1.X</code>的方式发送请求，如图：<br><img src="/images/http2-7.png" alt="paradin"></p><p><img src="/images/http2-8.png" alt="paradin" title="如果nginx是一个代理服务器的话，就是这图的传输方式"></p><p>支持<code>HTTP/2</code>的Web Server基本都支持<code>HTTP/1.1</code>。这样，即使浏览器不支持<code>HTTP/2</code>，双方也可以协商出可用的<code>HTTP</code>版本，没有兼容性问题。<br><img src="/images/http2-6.png" alt="paradin" title="使用HTTP/2其实还是服务器说的算"></p><h2><span id="参考资料">参考资料</span></h2><p><a href="http://www.alloyteam.com/2015/03/http2-0-di-qi-miao-ri-chang/comment-page-1/#comments" target="_blank" rel="noopener">http://www.alloyteam.com/2015/03/http2-0-di-qi-miao-ri-chang/comment-page-1/#comments</a><br><a href="https://segmentfault.com/a/1190000007637735" target="_blank" rel="noopener">https://segmentfault.com/a/1190000007637735</a><br><a href="https://github.com/creeperyang/blog/issues/23" target="_blank" rel="noopener">https://github.com/creeperyang/blog/issues/23</a><br><a href="https://www.nginx.com/blog/nginx-1-9-5/" target="_blank" rel="noopener">https://www.nginx.com/blog/nginx-1-9-5/</a><br><a href="https://ye11ow.gitbooks.io/http2-explained/content/part6.html" target="_blank" rel="noopener">https://ye11ow.gitbooks.io/http2-explained/content/part6.html</a></p>]]></content>
    
    <summary type="html">
    
      如果说有一个黑科技不用开发改代码、不用额外买服务，就能直接提升网络开启速度，这是什么呢？
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="大牛之路" scheme="http://yoursite.com/tags/%E5%A4%A7%E7%89%9B%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="http协议" scheme="http://yoursite.com/tags/http%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>centos 7里安装zsh来提升shell的高逼格</title>
    <link href="http://yoursite.com/2018/03/15/centos-7%E9%87%8C%E5%AE%89%E8%A3%85zsh%E6%9D%A5%E6%8F%90%E5%8D%87shell%E7%9A%84%E9%AB%98%E9%80%BC%E6%A0%BC/"/>
    <id>http://yoursite.com/2018/03/15/centos-7里安装zsh来提升shell的高逼格/</id>
    <published>2018-03-15T13:52:13.000Z</published>
    <updated>2018-03-16T16:14:04.871Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="zsh本体的安装">zsh本体的安装</span></h2><p>先用<code>chsh -l</code>查看当前的bash情况，如下：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   [root@zabbix ~]# chsh -l</span><br><span class="line">/bin/sh</span><br><span class="line">/bin/bash</span><br><span class="line">/sbin/nologin</span><br><span class="line">/bin/dash</span><br><span class="line">/bin/tcsh</span><br><span class="line">/bin/csh</span><br><span class="line">/usr/bin/tmux</span><br><span class="line">[root@zabbix ~]#</span><br></pre></td></tr></table></figure></p><p>如果是centos的话，使用<code>yum install -y zsh</code>来安装zsh，装完了zsh然后就是装<code>oh my zsh</code>，使用<code>wget</code>方法安装：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https:<span class="comment">//github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh</span></span><br></pre></td></tr></table></figure></p><p>再使用<code>which zsh</code>查看安装的zsh在<code>/usr/bin/zsh</code>，这个时候使用<code>chsh -s /usr/bin/zsh</code>，出现了<code>Shell changed.</code>这样就切换到了zsh界面，需要logout退出连接重进。</p><p>重新连接就会发现bash界面就变了，原本是路径的地方变成了一个小图标。界面主题是可以变化的，比如我个人比较喜欢<code>af-magic</code>这个模板，于是乎就把/root/.zshrc里的<code>ZSH_THEME=&quot;robbyrussell&quot;</code>改成<code>ZSH_THEME=&quot;af-magic&quot;</code>，保存文件，再一次退出连接重新进入就能看见模板变化了。</p><p>如果在使用vim的时候发现了tab键的补全爆错_arguments:451: _vim_files: function definition file not found，如下图：<br><img src="/images/zsh2.png" alt="paradin"></p><p>这个时候需要把/root/.zcompdump改一个名字，比如叫.zcompdump-bak，然后重新ssh连接即可。</p><h2><span id="autojump插件安装">autojump插件安装</span></h2><p>autojump这个插件安装之后，zsh会自动记录你访问过的目录，通过<code>j + 目录名</code>可以直接进行目录跳转，而且目录名支持模糊匹配和自动补全，例如你访问过<code>hadoop-1.0.0</code>目录，输入<code>j hado</code>即可正确跳转。<code>j –s</code>可以看你的历史路径库，安装方法如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git:<span class="comment">//github.com/joelthelion/autojump.git</span></span><br></pre></td></tr></table></figure></p><p>然后在autojump目录里执行<code>./install.sh</code>，此时屏幕会出现如下的显示：<br><img src="/images/zshautojump.png" alt="paradin"></p><p>把上面那个<code>[[ -s /root/.autojump/etc/profile.d/autojump.sh ]] &amp;&amp; source /root/.autojump/etc/profile.d/autojump.sh autoload -U compinit &amp;&amp; compinit -u复</code>制到<code>/root/.zshrc</code>的文件里，最好复制在<code>source $ZSH/oh-my-zsh.sh</code>这句话上面，保存之后<code>source ~/.zshrc</code>即可。</p><h2><span id="zsh-syntax-highlighting插件安装">zsh-syntax-highlighting插件安装</span></h2><p>这个插件安装之后主要效果就是命令高亮，如果是错误的命令，颜色是红色，正确的命令是绿色的，安装方法如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd .oh-my-zsh/plugins</span><br><span class="line">yum install -y git  #如果已经安装了git就不用执行的</span><br><span class="line">git clone git:<span class="comment">//github.com/zsh-users/zsh-syntax-highlighting.git</span></span><br><span class="line">source /root/.oh-my-zsh/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh添加到 .zshrc 的最后面</span><br><span class="line">source ~<span class="regexp">/.zshrc</span></span><br></pre></td></tr></table></figure></p><p>效果立竿见影。</p><h2><span id="尾声">尾声</span></h2><p>至此，你现在的zsh应该具备如下几个特性：<br>1、各种补全：路径补全、命令补全，命令参数补全，插件内容补全等等。触发补全只需要按一下或两下tab键，补全项可以使用ctrl+n/p/f/b上下左右切换。比如你想杀掉java的进程，只需要输入kill java + tab键，如果只有一个java进程，zsh会自动替换为进程的pid，如果有多个则会出现选择项供你选择。ssh + 空格 + 两个tab键，zsh会列出所有访问过的主机和用户名进行补全；<br>2、即使你没有安装autojump，只要输入d，就会列出你在这个回话中访问的目录，输入前面的序号，就可以直接跳转；<br>3、可以忽略cd命令, 输入..或者…和当前目录名都可以跳转；<br>当然，除了上面几点，zsh还有很多丰富的插件可以使用，这就需要继续的探索了…</p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="noopener">https://github.com/robbyrussell/oh-my-zsh</a><br><a href="http://macshuo.com/?p=676" target="_blank" rel="noopener">http://macshuo.com/?p=676</a></p>]]></content>
    
    <summary type="html">
    
      生命在于折腾...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="运维技术" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4%E6%8A%80%E6%9C%AF/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
</feed>
