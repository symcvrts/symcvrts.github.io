<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chris Chan&#39;s BLOG</title>
  
  <subtitle>那些在阳光下挥洒青春的日子啊！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-04-02T01:42:45.206Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Chris Chan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用zabbix去监控网站</title>
    <link href="http://yoursite.com/2018/04/02/%E4%BD%BF%E7%94%A8zabbix%E5%8E%BB%E7%9B%91%E6%8E%A7%E7%BD%91%E7%AB%99/"/>
    <id>http://yoursite.com/2018/04/02/使用zabbix去监控网站/</id>
    <published>2018-04-02T01:42:45.000Z</published>
    <updated>2018-04-02T01:42:45.206Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用zabbix去监控php-fpm</title>
    <link href="http://yoursite.com/2018/04/02/%E4%BD%BF%E7%94%A8zabbix%E5%8E%BB%E7%9B%91%E6%8E%A7php-fpm/"/>
    <id>http://yoursite.com/2018/04/02/使用zabbix去监控php-fpm/</id>
    <published>2018-04-02T01:42:36.000Z</published>
    <updated>2018-04-02T03:38:54.547Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="开启状态统计">开启状态统计</span></h2><p>nginx有一个status来获取nginx处理信息的总览情况，php-fpm也有一个状态统计。要打开这个状态统计，需要先打开php-fpm.conf，将<code>pm.status_path = /status</code>前面的注释去掉。</p><p>然后跑到nginx里，在<code>nginx.conf</code>里添加一个location：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   location ~ ^<span class="regexp">/(status|ping) &#123;</span></span><br><span class="line"><span class="regexp">       fastcgi_pass 127.0.0.1:9000;</span></span><br><span class="line"><span class="regexp">       include fastcgi.conf;</span></span><br><span class="line"><span class="regexp">       access_log off;</span></span><br><span class="line"><span class="regexp">       allow 127.0.0.1;</span></span><br><span class="line"><span class="regexp">       deny all;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p><p>然后重启一下php-fpm和nginx，在命令行里输入<code>curl -s http://127.0.0.1:80/status</code>，就会看到php的状态统计，如下图：<br><img src="/images/checkphp.png" alt="paradin"></p><h2><span id="php-fpm-status详解">php-fpm status详解</span></h2><p><code>pool</code> - fpm池子名称，大多数为www<br><code>process manager</code> – 进程管理方式,值：static, dynamic<br><code>start time</code>– 启动日期,如果reload了php-fpm，时间会更新<br><code>start since</code> – 运行时长<br><code>accepted conn</code> – 当前池子接受的请求数<br><code>listen queue</code> – 请求等待队列，如果这个值不为0，那么要增加FPM的进程数量<br><code>max listen queue</code> – 请求等待队列最高的数量<br><code>listen queue len</code> – socket等待队列长度<br><code>idle processes</code> – 空闲进程数量<br><code>active processes</code> – 活跃进程数量<br><code>total processes</code> – 总进程数量<br><code>max active processes</code> – 最大的活跃进程数量（FPM启动开始算）<br><code>max children reached</code> - 大道进程最大数量限制的次数，如果这个数量不为0，那说明你的最大进程数量太小了，请改大一点。<br><code>slow requests</code> – 启用了php-fpm slow-log，缓慢请求的数量 </p><h2><span id="配置监控">配置监控</span></h2><p>跑到<code>zabbix-agentd.conf</code>里添加一个自定义监控项，如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UserParameter=php-fpm.status[*],/usr/bin/curl -s <span class="string">"http://127.0.0.1/php-fpm_status?xml"</span> | grep <span class="string">"&lt;$1&gt;"</span> | awk -F<span class="string">'&gt;|&lt;'</span> <span class="string">'&#123; print $$3&#125;'</span></span><br></pre></td></tr></table></figure></p><p>然后重启一下<code>zabbix-agent</code>，模板就是<a href="https://gitee.com/careyjike_173/zabbix/tree/master/template" target="_blank" rel="noopener">https://gitee.com/careyjike_173/zabbix/tree/master/template</a> 里的<code>zbx_php-fpm_templates.xml</code>，直接导入即可！</p><p>效果如下图：<br><img src="/images/checkphp2.png" alt="paradin"></p>]]></content>
    
    <summary type="html">
    
      php-fpm得多一点了解，不然即使有报警了也不知道怎么办
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="zabbix" scheme="http://yoursite.com/tags/zabbix/"/>
    
      <category term="php-fpm" scheme="http://yoursite.com/tags/php-fpm/"/>
    
  </entry>
  
  <entry>
    <title>使用zabbix去监控nginx</title>
    <link href="http://yoursite.com/2018/04/02/%E4%BD%BF%E7%94%A8zabbix%E5%8E%BB%E7%9B%91%E6%8E%A7nginx/"/>
    <id>http://yoursite.com/2018/04/02/使用zabbix去监控nginx/</id>
    <published>2018-04-02T01:42:24.000Z</published>
    <updated>2018-04-02T03:34:58.104Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="准备工作">准备工作</span></h2><p>zabbix监控nginx，首先要确认nginx里是否有<code>http_stub_status_module</code>这个模块，一般来说，这个模块是自动安装的，<code>nginx -V</code>如下图：<br><img src="/images/checknginx1.png" alt="paradin"></p><p>如果你的nginx没有这个模块，请去看<a href="https://rorschachchan.github.io/2018/01/03/Nginx动态编译新的模块/" target="_blank" rel="noopener">https://rorschachchan.github.io/2018/01/03/Nginx动态编译新的模块/</a> 。</p><p>然后在<code>nginx.conf</code>里添加一段话：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> location = <span class="regexp">/nginx-status  &#123;</span></span><br><span class="line"><span class="regexp">    stub_status   on;</span></span><br><span class="line"><span class="regexp">    access_log   off;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p><p><code>nginx -s reload</code>一下，然后在命令行输入<code>curl http://127.0.0.1/nginx-status</code>，就会看到如下的界面：<br><img src="/images/checknginx2.png" alt="paradin"></p><p>这样就可以通过<code>http_stub_status_module</code>检查nginx情况了！</p><h2><span id="nginx-status详解">nginx status详解</span></h2><p>以上图的<code>nginx status</code>来做例子说明一下各个数字的意思：<br><code>active connections</code> – 活跃的连接数量<br><code>accepts</code> — 总共处理了3832000个连接<br><code>handled</code> — 成功创建3832000次握手<br><code>requests</code> —  总共处理了3295877个请求<br><code>reading</code> — 读取客户端的连接数<br><code>writing</code> — 响应数据到客户端的数量<br><code>waiting</code> — 开启<code>keep-alive</code>的情况下,这个值等于<code>active – (reading+writing)</code>, 意思就是 Nginx 已经处理完正在等候下一次请求指令的驻留连接</p><h2><span id="配置监控">配置监控</span></h2><p>有了模块，还需要添加一个脚本，然后就可以获取上面的数值了，脚本如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"># Method of use</span><br><span class="line"></span><br><span class="line">HOST=<span class="string">"127.0.0.1"</span></span><br><span class="line">PORT="80"#这个根据实际情况填写</span><br><span class="line">URL=<span class="string">"http://$&#123;HOST&#125;:$&#123;PORT&#125;/nginx-status"</span></span><br><span class="line"></span><br><span class="line">active() &#123;</span><br><span class="line">       curl <span class="string">"$&#123;URL&#125;"</span> <span class="number">2</span>&gt;<span class="regexp">/dev/</span><span class="literal">null</span> | grep  <span class="string">"Active"</span> | awk <span class="string">'&#123;print $NF&#125;'</span></span><br><span class="line">&#125;</span><br><span class="line">reading() &#123;</span><br><span class="line">       curl <span class="string">"$&#123;URL&#125;"</span> <span class="number">2</span>&gt;<span class="regexp">/dev/</span><span class="literal">null</span> | grep <span class="string">"Reading"</span> | awk <span class="string">'&#123;print $2&#125;'</span></span><br><span class="line">&#125;</span><br><span class="line">writing() &#123;</span><br><span class="line">       curl <span class="string">"$&#123;URL&#125;"</span> <span class="number">2</span>&gt;<span class="regexp">/dev/</span><span class="literal">null</span> | grep <span class="string">"Writing"</span> | awk <span class="string">'&#123;print $4&#125;'</span></span><br><span class="line">&#125;</span><br><span class="line">waiting() &#123;</span><br><span class="line">       curl <span class="string">"$&#123;URL&#125;"</span> <span class="number">2</span>&gt;<span class="regexp">/dev/</span><span class="literal">null</span> | grep <span class="string">"Waiting"</span> | awk <span class="string">'&#123;print $NF&#125;'</span></span><br><span class="line">&#125;</span><br><span class="line">accepts() &#123;</span><br><span class="line">       curl <span class="string">"$&#123;URL&#125;"</span> <span class="number">2</span>&gt;<span class="regexp">/dev/</span><span class="literal">null</span> | awk NR==<span class="number">3</span> | awk <span class="string">'&#123;print $1&#125;'</span></span><br><span class="line">&#125;</span><br><span class="line">handled() &#123;</span><br><span class="line">       curl <span class="string">"$&#123;URL&#125;"</span> <span class="number">2</span>&gt;<span class="regexp">/dev/</span><span class="literal">null</span> | awk NR==<span class="number">3</span> | awk <span class="string">'&#123;print $2&#125;'</span></span><br><span class="line">&#125;</span><br><span class="line">requests() &#123;</span><br><span class="line">       curl <span class="string">"$&#123;URL&#125;"</span> <span class="number">2</span>&gt;<span class="regexp">/dev/</span><span class="literal">null</span> | awk NR==<span class="number">3</span> | awk <span class="string">'&#123;print $NF&#125;'</span></span><br><span class="line">&#125;</span><br><span class="line">ping() &#123;</span><br><span class="line">       ps -ef | grep nginx | grep -v grep -c</span><br><span class="line">&#125;</span><br><span class="line">$<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>然后再去<code>zabbix_agentd.conf</code>里添加一句话:<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UserParameter=nginx.status[*],/usr/local/zabbix/script/nginx_status.sh $<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>然后<code>service zabbix-agent restart</code>，自定义项就搞定了。</p><p>如果要导入模板，<a href="https://gitee.com/careyjike_173/zabbix" target="_blank" rel="noopener">https://gitee.com/careyjike_173/zabbix</a> 这个朋友的魔板已经非常全面了，根据实际情况修改之后再导入他的就好，感谢前人付出！</p><p><img src="/images/埃里克森落叶球.gif" alt="paradin"></p><p><img src="/images/百年美洲杯1/4决赛对委内瑞拉助攻伊瓜因.gif" alt="paradin"></p>]]></content>
    
    <summary type="html">
    
      这一周又要把zabbix重新搭建并且搞起来了！
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
      <category term="zabbix" scheme="http://yoursite.com/tags/zabbix/"/>
    
  </entry>
  
  <entry>
    <title>金山云api调用的两个例子</title>
    <link href="http://yoursite.com/2018/03/29/%E9%87%91%E5%B1%B1%E4%BA%91api%E8%B0%83%E7%94%A8%E7%9A%84%E4%B8%A4%E4%B8%AA%E4%BE%8B%E5%AD%90/"/>
    <id>http://yoursite.com/2018/03/29/金山云api调用的两个例子/</id>
    <published>2018-03-29T14:55:09.000Z</published>
    <updated>2018-03-29T15:26:45.306Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>今天另外一个运维要看一下金山云API返回的格式，于是就临时写了两个demo，也顺便记录下来，说不定以后开发脚本的时候可能用的着。</p><h2><span id="查询数据库的脚本">查询数据库的脚本</span></h2><p>需要先获取<code>https://github.com/kscdb/krds_openapi_sdk.git</code>，然后执行<code>python setup.py install</code>安装所用的金山库。</p><p>这个脚本是查询某个数据库的具体情况：<br><img src="/images/ksapi4.png" alt="paradin"></p><p>脚本如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line"># -*- encoding:utf-8 -*-</span><br><span class="line"><span class="keyword">from</span> kscore.session <span class="keyword">import</span> get_session</span><br><span class="line"><span class="keyword">from</span> krds_client <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">#密钥</span><br><span class="line">ACCESS_KEY_ID = <span class="string">"这里填写ak"</span></span><br><span class="line">SECRET_ACCESS_KEY = <span class="string">"这里填写sk"</span></span><br><span class="line"></span><br><span class="line">#连接</span><br><span class="line">s = get_session()</span><br><span class="line">krds_client = KRDSClient(ACCESS_KEY_ID, SECRET_ACCESS_KEY, <span class="string">'地域名'</span>)</span><br><span class="line">r = krds_client.DescribeDBInstances(DBInstanceIdentifier='5c664b16-fbfe-4373-8a00-67c9476e7386',DBInstanceType='HA')#DBInstanceIdentifier后面是实例ID</span><br><span class="line">print r</span><br></pre></td></tr></table></figure></p><p>执行脚本之后，可以看到返回的结果包括数据库里很多的资料，如图：<br><img src="/images/ksapi1.png" alt="paradin" title="执行效果"></p><p>如果不加参数的话，就是返回账号内所有的数据库情况。</p><h2><span id="查询服务器的脚本">查询服务器的脚本</span></h2><p>需要先获取<code>https://github.com/KscSDK/ksc-sdk-python.git</code>，然后执行<code>python setup.py install</code>安装所用的金山库。</p><p>这个脚本是查询下面这个服务器的情况：<br><img src="/images/ksapi3.png" alt="paradin"></p><p>脚本如下：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line"># -*- encoding:utf-8 -*-</span><br><span class="line"><span class="keyword">from</span> kscore.session <span class="keyword">import</span> get_session</span><br><span class="line"></span><br><span class="line">#密钥</span><br><span class="line">ACCESS_KEY_ID = <span class="string">"这里填写ak"</span></span><br><span class="line">SECRET_ACCESS_KEY = <span class="string">"这里填写sk"</span></span><br><span class="line"></span><br><span class="line">#连接</span><br><span class="line">s = get_session()</span><br><span class="line">client = s.create_client(<span class="string">"kec"</span>, <span class="string">"地域名"</span>, use_ssl=True,ks_access_key_id=ACCESS_KEY_ID, ks_secret_access_key=SECRET_ACCESS_KEY)</span><br><span class="line">print client.describe_instances(Search=['js-online-hlsproxy-20'])#Search后面接实例名</span><br></pre></td></tr></table></figure></p><p>执行脚本之后，可以看到返回的结果包括数据库里很多的资料，如图：<br><img src="/images/ksapi2.png" alt="paradin" title="执行效果"></p><p>如果不加参数的话，就是返回账号内所有的服务器情况。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://github.com/KscSDK/ksc-sdk-python" target="_blank" rel="noopener">https://github.com/KscSDK/ksc-sdk-python</a><br><a href="https://github.com/kscdb/krds_openapi_sdk" target="_blank" rel="noopener">https://github.com/kscdb/krds_openapi_sdk</a></p>]]></content>
    
    <summary type="html">
    
      留下两个例子，日后说不定用得着
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="金山云" scheme="http://yoursite.com/tags/%E9%87%91%E5%B1%B1%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>使用pandas来做html表格</title>
    <link href="http://yoursite.com/2018/03/27/%E4%BD%BF%E7%94%A8pandas%E6%9D%A5%E5%81%9Ahtml%E8%A1%A8%E6%A0%BC/"/>
    <id>http://yoursite.com/2018/03/27/使用pandas来做html表格/</id>
    <published>2018-03-27T15:31:28.000Z</published>
    <updated>2018-03-27T15:56:17.698Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="前言">前言</span></h2><p>最近电子商城慢sql问题引了小BOSS的重视，于是就打算给开发们搞一个表格，在表格里可以看到前一天阿里云数据库的慢sql。这一次我不打算用html邮件了，因为慢sql数量不固定，今天可能三个，明天可能五个，后天抽风可能就一百个。而html邮件的格式是要事先写死的，于是我就用pandas来做这个表格，直接生成一个html文件，通过访问浏览器去让开发看慢sql。</p><h2><span id="慢日志脚本">慢日志脚本</span></h2><p>我要承认，阿里云自带的api在线调试工具真是一个好东西，有了它，脚本demo可以直接生成，地址是：<a href="https://api.aliyun.com/?spm=a2c4g.750001.952925.6.1QrDYe" target="_blank" rel="noopener">https://api.aliyun.com/?spm=a2c4g.750001.952925.6.1QrDYe</a> ，于是乎，阿里云获取慢日志脚本<code>test.py</code>如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line">#coding=utf-8</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore <span class="keyword">import</span> client</span><br><span class="line"><span class="keyword">from</span> aliyunsdkrds.request.v20140815 <span class="keyword">import</span> DescribeSlowLogRecordsRequest</span><br><span class="line"></span><br><span class="line">clt = client.AcsClient(<span class="string">'这里是ak'</span>,<span class="string">'这里是sk'</span>,<span class="string">'这里是地域'</span>)</span><br><span class="line"></span><br><span class="line"># 设置参数</span><br><span class="line">request = DescribeSlowLogRecordsRequest.DescribeSlowLogRecordsRequest()</span><br><span class="line">request.set_accept_format(<span class="string">'json'</span>)</span><br><span class="line"></span><br><span class="line">request.add_query_param(<span class="string">'DBInstanceId'</span>, <span class="string">'RDS的ID号'</span>)</span><br><span class="line">request.add_query_param('StartTime', '2018-03-26T08:00Z')#3月26日早上8点开始</span><br><span class="line">request.add_query_param('EndTime', '2018-03-27T08:00Z')#3月27日早上8点结束</span><br><span class="line">request.add_query_param(<span class="string">'DBName'</span>, <span class="string">'对应的数据库名'</span>)</span><br><span class="line">request.add_query_param('PageSize', 100)#这个值只能是30/50/100</span><br><span class="line"></span><br><span class="line"># 发起请求</span><br><span class="line">response = clt.do_action_with_exception(request)</span><br><span class="line">print response</span><br><span class="line"></span><br><span class="line">#把json格式的返回值改成dict格式</span><br><span class="line">slow_log=json.loads(response)</span><br><span class="line">num = slow_log[<span class="string">'TotalRecordCount'</span>]</span><br><span class="line">Hostaddress = []</span><br><span class="line">LockTimes = []</span><br><span class="line">ParseRowCounts = []</span><br><span class="line">QueryTimes = []</span><br><span class="line">SQLText = []</span><br><span class="line"></span><br><span class="line">#将有用的值做成list</span><br><span class="line"><span class="keyword">if</span> num &lt; <span class="number">100</span>:</span><br><span class="line">       <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,num):</span><br><span class="line">               Hostaddress.append(slow_log[<span class="string">'Items'</span>][<span class="string">'SQLSlowRecord'</span>][i][<span class="string">'HostAddress'</span>])</span><br><span class="line">               LockTimes.append(slow_log[<span class="string">'Items'</span>][<span class="string">'SQLSlowRecord'</span>][i][<span class="string">'LockTimes'</span>])</span><br><span class="line">               ParseRowCounts.append(slow_log[<span class="string">'Items'</span>][<span class="string">'SQLSlowRecord'</span>][i][<span class="string">'ParseRowCounts'</span>])</span><br><span class="line">               QueryTimes.append(slow_log[<span class="string">'Items'</span>][<span class="string">'SQLSlowRecord'</span>][i][<span class="string">'QueryTimes'</span>])</span><br><span class="line">               SQLText.append(slow_log[<span class="string">'Items'</span>][<span class="string">'SQLSlowRecord'</span>][i][<span class="string">'SQLText'</span>])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">       <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">100</span>):</span><br><span class="line">               Hostaddress.append(slow_log[<span class="string">'Items'</span>][<span class="string">'SQLSlowRecord'</span>][i][<span class="string">'HostAddress'</span>])</span><br><span class="line">               LockTimes.append(slow_log[<span class="string">'Items'</span>][<span class="string">'SQLSlowRecord'</span>][i][<span class="string">'LockTimes'</span>])</span><br><span class="line">               ParseRowCounts.append(slow_log[<span class="string">'Items'</span>][<span class="string">'SQLSlowRecord'</span>][i][<span class="string">'ParseRowCounts'</span>])</span><br><span class="line">               QueryTimes.append(slow_log[<span class="string">'Items'</span>][<span class="string">'SQLSlowRecord'</span>][i][<span class="string">'QueryTimes'</span>])</span><br><span class="line">               SQLText.append(slow_log[<span class="string">'Items'</span>][<span class="string">'SQLSlowRecord'</span>][i][<span class="string">'SQLText'</span>])</span><br></pre></td></tr></table></figure></p><p>这个<code>response</code>的格式是一个<code>json</code>，在<code>www.json.cn</code>里查看是这个样子：<br><img src="/images/pandas1.png" alt="paradin"></p><p>可以看到返回值里面<code>TotalRecordCount</code>就是总返回值，如果这个值大于<code>PageSize</code>，那么就会有第二篇，需要手动翻篇。所以我这里直接最大值就是100，一篇100已经够开发看了…</p><h2><span id="脚本如下">脚本如下</span></h2><p>在上面的脚本里可以获取到所有慢sql的<code>json</code>格式，那么就可以再写一个脚本把<code>json</code>转化成<code>html</code>格式并且生成一个<code>html</code>文件，然后在nginx里直接把这个文件展示出来。既然用到了<code>pandas</code>库，那么就要先安装<code>pandas</code>,方法如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pip install --upgrade pip</span><br><span class="line">pip install pandas</span><br><span class="line">如果有“Please upgrade numpy to &gt;= <span class="number">1.9</span><span class="number">.0</span> to use <span class="keyword">this</span> pandas version”的反应，那么执行下一句</span><br><span class="line">pip install -U numpy</span><br></pre></td></tr></table></figure></p><p>生成html的整个脚本如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line">#coding=utf-8</span><br><span class="line">from test import Hostaddress,LockTimes,ParseRowCounts,QueryTimes,SQLText#从刚写的test.py里得到那些list变量</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">def convertToHtml(result,title):</span><br><span class="line">    #将数据转换为html的table</span><br><span class="line">    #result是list[list1,list2]这样的结构</span><br><span class="line">    #title是list结构；和result一一对应。titleList[0]对应resultList[0]这样的一条数据对应html表格中的一列</span><br><span class="line">    d = &#123;&#125;</span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> title:</span><br><span class="line">        d[t]=result[index]</span><br><span class="line">        index = index+<span class="number">1</span></span><br><span class="line">    pd.set_option('max_colwidth',200)#默认的行长度是50，这里我调成了200</span><br><span class="line">    df = pd.DataFrame(d)</span><br><span class="line">    df = df[title]</span><br><span class="line">    h = df.to_html(index=False)</span><br><span class="line">    <span class="keyword">return</span> h</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    result = [Hostaddress,LockTimes,ParseRowCounts,QueryTimes,SQLText]</span><br><span class="line">    title = [u<span class="string">'HostAddress'</span>,u<span class="string">'LockTimes'</span>,u<span class="string">'ParseRowCounts'</span>,u<span class="string">'QueryTimes'</span>,u<span class="string">'SQLText'</span>]</span><br><span class="line">    #生成一个叫biaoge.html</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'/nginxhtml路径/biaoge.html'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(convertToHtml(result,title))</span><br><span class="line">        print <span class="string">"html文件已经生成！"</span></span><br></pre></td></tr></table></figure></p><h2><span id="执行效果">执行效果</span></h2><p>将这个<code>biaoge.html</code>直接生成到nginx的html文件夹里，在浏览器里打开这个html就看到效果了，如图：<br><img src="/images/pandas2.png" alt="paradin"></p>]]></content>
    
    <summary type="html">
    
      最近各种画图，都快吐了...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="pandas" scheme="http://yoursite.com/tags/pandas/"/>
    
      <category term="大数据分析" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>记录一次nginx出现了502的问题</title>
    <link href="http://yoursite.com/2018/03/26/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1nginx%E5%87%BA%E7%8E%B0%E4%BA%86502%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/03/26/记录一次nginx出现了502的问题/</id>
    <published>2018-03-26T11:01:24.000Z</published>
    <updated>2018-03-26T11:12:29.110Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="背景交待">背景交待</span></h2><p>市场运营在手机APP端推送了一个“家装节，部分商品优惠打折”消息，用户可以通过点击这个消息，在APP进入到商城界面，如果是已经登录的用户将通过免登陆直接跳转，如果是没有登录的用户会登陆到登陆界面。但是刚推送就发现，通过这个推送点击，没有正常登陆到商城界面，而是返回了502。</p><p>nginx 502的错误，一般来说就是<code>php-fpm</code>的问题，我登陆到电商服务器发现，<code>php-fpm</code>运行正常而且<code>php-fpm</code>的进程数也很正常。但是查看到mysql，发现mysql的CPU飙升，如图：<br><img src="/images/nginx5021.png" alt="paradin"></p><p>于是登陆到数据库里，使用<code>show processlist</code>一看，数据库里有大量的语句处于<code>sending data</code>状态，而且执行时间令人发指（<code>command</code>项处于<code>Sleep</code>状态的进程表示其正在等待接受查询，因此它并没有消耗任何资源，是无害的）：<br><img src="/images/nginx5022.png" alt="paradin"></p><p>先赶快通知运营先把推送的消息界面停用掉，不要让更多的用户登陆失败。然后写了一个脚本批量的kill掉这些进程，看看能不能让数据库恢复正常，过程如下。</p><p>首先先得到<code>show processlist</code>展现的所有的情况:<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p密码 -h数据库地址 -e <span class="string">"show processlist"</span> | grep -i <span class="string">'Locked'</span> &gt; locked_log.txt</span><br></pre></td></tr></table></figure></p><p>然后获得前面的进程号，并且加上kill的指令:<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#/bin/bash</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="string">`cat locked_log.txt | awk '&#123;print $1&#125;'`</span></span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">   echo <span class="string">"kill $line;"</span> &gt;&gt; kill_thread_id.sql</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><p>在登陆到数据库，然后执行上面生成的<code>kill_thread_id.sql</code>：:<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;source kill_thread_id.sql</span><br></pre></td></tr></table></figure></p><p>但是发现，kill掉一批之后，又有了新的慢sql出现，CPU依旧高居不下，于是只能跟产品经理说明情况，在征得了产品经理无奈的同意之后，重启了数据库，幸好时间没有很长，就耽误二三分钟而已。重启了之后，CPU就降下去了。赶快叫开发童鞋在线补充一个索引给用户登录的表来解决这个慢sql问题，没有了慢sql就没有了502。</p><h2><span id="补充nginx499">补充nginx499</span></h2><p>nginx如果爆错499的话，代表<code>客户端主动关闭连接</code>，原因就是后端脚本执行的时间太长了or数据库有慢mysql，调用方超出了<code>timeout</code>的时间，关闭了连接。</p><p>这个时候需要更改一下<code>nginx.conf</code>:<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">proxy_read_timeout <span class="number">10</span>s;</span><br><span class="line">proxy_send_timeout <span class="number">10</span>s;</span><br></pre></td></tr></table></figure></p><p>把上面两个值适度调大然后重启nginx即可。或者就是<code>proxy_ignore_client_abort  on;</code>，这话就是让代理服务端不要主动关闭客户端的连接。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://blog.csdn.net/zhuxineli/article/details/14455029" target="_blank" rel="noopener">https://blog.csdn.net/zhuxineli/article/details/14455029</a><br><a href="https://segmentfault.com/a/1190000012326158" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012326158</a></p>]]></content>
    
    <summary type="html">
    
      据说php可以改变数据表结构？？？
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>使用python调用redis的基本操作</title>
    <link href="http://yoursite.com/2018/03/26/%E4%BD%BF%E7%94%A8python%E8%B0%83%E7%94%A8redis%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2018/03/26/使用python调用redis的基本操作/</id>
    <published>2018-03-26T10:52:37.000Z</published>
    <updated>2018-03-27T16:05:00.036Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="前言">前言</span></h2><p>最近有一个需求，里面涉及到把<code>python</code>获取到的数值存储到<code>redis</code>里，于是就简单研究一下<code>python</code>调用<code>redis</code>的方法。</p><p><code>python</code>要调用redis的时候，需要先安装redis模块，有两个方法。第一个方法就是<code>pip install redis</code>，第二个方法就是<code>easy_install redis</code>，模块装完之后，就可以创建redis连接了。</p><p><code>redis-py</code>提供两个类<code>Redis</code>和<code>StrictRedis</code>来实现Redis的命令，<code>StrictRedis</code>用于实现大部分官方的命令，并使用官方的语法和命令（比如，<code>SET</code>命令对应与<code>StrictRedis.set</code>方法）。 <code>Redis</code>是<code>StrictRedis</code>的子类，用于向后兼容旧版本的<code>redis-py</code>。 <font color="red">官方推荐使用<code>StrictRedis</code>方法，所以我这里只说<code>StrictRedis</code></font>。</p><h2><span id="如何连接">如何连接</span></h2><p>连接的代码如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line">#这里是redis的基本情况</span><br><span class="line">&gt;&gt;&gt; host = <span class="string">'这里填写redis的host地址'</span></span><br><span class="line">&gt;&gt;&gt; port = 6379        #根据实际情况更改端口</span><br><span class="line">&gt;&gt;&gt; password = <span class="string">'redis对应的密码'</span></span><br><span class="line"></span><br><span class="line">#使用StrictRedis去连接到目标redis</span><br><span class="line">&gt;&gt;&gt; r = redis.StrictRedis(host=host, port=6379, password=password, db=0) #db为选定的数据库，db=0代表选择了0号数据库。redis默认有16个数据库，在conf里面可以配置。如果没有指定的数据库，可以不写。</span><br><span class="line">&gt;&gt;&gt; r.set(<span class="string">'age'</span>, <span class="string">'88'</span>)</span><br><span class="line">&gt;&gt;&gt; r.get(<span class="string">'age'</span>)</span><br><span class="line"><span class="string">'88'</span></span><br></pre></td></tr></table></figure></p><p>关系型数据库都有一个<code>连接池</code>的概念：对于大量redis连接来说，如果使用直接连接redis的方式的话，将会造成大量的TCP的重复连接，所以，就引入<code>连接池</code>来解决这个问题。在使用连接池连接上redis之后，可以从该连接池里面生成连接，调用完成之后，该链接将会返还给连接池，供其他连接请求调用，这样将减少大量redis连接的执行时间，那么使用<code>StrictRedis</code>的连接池的实现方式如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pool = redis.ConnectionPool(host=host, port=<span class="number">6379</span>, password=password)</span><br><span class="line">r = redis.StrictRedis(connection_pool=pool</span><br></pre></td></tr></table></figure></p><p>或者使用<code>pipeline</code>（管道），通过<code>缓冲多条命令，然后一次性执行</code>的方法减少<code>服务器-客户端</code>之间TCP数据库包，从而提高效率，方法如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">接上文</span><br><span class="line">pipe = r.pipeline()</span><br><span class="line">#插入数据</span><br><span class="line">&gt;&gt;&gt; pipe.hset(<span class="string">"hash_key"</span>,<span class="string">"leizhu900516"</span>,<span class="number">8</span>)</span><br><span class="line">Pipeline&lt;ConnectionPool&lt;Connection&lt;host=<span class="number">192.168</span><span class="number">.8</span><span class="number">.176</span>,port=<span class="number">6379</span>,db=<span class="number">0</span>&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; pipe.hset(<span class="string">"hash_key"</span>,<span class="string">"chenhuachao"</span>,<span class="number">9</span>)</span><br><span class="line">Pipeline&lt;ConnectionPool&lt;Connection&lt;host=<span class="number">192.168</span><span class="number">.8</span><span class="number">.176</span>,port=<span class="number">6379</span>,db=<span class="number">0</span>&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; pipe.hset(<span class="string">"hash_key"</span>,<span class="string">"wanger"</span>,<span class="number">10</span>)</span><br><span class="line">Pipeline&lt;ConnectionPool&lt;Connection&lt;host=<span class="number">192.168</span><span class="number">.8</span><span class="number">.176</span>,port=<span class="number">6379</span>,db=<span class="number">0</span>&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; pipe.execute()</span><br><span class="line">[<span class="number">1</span>L, <span class="number">1</span>L, <span class="number">1</span>L]</span><br></pre></td></tr></table></figure></p><p><img src="/images/redis1.png" alt="paradin" title="查看插入的结果"></p><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    #批量读取数据</span><br><span class="line">    &gt;&gt;&gt; pipe.hget(<span class="string">"hash_key"</span>,<span class="string">"leizhu900516"</span>)</span><br><span class="line">    Pipeline&lt;ConnectionPool&lt;Connection&lt;host=<span class="number">192.168</span><span class="number">.8</span><span class="number">.176</span>,port=<span class="number">6379</span>,db=<span class="number">0</span>&gt;&gt;&gt;</span><br><span class="line">    &gt;&gt;&gt; pipe.hget(<span class="string">"hash_key"</span>,<span class="string">"chenhuachao"</span>)</span><br><span class="line">    Pipeline&lt;ConnectionPool&lt;Connection&lt;host=<span class="number">192.168</span><span class="number">.8</span><span class="number">.176</span>,port=<span class="number">6379</span>,db=<span class="number">0</span>&gt;&gt;&gt;</span><br><span class="line">    &gt;&gt;&gt; pipe.hget(<span class="string">"hash_key"</span>,<span class="string">"wanger"</span>)</span><br><span class="line">    Pipeline&lt;ConnectionPool&lt;Connection&lt;host=<span class="number">192.168</span><span class="number">.8</span><span class="number">.176</span>,port=<span class="number">6379</span>,db=<span class="number">0</span>&gt;&gt;&gt;</span><br><span class="line">    &gt;&gt;&gt; result = pipe.execute()</span><br><span class="line">    &gt;&gt;&gt; print result</span><br><span class="line">    ['8', '9', '10']   #有序的列表</span><br><span class="line">    <span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span>pipeline<span class="string">`的命令可以写在一起，如`</span>p.set(<span class="string">'hello'</span>,<span class="string">'redis'</span>).sadd(<span class="string">'faz'</span>,<span class="string">'baz'</span>).incr(<span class="string">'num'</span>).execute()<span class="string">`，其实它的意思等同于是：</span></span><br><span class="line"><span class="string">    `</span><span class="string">``</span>js</span><br><span class="line">    &gt;&gt;&gt; p.set(<span class="string">'hello'</span>,<span class="string">'redis'</span>)</span><br><span class="line">    &gt;&gt;&gt; p.sadd(<span class="string">'faz'</span>,<span class="string">'baz'</span>)</span><br><span class="line">    &gt;&gt;&gt; p.incr(<span class="string">'num'</span>)</span><br><span class="line">    &gt;&gt;&gt; p.execute()</span><br><span class="line">    [True, <span class="number">1</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure></code></pre><p>利用<code>pipeline</code>取值3500条数据，大约需要900ms，如果配合线程or协程来使用，每秒返回1W数据是没有问题的，基本能满足大部分业务。</p><h2><span id="如何存储">如何存储</span></h2><p>上面已经举了一个<code>age：88</code>的例子，可见创建一个<code>string</code>类型的key并放入value是使用<code>set</code>方法，比如再多存几个名字：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; r.set(<span class="string">'name'</span>, <span class="string">'lilei'</span>)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; r.get(<span class="string">'name'</span>)</span><br><span class="line"><span class="string">'lilei'</span></span><br><span class="line">&gt;&gt;&gt; r.set(<span class="string">'name2'</span>, <span class="string">'zhaowei'</span>)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; r.set(<span class="string">'name3'</span>, <span class="string">'james'</span>)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; r.set(<span class="string">'name4'</span>, <span class="string">'yaoming'</span>)</span><br><span class="line">True</span><br><span class="line">#列出以name开头的所有key</span><br><span class="line">&gt;&gt;&gt; print r.keys(<span class="string">"name*"</span>)</span><br><span class="line">[<span class="string">'name3'</span>, <span class="string">'name4'</span>, <span class="string">'name2'</span>, <span class="string">'name'</span>]</span><br><span class="line">#列出所有key</span><br><span class="line">&gt;&gt;&gt; print r.keys()</span><br><span class="line">&gt;&gt;&gt; r.dbsize()         #当前数据库包含多少条数据       </span><br><span class="line"><span class="number">4</span>L</span><br><span class="line">&gt;&gt;&gt; r.delete(<span class="string">'name'</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line">&gt;&gt;&gt; r.save()               #执行“检查点”操作，将数据写回磁盘。保存时阻塞</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; r.get(<span class="string">'name'</span>)</span><br><span class="line">&gt;&gt;&gt; r.flushdb()        #清空r中的所有数据</span><br><span class="line">True</span><br></pre></td></tr></table></figure></p><p>还有其他类型的存储方法，简单举例子如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#创建一个hash</span><br><span class="line">r.hset(<span class="string">'abc:def'</span>, <span class="string">'name'</span>, <span class="string">"abcde"</span>)</span><br><span class="line">#获取一个hash的所有值</span><br><span class="line">print r.hgetall(<span class="string">'abc:def'</span>)</span><br><span class="line">#获取一个hash的所有key    </span><br><span class="line">print r.hkeys(<span class="string">'abc:def'</span>) </span><br><span class="line">#创建list</span><br><span class="line">r.sadd(<span class="string">'abcd:ef'</span>,<span class="string">'nihao'</span>)</span><br><span class="line">r.sadd(<span class="string">'abcd:ef'</span>,<span class="string">'hello'</span>)</span><br><span class="line">r.sadd(<span class="string">'xxxx'</span>,<span class="string">'nihao'</span>)</span><br><span class="line">r.sadd(<span class="string">'xxxx'</span>,<span class="string">'good'</span>)</span><br><span class="line">#打印出该key中的值 list</span><br><span class="line">print r.smembers(<span class="string">'abcd:ef'</span>)</span><br><span class="line">#查询两个list中相同的值</span><br><span class="line">print r.sinter(<span class="string">'abcd:ef'</span>, <span class="string">'xxxx'</span>)</span><br><span class="line">#给两个list取并集</span><br><span class="line">print r.sunion(<span class="string">'abcd:ef'</span>, <span class="string">'xxxx'</span>)</span><br></pre></td></tr></table></figure></p><p><code>setnx</code>是<code>SET if Not eXists</code>的缩写，也就是只有不存在的时候才设置，可以利用它来实现锁的效果。python要使用它也是<code>r.setnx(key,value)</code>，当发现没有这个key的时候，就会插入这个新的key以及对应的value，如果发现有了个这个key了，那这条就等于没加。</p><h2><span id="如何删除">如何删除</span></h2><p><code>py-redis</code>中有个<code>delete</code>接口，既可以删除单个key，也可以全删除key，如果要删除几个key，用法是:<code>r.delete(&#39;age&#39;)</code>、<code>r.delete(&#39;sex&#39;, &#39;age&#39;)</code>，如果要全删除，那就是<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">keys = r.keys()</span><br><span class="line">r.delete(*keys)</span><br></pre></td></tr></table></figure></p><p>执行之后的效果等于<code>flushall</code>。</p><p>redis里默认情况下是不支持通配符的，那么要批量删除key怎么做呢？答案就是搭配<code>xargs</code>，比如要删除掉所有<code>2018-03-</code>开头的key：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -hredis地址 -a密码 keys <span class="string">"2018-03-*"</span>|xargs redis-cli -hredis地址 -a密码 del</span><br></pre></td></tr></table></figure></p><h2><span id="python将两个list元素一一对应转换为dict">python将两个list元素一一对应转换为dict</span></h2><p>使用python的<code>zip</code>函数和强大的集合操作可以方便的将两个list元素一一对应转换为dict，如下示例代码：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">'n1'</span>,<span class="string">'n2'</span>,<span class="string">'n3'</span>]</span><br><span class="line">values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">nvs = zip(names,values)</span><br><span class="line">nvDict = dict( (name,value) <span class="keyword">for</span> name,value <span class="keyword">in</span> nvs)</span><br></pre></td></tr></table></figure></p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://github.com/andymccurdy/redis-py" target="_blank" rel="noopener">https://github.com/andymccurdy/redis-py</a><br><a href="http://xiaorui.cc/2014/11/10/%E4%BD%BF%E7%94%A8redis-py%E7%9A%84%E4%B8%A4%E4%B8%AA%E7%B1%BBredis%E5%92%8Cstrictredis%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/" target="_blank" rel="noopener">http://xiaorui.cc/2014/11/10/%E4%BD%BF%E7%94%A8redis-py%E7%9A%84%E4%B8%A4%E4%B8%AA%E7%B1%BBredis%E5%92%8Cstrictredis%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/</a><br><a href="http://debugo.com/python-redis/" target="_blank" rel="noopener">http://debugo.com/python-redis/</a></p>]]></content>
    
    <summary type="html">
    
      把数据存到redis里，任我蹂躏...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>使用python调用echart画图</title>
    <link href="http://yoursite.com/2018/03/22/%E4%BD%BF%E7%94%A8python%E8%B0%83%E7%94%A8echart%E7%94%BB%E5%9B%BE/"/>
    <id>http://yoursite.com/2018/03/22/使用python调用echart画图/</id>
    <published>2018-03-22T15:24:32.000Z</published>
    <updated>2018-03-23T11:02:46.366Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="前言">前言</span></h2><p>之前说了如何使用阿里云的SDK获取云存储的值然后发送表格邮件，但是最近领导又发话了，说这个邮件每天一封看的有点审美疲劳，要顺应“数据可视化”的趋势，于是就要求画图，力求直观，要做到“从众多数据中突出特别数据，从特别数据中突出高价值数据”。我之前用<code>python</code>的<code>matplotlib</code>画过，这一次尝试用<code>echart</code>来做图！</p><p><code>echart</code>是不太良心的百度良心的开源作品，提供各种各样精美的作图方案，分分钟把图片做的高大上，吸引周围人的目光。不过我对前端的了解非常浅薄，但是没关系。这次使用<code>pyechart</code>插件！这个插件可以让<code>python</code>直接调用<code>echart</code>接口，选择需要的图形之后，直接往里查数据就好，简单粗暴见效快，而且支持3D，可以说是居家旅行常备物品。可以说，有了它，作图能力顶呱呱。感谢开发者大神们的辛苦工作！</p><h2><span id="作图">作图</span></h2><p>首先先需要安装<code>pyecharts</code>插件，命令是<code>pip install pyecharts</code>。</p><p>然后我们就可以写一个简单的案例，如下：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line">#coding=utf-8</span><br><span class="line">from pyecharts import Bar    #导入第三方库</span><br><span class="line"></span><br><span class="line">#attr = ["&#123;&#125;day".format(i) for i in range(1, 8)]    #这样的话X坐标就是1day、2day、3day...</span><br><span class="line">attr = ["Mon", "Feb", "Wed", "Thu", "Fri", "Sat", "Sun"]    #这样X坐标就是星期</span><br><span class="line">v1 = [<span class="number">1.49</span>, <span class="number">2.09</span>, <span class="number">4.03</span>, <span class="number">2.23</span>, <span class="number">5.26</span>, <span class="number">7.71</span>, <span class="number">7.56</span>]        </span><br><span class="line">v2 = [<span class="number">0.3</span>, <span class="number">0.9</span>, <span class="number">0.2</span>, <span class="number">0.4</span>, <span class="number">0.7</span>, <span class="number">0.7</span>, <span class="number">0.6</span>]</span><br><span class="line">v3 = [<span class="number">18.15</span>, <span class="number">13.22</span>, <span class="number">11.28</span>, <span class="number">17.99</span>, <span class="number">18.7</span>, <span class="number">19.7</span>, <span class="number">15.6</span>]</span><br><span class="line"></span><br><span class="line">bar = Bar("乐橙云存储情况总览", "本图表展示过去一周的云存储情况")        #这里是主标题和副标题</span><br><span class="line">bar.add("录像分享文件", attr, v1, mark_line=["average"], mark_point=["max", "min"])    #每一个值的名称以及要展现平均值和最大最小值</span><br><span class="line">bar.add(<span class="string">"视频直播文件"</span>, attr, v2, mark_line=[<span class="string">"average"</span>], mark_point=[<span class="string">"max"</span>, <span class="string">"min"</span>])</span><br><span class="line">bar.add(<span class="string">"云录像、报警图片、全景图片"</span>, attr, v3, mark_line=[<span class="string">"average"</span>], mark_point=[<span class="string">"max"</span>, <span class="string">"min"</span>])    </span><br><span class="line">bar.render('/tmp/111.html')        #在/tmp文件夹里生成一个111.html文件</span><br></pre></td></tr></table></figure></p><p>如果服务器里有<code>nginx</code>，那么把这个html文件放到<code>nginx/html</code>路径里，再在浏览器里打开就会看到这样的图：<br><img src="/images/pyechart.png" alt="paradin"></p><p>而且还可以通过点击网页上“A值”、“B值”、“C值”就可以达到屏蔽相应值的效果，而且如果点击红色箭头的“数据视图”，还可以直接看到对应的数据，非常贴心非常屌，如图：<br><img src="/images/pyechart2.png" alt="paradin"></p><p>如果你觉得图片有点小，那么可以修改这个地方：<code>bar = Bar(&quot;XXX情况总览&quot;, &quot;本图表展示过去一周的ABC情况&quot;，width=1000,height=900)</code>，我这里把宽和高分别从默认值调成了1000和900。</p><p>如果想要在一个html里做多个图，比如要做三个柱状图，那么example如下：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line">#coding=utf-8</span><br><span class="line"><span class="keyword">from</span> pyecharts <span class="keyword">import</span> Bar, Grid</span><br><span class="line"></span><br><span class="line">attr = [<span class="string">"一班"</span>, <span class="string">"二班"</span>, <span class="string">"三班"</span>, <span class="string">"四班"</span>]</span><br><span class="line">v1 = [<span class="number">54</span>, <span class="number">81</span>, <span class="number">32</span>, <span class="number">32</span>] </span><br><span class="line">v2 = [<span class="number">68</span>, <span class="number">69</span>, <span class="number">27</span>, <span class="number">32</span>] </span><br><span class="line">bar = Bar(<span class="string">"赞成票"</span>,<span class="string">"本图表展示赞成票情况"</span>)</span><br><span class="line">bar.add(<span class="string">"年纪长"</span>, attr, v1, mark_point=[<span class="string">"max"</span>, <span class="string">"min"</span>])</span><br><span class="line">bar.add(<span class="string">"副年纪长"</span>, attr, v2, mark_point=[<span class="string">"max"</span>, <span class="string">"min"</span>])</span><br><span class="line"></span><br><span class="line">attr2 = [<span class="string">"一班"</span>, <span class="string">"二班"</span>, <span class="string">"三班"</span>, <span class="string">"四班"</span>]</span><br><span class="line">x1 = [<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">x2 = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>]</span><br><span class="line">bar2 = Bar("反对票","本图表展示反对票情况",title_top='bottom',title_color='#1d12eb')            #title_color是标题颜色，这个跟html的颜色取值一样</span><br><span class="line">bar2.add(<span class="string">"年纪长"</span>, attr2, x1, mark_point=[<span class="string">"max"</span>, <span class="string">"min"</span>])</span><br><span class="line">bar2.add(<span class="string">"副年纪长"</span>, attr2, x2, mark_point=[<span class="string">"max"</span>, <span class="string">"min"</span>])</span><br><span class="line"></span><br><span class="line">attr3 = [<span class="string">"一班"</span>, <span class="string">"二班"</span>, <span class="string">"三班"</span>, <span class="string">"四班"</span>]</span><br><span class="line">y1 = [<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">y2 = [<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">bar3 = Bar("弃权票","本图表展示弃权票情况",title_pos='right',title_color='#eb1212')             #title_pos是标题的位置，如果不特殊说明，会重叠</span><br><span class="line">bar3.add(<span class="string">"年纪长"</span>, attr3, y1, mark_point=[<span class="string">"max"</span>, <span class="string">"min"</span>])    </span><br><span class="line">bar3.add(<span class="string">"副年纪长"</span>, attr3, y1, mark_point=[<span class="string">"max"</span>, <span class="string">"min"</span>])</span><br><span class="line"></span><br><span class="line">grid = Grid()    </span><br><span class="line">grid.add(bar, grid_width="40%", grid_height="30%", grid_bottom="60%", grid_right="55%")        #grid_height和grid_width是每一个小图的大小</span><br><span class="line">grid.add(bar2, grid_width="40%", grid_height="30%", grid_bottom="60%", grid_left="55%")        #grid_bottom和grid_top是垂直位置</span><br><span class="line">grid.add(bar3, grid_width="40%", grid_height="30%", grid_top="60%", grid_right="55%")        #grid_right和grid_left是水平位置</span><br><span class="line">grid.render('/tmp/grid.html')    #在/tmp文件夹里生成一个grid.html文件</span><br></pre></td></tr></table></figure></p><p><img src="/images/pyechart3.png" alt="paradin"></p><p>例子中的数字都是我虚拟的，实际情况中，这些数字都应该是存储在redis这样的数据库里，然后取出来使用。</p><p>上面的两个例子仅仅是<code>pyechart</code>使用的冰山一角，如果想更多的了解，请去看一下文末<code>pyechart</code>的中文说明文档，无论是柱状图、雷达图、曲线图、3D图都有相关的使用讲解，内容特别丰富！</p><h2><span id="参考资料">参考资料</span></h2><p><a href="http://echarts.baidu.com" target="_blank" rel="noopener">http://echarts.baidu.com</a><br><a href="http://pyecharts.org/#/zh-cn/prepare" target="_blank" rel="noopener">http://pyecharts.org/#/zh-cn/prepare</a></p>]]></content>
    
    <summary type="html">
    
      有了pyechart加持，准保你的大数据图案美观简洁又大方！
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="echart" scheme="http://yoursite.com/tags/echart/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ的安装、配置与启动</title>
    <link href="http://yoursite.com/2018/03/19/RabbitMQ%E7%9A%84%E5%AE%89%E8%A3%85%E3%80%81%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%90%AF%E5%8A%A8/"/>
    <id>http://yoursite.com/2018/03/19/RabbitMQ的安装、配置与启动/</id>
    <published>2018-03-19T01:59:05.000Z</published>
    <updated>2018-03-19T03:35:49.323Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="前言">前言</span></h2><p>环境介绍：<code>Centos 7</code> + <code>RabbitMQ：3.6.12</code> + <code>Erlang：20.0</code></p><h2><span id="安装erlang">安装erlang</span></h2><p>由于RabbitMQ使用erlang语言编写的，所以要先安装erlang语言环境。但是yum源里的erlang版本太老了，于是这里选择手动安装，使用Erlang官方推荐的<code>Erlang Solutions</code>安装方法如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum install gcc gcc-c++ glibc-devel make ncurses-devel openssl-devel autoconf java-1.8.0-openjdk-devel git wget wxBase.x86_64#先把其他模块准备好</span><br><span class="line">wget https:<span class="comment">//packages.erlang-solutions.com/erlang-solutions-1.0-1.noarch.rpm</span></span><br><span class="line">rpm -Uvh erlang-solutions<span class="number">-1.0</span><span class="number">-1.</span>noarch.rpm</span><br><span class="line">rpm --<span class="keyword">import</span> https:<span class="comment">//packages.erlang-solutions.com/rpm/erlang_solutions.asc</span></span><br></pre></td></tr></table></figure></p><p>此时，查看<code>/etc/yum.repos.d/erlang_solutions.repo</code>，应该是这个样子：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[erlang-solutions]</span><br><span class="line">name=CentOS $releasever - $basearch - Erlang Solutions</span><br><span class="line">baseurl=https:<span class="comment">//packages.erlang-solutions.com/rpm/centos/$releasever/$basearch</span></span><br><span class="line">gpgcheck=<span class="number">1</span></span><br><span class="line">gpgkey=https:<span class="comment">//packages.erlang-solutions.com/rpm/erlang_solutions.asc</span></span><br><span class="line">enabled=<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>这个时候可以yum安装了：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y esl-erlang</span><br></pre></td></tr></table></figure></p><p>此时得到的erlang就是20.0版本的了，如图：<br><img src="/images/rabbitmq1.png" alt="paradin"></p><p>如果不想使用这个办法，可以使用源码安装的方式，<a href="https://packages.erlang-solutions.com/erlang/" target="_blank" rel="noopener">https://packages.erlang-solutions.com/erlang/</a> 这里面有Erlang官方的下载包，拆包解压缩然后<code>make &amp;&amp; make install</code>即可。</p><h2><span id="安装rabbitmq">安装RabbitMQ</span></h2><p>安装RabbitMQ跟其他普通软件差不多，先去官网下载目前较稳定的rpm包，然后安装，步骤如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https:<span class="comment">//dl.bintray.com/rabbitmq/all/rabbitmq-server/3.7.4/rabbitmq-server-3.7.4-1.el7.noarch.rpm</span></span><br><span class="line">yum install -y rabbitmq-server<span class="number">-3.7</span><span class="number">.4</span><span class="number">-1.</span>el7.noarch.rpm</span><br></pre></td></tr></table></figure></p><p>如果出现了<code>Transaction Check Error</code>的错误：<br><img src="/images/rabbitmq2.png" alt="paradin"></p><p>可见是要安装的包与已有的包相冲突，此时需要<code>yum list|grep erlang</code>，如图：</p><p><img src="/images/rabbitmq3.png" alt="paradin"><br>再<code>yum remove esl-erlang.x86_64</code>，然后重新执行yum install那一步即可。</p><p>如果出现<code>Requires: socat</code>的错误，如图：<br><img src="/images/rabbitmq6.png" alt="paradin"></p><p>此时需要执行如下命令即可：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y install epel-release</span><br><span class="line">yum -y install socat</span><br></pre></td></tr></table></figure></p><h2><span id="配置rabbitmq">配置RabbitMQ</span></h2><p>RabbitMQ安装完毕，先<code>chkconfig rabbitmq-server on</code>设置开机启动。然后，配置一下用户名。我这个机器的用户名不规范，需要把hostname里的中文去掉，比如改成：<code>3-dvl-hlsproxy-001</code>，那么就要在/etc/hosts里添加一句：</p><pre><code>内网IP地址 3-dvl-hlsproxy-001</code></pre><p>然后执行<code>rabbitmq-plugins enable rabbitmq_management</code>来安装WEB图形界面，然后拷贝<code>rabbitmq.config.example</code>到<code>/etc/rabbitmq/</code>里，并且改名叫<code>rabbitmq.config</code>，命令如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/share/doc/rabbitmq-server<span class="number">-3.7</span><span class="number">.4</span>/rabbitmq.config.example /etc/rabbitmq/</span><br><span class="line">cd /etc/rabbitmq/</span><br><span class="line">mv rabbitmq.config.example rabbitmq.config</span><br></pre></td></tr></table></figure></p><p>编辑<code>rabbitmq.config</code>这个文件，把<code>%%{loopback_users, []}.</code>改成<code>{loopback_users, []}</code>，保存之后，执行<code>service rabbitmq-server restart</code>来启动RabbitMQ。</p><p>如果启动之后，执行<code>rabbitmqctl status</code>不断的刷<code>Error when reading /var/lib/rabbitmq/.erlang.cookie: eacces</code>的错误的话，执行<code>chown rabbitmq:rabbitmq /var/lib/rabbitmq/.erlang.cookie</code>。</p><p>在浏览器里登录<code>外网IP:15672</code>就会看到RabbitMQ的WEB配置界面了，<br><img src="/images/rabbitmq4.png" alt="paradin"></p><p>账号和密码都是guest，输入之后就会看到如下的界面，可以在界面里看到<code>3-dvl-hlsproxy-001</code>的情况了，如图：<br><img src="/images/rabbitmq5.png" alt="paradin"></p><p>RabbitMQ 3.0以后版本的WEB端口是<code>15672</code>,服务的端口是<code>5672</code>,这俩都可以在配置文件里面更改。至此RabbitMQ的安装与配置结束了，但是这个仅仅是最简单的配置，RabbitMQ自身有一套很详细的用户管理规则以及它支持Python等很多语言的管理，这些内容以后再详细说明。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://packages.erlang-solutions.com/erlang/" target="_blank" rel="noopener">https://packages.erlang-solutions.com/erlang/</a><br><a href="https://laucyun.com/9849587ce75f31d534d52f906c94368f.html" target="_blank" rel="noopener">https://laucyun.com/9849587ce75f31d534d52f906c94368f.html</a><br><a href="https://www.rabbitmq.com/access-control.html" target="_blank" rel="noopener">https://www.rabbitmq.com/access-control.html</a></p><p><img src="/images/salahe.gif" alt="paradin" title="大四喜的萨拉赫"></p>]]></content>
    
    <summary type="html">
    
      这个MQ是给activemq当备胎的
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="消息队列" scheme="http://yoursite.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="RabbitMQ" scheme="http://yoursite.com/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>使用nginx开启http2协议</title>
    <link href="http://yoursite.com/2018/03/16/%E4%BD%BF%E7%94%A8nginx%E5%BC%80%E5%90%AFhttp2%E5%8D%8F%E8%AE%AE/"/>
    <id>http://yoursite.com/2018/03/16/使用nginx开启http2协议/</id>
    <published>2018-03-16T14:34:44.000Z</published>
    <updated>2018-03-16T16:24:29.939Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="部署过程">部署过程</span></h2><p><code>HTTP/2</code>是建立在TLS的基础上的，那么先要查看nginx的版本和openssl的版本，如果<code>nginx</code>版本在<code>1.10.0</code>以上且需要<code>openssl</code>版本在<code>1.0.2</code>以上那么就可以进行下一步了：<br><img src="/images/http2-10.png" alt="paradin"></p><p>如果版本并不符合要求，可以按照<a href="https://rorschachchan.github.io/2018/01/03/Nginx动态编译新的模块/" target="_blank" rel="noopener">https://rorschachchan.github.io/2018/01/03/Nginx动态编译新的模块/</a> 里的方法升级对应的模块版本。</p><p>先编辑https（443端口）对应的<code>conf</code>文件：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 443 ssl http2;    #这里多加一句http2</span><br><span class="line">        server_name  cuntao.lechange.com *.lechange.com;    #这里填写实际的域名，我这里以cuntao.lechange.com为例</span><br><span class="line"></span><br><span class="line">        ssl_certificate /实际路径/server-com.crt;        </span><br><span class="line">        ssl_certificate_key /实际路径/server-com.key;</span><br><span class="line"></span><br><span class="line">        ssl_session_timeout  30m;        #客户端会话缓存时间</span><br><span class="line">        ssl_protocols  TLSv1 TLSv1.1 TLSv1.2;    #允许的协议</span><br><span class="line">        ssl_ciphers  EECDH+CHACHA20:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5;    #加密算法(CloudFlare 推荐的加密套件组)</span><br><span class="line">        ssl_prefer_server_ciphers   on;        #优化 SSL 加密套件</span><br><span class="line">        ssl_session_cache builtin:1000 shared:SSL:10m;        #SSL会话缓存类型和大小</span><br><span class="line">        ssl_buffer_size 1400;        #每个MTU大小1400b</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page  <span class="number">404</span>              /<span class="number">404.</span>html;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>保存之后再编辑http（80端口）对应的<code>conf</code>文件：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen <span class="number">80</span> <span class="keyword">default</span>;</span><br><span class="line">    add_header Strict-Transport-Security max-age=<span class="number">15768000</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">301</span> https:<span class="comment">//$host$request_uri;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后使用<code>nginx -t</code>检查一下是否文件有错误，如果是OK的话，那么就<code>nginx -s reload</code>平滑重启一下nginx即可。</p><p>验证<code>HTTP/2</code>协议是否开启很简单，有两个方法：<br>1）登陆<code>https://tools.keycdn.com/http2-test</code>，将你的域名填写进去，查看一下配置成功：<br><img src="/images/http2-11.png" alt="paradin"></p><p>2)在Chrome浏览器上可以通过安装<code>HTTP/2 and SPDY indicator</code>插件来检验，网址是<a href="https://chrome.google.com/webstore/detail/http2-and-spdy-indicator/mpbpobfflnpcgagjijhmgnchggcjblin" target="_blank" rel="noopener">https://chrome.google.com/webstore/detail/http2-and-spdy-indicator/mpbpobfflnpcgagjijhmgnchggcjblin</a>  ，如果地址栏出现蓝色的闪电就是该网站开启了<code>HTTP/2</code>协议，灰色的话就是<code>HTTP/2</code>协议没开启。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://www.nginx.com/blog/nginx-1-9-5/" target="_blank" rel="noopener">https://www.nginx.com/blog/nginx-1-9-5/</a><br><a href="https://blog.fazero.me/2017/01/06/upgrate-nginx-and-use-http2/" target="_blank" rel="noopener">https://blog.fazero.me/2017/01/06/upgrate-nginx-and-use-http2/</a><br><a href="https://iyaozhen.com/nginx-http2-conf.html" target="_blank" rel="noopener">https://iyaozhen.com/nginx-http2-conf.html</a></p>]]></content>
    
    <summary type="html">
    
      普通的HTTPS网站浏览会比HTTP网站稍微慢一些，因为需要处理加密任务，而配置了HTTP/2的HTTPS，在低延时的情况下速度会比HTTP更快更稳定！
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
      <category term="http协议" scheme="http://yoursite.com/tags/http%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>关于HTTP 2.0应该知道的事</title>
    <link href="http://yoursite.com/2018/03/16/%E5%85%B3%E4%BA%8EHTTP-2%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8B/"/>
    <id>http://yoursite.com/2018/03/16/关于HTTP-2应该知道的事/</id>
    <published>2018-03-16T13:44:45.000Z</published>
    <updated>2018-03-16T16:28:45.398Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="http-20的优势">HTTP 2.0的优势</span></h2><p>相比<code>HTTP/1.x</code>，<code>HTTP/2</code>在底层传输做了很大的改动和优化：<br>1.每个服务器只用一个连接：<code>HTTP/2</code>对每个服务器只使用一个连接，而不是每个文件一个连接。这样，就省掉了多次建立连接的时间，这个时间对TLS尤其明显，因为TLS连接费时间;<br>2.加速TLS交付：<code>HTTP/2</code>只需一次耗时的TLS握手，并且通过一个连接上的多路利用实现最佳性能。<code>HTTP/2</code>还会压缩首部数据，省掉<code>HTTP/1.x</code>时代所需的一些优化工作，比如拼接文件，从而提高缓存利用率;<br>3.简化Web应用：使用<code>HTTP/2</code>可以让Web开发者省很多事，因为不用再做那些针对<code>HTTP/1.x</code>的优化工作了;<br>4.适合内容混杂的页面：<code>HTTP/2</code>特别适合混合了HTML、CSS、JavaScript、图片和有限多媒体的传统页面。浏览器可以优先安排那些重要的文件请求，让页面的关键部分先出现、快出现，而且根本不会发生“浏览器明明在等关键的CSS和JS，而服务器还在发送黄图”的尴尬局面;<br>5.更安全：通过减少TLS的性能损失，可以让更多应用使用TLS，从而让用户信息更安全。</p><h2><span id="http-20性能增强之二进制分帧">HTTP 2.0性能增强之二进制分帧</span></h2><p>HTTP的定义大家都知道，叫<code>超文本协议</code>，也就是说<code>http1.x</code>的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多。但是在<code>HTTP/2</code>里这里做了比较重大的改动—<code>二进制分帧</code>，<code>HTTP/2</code>在应用层(HTTP)和传输层(TCP or UDP)之间增加一个二进制分帧层。在这个新增的二进制分帧层里<code>HTTP/2</code>会将所有传输的信息分割为更小的消息和帧,并对它们采用二进制格式的编码 ，其中<code>HTTP1.x</code>的首部信息会被封装到<code>Headers</code>帧，而我们的<code>request body</code>则封装到<code>Data</code>帧里面。二进制与之前的文本不同，二进制只认0和1的组合。基于这种考虑<code>http2.0</code>的协议解析决定采用二进制格式，实现方便且健壮。<br><img src="/images/http2-1.png" alt="paradin" title="对比一下http1.x和http2的报文格式"></p><p><code>HTTP/2</code>的格式定义十分高效且精简。<code>length</code>定义了整个<code>frame</code>的大小，<code>type</code>定义<code>frame</code>的类型（一共10种），<code>flags</code>用<code>bit</code>位定义一些重要的参数，<code>stream id</code>用作流控制，<code>payload</code>就是<code>request</code>的正文，如下图：<br><img src="/images/http2-2.png" alt="paradin" title="二进制层是夹在回话层和应用层之间的"></p><h2><span id="http-20性能增强之首部压缩">HTTP 2.0性能增强之首部压缩</span></h2><p>虽然<code>HTTP/2</code>引入了二进制分帧的概念，但是试想如果所有的二进制帧都会带上<code>Headers</code>帧，这是多大的数据冗余传送啊。于是<code>HTTP/2</code>针对这个需求又搞出来一个东东—“首部表”。</p><p>“首部表”来跟踪和存储之前发送的<code>键-值</code>对，对于相同的数据，不再通过每次请求和响应发送；通信期间几乎不会改变的通用<code>键-值</code>对(用户代理、可接受的媒体类型等等)只需发送一次。事实上,如果请求中不包含首部(例如对同一资源的轮询请求)，那么首部开销就是零字节。此时所有首部都自动使用之前请求发送的首部。如果首部发生变化了，那么只需要发送变化了数据在<code>Headers</code>帧里面，新增或修改的首部帧会被追加到“首部表”。首部表在<code>HTTP/2</code>的连接存续期内始终存在,由客户端和服务器共同渐进地更新。</p><h2><span id="http-20性能增强之tcp请求集中">HTTP 2.0性能增强之TCP请求集中</span></h2><p>TCP的优势是很直白的：面向连接、提供可靠的数据传输服务、流量控制。那么有效地使用TCP连接的方法就是<strong>长时间连接传输大块数据</strong>。于是<code>HTTP/2</code>就尽大化的把这一特点发扬：所有<code>HTTP/2</code>通信都是在一个TCP连接上完成。前面说过，HTTP/2把HTTP协议通信的基本单位缩小为一个一个的帧，这些帧对应着逻辑流中的消息，并行地在同一个TCP连接上双向交换消息(注意这个“双向交换消息”)。举个例子，请求一个页面<code>https://www.google.com</code>，页面上所有的资源请求都是客户端与服务器上的一条TCP上请求和响应的！</p><p>这样“单链接多资源”的方式，使到至上而下的层面都得到了好处：<br>    1.可以减少服务链接压力,内存占用少了,连接吞吐量大了；<br>    2.由于TCP连接减少而使网络拥塞状况得以改观;<br>    3.慢启动时间减少,拥塞和丢包恢复速度更快。</p><p>综上所述，“资源合并减少请求”对于<code>HTTP/2</code>是无用的优化手段。</p><p>上面的文字说了要注意“双向交换消息”，那么啥是“双向交换消息”？</p><p>就是把HTTP消息分解为独立的帧,交错发送,然后在另一端重新组装。专业一点说就是“一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的id将request再归属到各自不同的服务端请求里面”。这是<code>HTTP/2</code>重要的一项增强。事实上,这个机制会在整个Web技术栈中引发一系列连锁反应, 从而带来巨大的性能提升,因为：</p><pre><code>可以并行交错地发送请求,请求之间互不影响;可以并行交错地发送响应,响应之间互不干扰;只使用一个连接即可并行发送多个请求和响应;消除不必要的延迟,从而减少页面加载的时间;</code></pre><p><img src="/images/http2-3.png" alt="paradin" title="“域名分区”这种优化手段对于HTTP2.0是无用的，因为资源都是并行交错发送，且没有限制，不需要额外的多域名并行下载"></p><h2><span id="keep-alive与http2集中tcp的区别">Keep Alive与HTTP/2集中TCP的区别</span></h2><p><code>HTTP1.1</code>的<code>keep-alive</code>是为了尽可能使用持久链接，以消除TCP握手和慢启动。但是<code>keep-alive</code>使用多了同样会给服务端带来大量的性能压力，并且对于单个文件被不断请求的服务(例如图片存放网站)，<code>keep-alive</code>可能会极大的影响性能，因为它在文件被请求之后还保持了不必要的连接很长时间。</p><p>举个例子：下载<code>a.js</code>创建一个TCP链接，就会需要TCP握手和慢启动而产生了约300ms下载延迟。当<code>a.js</code>下载完成后这时候<code>b.js</code>也要下载，如果<code>a.js</code>创建TCP链接是<code>keep-alive</code>的，<code>b.js</code>就可以复用其TCP而不需要重新TCP握手和慢启动（没有了那300ms）。</p><p>而<code>HTTP/2</code>是使用一个TCP链接的，其慢启动和握手只在第一次链接的时候产生一次，其后面链接都是持久化的。并且一个TCP下载多个资源，可以将TCP吞吐量最大化来提升性能，这方面可以参考一下TCP的拥塞预防及控制。<br><img src="/images/http2-4.png" alt="paradin"></p><p><img src="/images/http2-5.png" alt="paradin"></p><h2><span id="nginx上如何配制http2">NGINX上如何配制HTTP/2</span></h2><p>上面说了这么多HTTP/2这个好那个好，是未来的趋势blablabla，但是要实现<code>HTTP/2</code>，还是需要“客户端和服务器都开启了HTTP/2”这一个首要条件。不过现在客户端（浏览器）大多数都已经支持<code>HTTP/2</code>，那么主要就是在服务器端如何开启<code>HTTP/2</code>，nginx的配置方法请见：<a href="https://rorschachchan.github.io/2018/03/16/使用nginx开启http2协议/" target="_blank" rel="noopener">https://rorschachchan.github.io/2018/03/16/使用nginx开启http2协议/</a> 。</p><p>按照这样的操作下来，服务器就开了<code>HTTP/2</code>协议，那些支持<code>HTTP/2</code>的浏览器在请求页面的时候就会走<code>HTTP/2</code>模式，而不支持HTTP/2的浏览器会议就按照<code>HTTP/1.X</code>的方式发送请求，如图：<br><img src="/images/http2-7.png" alt="paradin"></p><p><img src="/images/http2-8.png" alt="paradin" title="如果nginx是一个代理服务器的话，就是这图的传输方式"></p><p>支持<code>HTTP/2</code>的Web Server基本都支持<code>HTTP/1.1</code>。这样，即使浏览器不支持<code>HTTP/2</code>，双方也可以协商出可用的<code>HTTP</code>版本，没有兼容性问题。<br><img src="/images/http2-6.png" alt="paradin" title="使用HTTP/2其实还是服务器说的算"></p><h2><span id="参考资料">参考资料</span></h2><p><a href="http://www.alloyteam.com/2015/03/http2-0-di-qi-miao-ri-chang/comment-page-1/#comments" target="_blank" rel="noopener">http://www.alloyteam.com/2015/03/http2-0-di-qi-miao-ri-chang/comment-page-1/#comments</a><br><a href="https://segmentfault.com/a/1190000007637735" target="_blank" rel="noopener">https://segmentfault.com/a/1190000007637735</a><br><a href="https://github.com/creeperyang/blog/issues/23" target="_blank" rel="noopener">https://github.com/creeperyang/blog/issues/23</a><br><a href="https://www.nginx.com/blog/nginx-1-9-5/" target="_blank" rel="noopener">https://www.nginx.com/blog/nginx-1-9-5/</a><br><a href="https://ye11ow.gitbooks.io/http2-explained/content/part6.html" target="_blank" rel="noopener">https://ye11ow.gitbooks.io/http2-explained/content/part6.html</a></p>]]></content>
    
    <summary type="html">
    
      如果说有一个黑科技不用开发改代码、不用额外买服务，就能直接提升网络开启速度，这是什么呢？
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="大牛之路" scheme="http://yoursite.com/tags/%E5%A4%A7%E7%89%9B%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="http协议" scheme="http://yoursite.com/tags/http%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>centos 7里安装zsh来提升shell的高逼格</title>
    <link href="http://yoursite.com/2018/03/15/centos-7%E9%87%8C%E5%AE%89%E8%A3%85zsh%E6%9D%A5%E6%8F%90%E5%8D%87shell%E7%9A%84%E9%AB%98%E9%80%BC%E6%A0%BC/"/>
    <id>http://yoursite.com/2018/03/15/centos-7里安装zsh来提升shell的高逼格/</id>
    <published>2018-03-15T13:52:13.000Z</published>
    <updated>2018-03-16T16:14:04.871Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="zsh本体的安装">zsh本体的安装</span></h2><p>先用<code>chsh -l</code>查看当前的bash情况，如下：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   [root@zabbix ~]# chsh -l</span><br><span class="line">/bin/sh</span><br><span class="line">/bin/bash</span><br><span class="line">/sbin/nologin</span><br><span class="line">/bin/dash</span><br><span class="line">/bin/tcsh</span><br><span class="line">/bin/csh</span><br><span class="line">/usr/bin/tmux</span><br><span class="line">[root@zabbix ~]#</span><br></pre></td></tr></table></figure></p><p>如果是centos的话，使用<code>yum install -y zsh</code>来安装zsh，装完了zsh然后就是装<code>oh my zsh</code>，使用<code>wget</code>方法安装：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https:<span class="comment">//github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh</span></span><br></pre></td></tr></table></figure></p><p>再使用<code>which zsh</code>查看安装的zsh在<code>/usr/bin/zsh</code>，这个时候使用<code>chsh -s /usr/bin/zsh</code>，出现了<code>Shell changed.</code>这样就切换到了zsh界面，需要logout退出连接重进。</p><p>重新连接就会发现bash界面就变了，原本是路径的地方变成了一个小图标。界面主题是可以变化的，比如我个人比较喜欢<code>af-magic</code>这个模板，于是乎就把/root/.zshrc里的<code>ZSH_THEME=&quot;robbyrussell&quot;</code>改成<code>ZSH_THEME=&quot;af-magic&quot;</code>，保存文件，再一次退出连接重新进入就能看见模板变化了。</p><p>如果在使用vim的时候发现了tab键的补全爆错_arguments:451: _vim_files: function definition file not found，如下图：<br><img src="/images/zsh2.png" alt="paradin"></p><p>这个时候需要把/root/.zcompdump改一个名字，比如叫.zcompdump-bak，然后重新ssh连接即可。</p><h2><span id="autojump插件安装">autojump插件安装</span></h2><p>autojump这个插件安装之后，zsh会自动记录你访问过的目录，通过<code>j + 目录名</code>可以直接进行目录跳转，而且目录名支持模糊匹配和自动补全，例如你访问过<code>hadoop-1.0.0</code>目录，输入<code>j hado</code>即可正确跳转。<code>j –s</code>可以看你的历史路径库，安装方法如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git:<span class="comment">//github.com/joelthelion/autojump.git</span></span><br></pre></td></tr></table></figure></p><p>然后在autojump目录里执行<code>./install.sh</code>，此时屏幕会出现如下的显示：<br><img src="/images/zshautojump.png" alt="paradin"></p><p>把上面那个<code>[[ -s /root/.autojump/etc/profile.d/autojump.sh ]] &amp;&amp; source /root/.autojump/etc/profile.d/autojump.sh autoload -U compinit &amp;&amp; compinit -u复</code>制到<code>/root/.zshrc</code>的文件里，最好复制在<code>source $ZSH/oh-my-zsh.sh</code>这句话上面，保存之后<code>source ~/.zshrc</code>即可。</p><h2><span id="zsh-syntax-highlighting插件安装">zsh-syntax-highlighting插件安装</span></h2><p>这个插件安装之后主要效果就是命令高亮，如果是错误的命令，颜色是红色，正确的命令是绿色的，安装方法如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd .oh-my-zsh/plugins</span><br><span class="line">yum install -y git  #如果已经安装了git就不用执行的</span><br><span class="line">git clone git:<span class="comment">//github.com/zsh-users/zsh-syntax-highlighting.git</span></span><br><span class="line">source /root/.oh-my-zsh/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh添加到 .zshrc 的最后面</span><br><span class="line">source ~<span class="regexp">/.zshrc</span></span><br></pre></td></tr></table></figure></p><p>效果立竿见影。</p><h2><span id="尾声">尾声</span></h2><p>至此，你现在的zsh应该具备如下几个特性：<br>1、各种补全：路径补全、命令补全，命令参数补全，插件内容补全等等。触发补全只需要按一下或两下tab键，补全项可以使用ctrl+n/p/f/b上下左右切换。比如你想杀掉java的进程，只需要输入kill java + tab键，如果只有一个java进程，zsh会自动替换为进程的pid，如果有多个则会出现选择项供你选择。ssh + 空格 + 两个tab键，zsh会列出所有访问过的主机和用户名进行补全；<br>2、即使你没有安装autojump，只要输入d，就会列出你在这个回话中访问的目录，输入前面的序号，就可以直接跳转；<br>3、可以忽略cd命令, 输入..或者…和当前目录名都可以跳转；<br>当然，除了上面几点，zsh还有很多丰富的插件可以使用，这就需要继续的探索了…</p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="noopener">https://github.com/robbyrussell/oh-my-zsh</a><br><a href="http://macshuo.com/?p=676" target="_blank" rel="noopener">http://macshuo.com/?p=676</a></p>]]></content>
    
    <summary type="html">
    
      生命在于折腾...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="运维技术" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4%E6%8A%80%E6%9C%AF/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>安装vim8.0的过程</title>
    <link href="http://yoursite.com/2018/03/14/%E5%AE%89%E8%A3%85vim8-0%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/03/14/安装vim8-0的过程/</id>
    <published>2018-03-14T13:44:45.000Z</published>
    <updated>2018-03-14T14:47:20.609Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>1.先卸载老的vim<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove vim-* -y</span><br></pre></td></tr></table></figure></p><p>2.下载第三方yum源<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -P /etc/yum.repos.d/  https:<span class="comment">//copr.fedorainfracloud.org/coprs/mcepl/vim8/repo/epel-7/mcepl-vim8-epel-7.repo</span></span><br></pre></td></tr></table></figure></p><p>3.安装vim<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install vim-enhanced</span><br></pre></td></tr></table></figure></p><p>4.验证vim版本<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa |grep vim</span><br><span class="line">vim-enhanced<span class="number">-8.0</span><span class="number">.0704</span><span class="number">-1.1</span><span class="number">.26</span>.el7.centos.x86_64</span><br><span class="line">vim-common<span class="number">-8.0</span><span class="number">.0704</span><span class="number">-1.1</span><span class="number">.26</span>.el7.centos.x86_64</span><br><span class="line">vim-minimal<span class="number">-8.0</span><span class="number">.0704</span><span class="number">-1.1</span><span class="number">.26</span>.el7.centos.x86_64</span><br><span class="line">vim-filesystem<span class="number">-8.0</span><span class="number">.0704</span><span class="number">-1.1</span><span class="number">.26</span>.el7.centos.x86_64</span><br></pre></td></tr></table></figure></p><p><img src="/images/huojin.png" alt="paradin" title="霍金与长者"></p>]]></content>
    
    <summary type="html">
    
      不知道发生了啥就把vim搞坏了，只能重装...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="运维技术" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4%E6%8A%80%E6%9C%AF/"/>
    
      <category term="编辑器" scheme="http://yoursite.com/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>使用expect来实现远程登录ssh</title>
    <link href="http://yoursite.com/2018/03/14/%E4%BD%BF%E7%94%A8expect%E6%9D%A5%E5%AE%9E%E7%8E%B0%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95ssh/"/>
    <id>http://yoursite.com/2018/03/14/使用expect来实现远程登录ssh/</id>
    <published>2018-03-14T13:39:49.000Z</published>
    <updated>2018-03-14T20:20:09.572Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="先说说shebang">先说说shebang</span></h2><p>我们在写一个<code>shell</code>脚本时，总是习惯在最前面加上一行<code>#!/bin/bash</code>,这个就是脚本的<code>shebang</code>,可以把它理解成是一种解释器。至于为什么叫这么个奇怪的名字，C语言和Unix的开发者Dennis Ritchie称它为可能是类似于“hash-bang”的英国风描述性文字；</p><p>贴一段wiki上的解释:</p><blockquote><p>在计算机科学中，shebang是一个由井号和叹号构成的字符串行，其出现在文本文件的第一行的前两个字符。 在文件中存在shebang的情况下，类unix操作系统的程序载入器会分析shebang后的内容，将这些内容作为解释器指令，并调用该指令，并将载有shebang的文件路径作为该解释器的参数。</p></blockquote><p>简单的说，它指示了此脚本运行时的解释器，所以，使用文件名直接执行shell脚本时，必须带上这个<code>shebang</code>; 此外，我们还可以在<code>shebang</code>后面直接附加选项，执行时默认使用选项执行；</p><p>比如<code>test.sh</code>的<code>shebang</code>为<code>#!/bin/sh -x</code>，那我们执行脚本时:<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./test.sh hello</span><br></pre></td></tr></table></figure></p><p>相当于：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/sh -x ./test.sh hello;</span><br></pre></td></tr></table></figure></p><p>而expect编写的脚本，需要用到的shebang为<code>/usr/bin/expect</code>;</p><p>需要注意的是：在指定脚本解释器来执行脚本时，<code>shebang</code>会被指定的脚本解释器覆盖，即优先使用指定的脚本解释器来执行脚本（习惯性地用<code>sh ./test.sh</code>却提示<code>command not found</code>）</p><h2><span id="实例脚本">实例脚本</span></h2><p>expect的具体语法我这里就不说了，看一下下面的参考资料就好了。其实说来说去，就是根据命令栏上的反馈来输入对应的内容，举一个ssh登陆的例子。如图:<br><img src="/images/expectssh.png" alt="paradin"></p><p>从这个我们非常熟悉的ssh登陆的过程就看到，在登陆的时候，页面会返回几个交互的问题，而我们就可以针对这几个问题的关键字来输入答案。最后也根据“Welcome”这个关键字认为我们已经登陆成功了，这样就直接在连接的服务器里操作命令。</p><p>于是根据这个思路，来写一个远程ssh到A机器上的脚本：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/expect -f</span></span><br><span class="line"></span><br><span class="line">set timeout 30        #设定超时时间是30秒，如果是-1那就是永不超时</span><br><span class="line">spawn ssh root@A服务器IP地址        #这里开始ssh连接到目标服务器上</span><br><span class="line"></span><br><span class="line">expect &#123;</span><br><span class="line">  "*(yes/no)?" &#123;    #如果是第一次连接，那么命令栏里就会出现(yes/no)的字样</span><br><span class="line">     send "yes\r"    #此时匹配yes</span><br><span class="line">     expect "*password:" &#123;send "服务器密码\r"&#125;    #如果命令栏出现了password的字样，直接填写密码</span><br><span class="line">   &#125;</span><br><span class="line">      "*password:" &#123;send "服务器密码\r"&#125;        #如果不是第一次连接，那么就会直接出现password，所以可以直接填写密码</span><br><span class="line">&#125;</span><br><span class="line">expect "*Welcome*"    #连接成功就会出现welcome的字样</span><br><span class="line">send "echo '我就是你的爹地' &gt;&gt; /tmp/123321.txt\r"        #此时执行第一个命令</span><br><span class="line">send "df -h\r"        #执行第二个命令</span><br><span class="line">send "cp /tmp/123321.txt /tmp/123123.txt\r"        #执行第三个命令</span><br><span class="line">interact     #脚本fork的子进程会将操作权交给用户，允许用户与当前A服务器的shell进行交互</span><br></pre></td></tr></table></figure></p><h2><span id="参考资料">参考资料</span></h2><p><a href="http://blog.sctux.com/?p=343" target="_blank" rel="noopener">http://blog.sctux.com/?p=343</a><br><a href="http://www.zyy1217.com/2017/07/02/linux%20expect%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener">http://www.zyy1217.com/2017/07/02/linux%20expect%E8%AF%A6%E8%A7%A3/</a><br><a href="https://github.com/jiangxianli/SSHAutoLogin" target="_blank" rel="noopener">https://github.com/jiangxianli/SSHAutoLogin</a><br><a href="https://peiqiang.net/2014/05/10/ssh-auto-login.html" target="_blank" rel="noopener">https://peiqiang.net/2014/05/10/ssh-auto-login.html</a><br><a href="https://www.jianshu.com/p/9bee08dc3dca" target="_blank" rel="noopener">https://www.jianshu.com/p/9bee08dc3dca</a></p>]]></content>
    
    <summary type="html">
    
      题外话一下，加权最少连接，算法为：（活动连接数*256+非活动连接数）÷权重，计算出来的值小的服务器优先被选择。
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="运维技术" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4%E6%8A%80%E6%9C%AF/"/>
    
      <category term="expect" scheme="http://yoursite.com/tags/expect/"/>
    
  </entry>
  
  <entry>
    <title>使用python去做一个生成随机码的页面</title>
    <link href="http://yoursite.com/2018/03/13/%E4%BD%BF%E7%94%A8python%E5%8E%BB%E5%81%9A%E4%B8%80%E4%B8%AA%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E7%A0%81%E7%9A%84%E9%A1%B5%E9%9D%A2/"/>
    <id>http://yoursite.com/2018/03/13/使用python去做一个生成随机码的页面/</id>
    <published>2018-03-13T13:41:28.000Z</published>
    <updated>2018-03-13T13:43:55.500Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="先说一下mkpasswd">先说一下mkpasswd</span></h2><p>linux里是自带生成密码的命令的，比较出名的一个是<code>mkpasswd</code>，另一个是<code>passwdgen</code>。</p><p><code>mkpasswd</code>命令是附属在<code>expect</code>模块里的，如图<br><img src="/images/mkpasswd.png" alt="paradin" title="使用yum whatprovides */mkpasswd去查找依附yum包"></p><p><code>passwdgen</code>的话也要手动执行一下<code>yum install -y passwdgen</code>来安装命令。</p><p>这里主要说说<code>mkpasswd</code>，它支持如下几个参数：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-l       (length <span class="keyword">of</span> password, <span class="keyword">default</span> = <span class="number">7</span>)        指定密码的长度，默认是<span class="number">7</span>位数</span><br><span class="line">-d       (min # of digits, default = 2)           指定密码中数字最少位数，默认是2位</span><br><span class="line">-c       (min # of lowercase chars, default = 2)  指定密码中小写字母最少位数，默认是2位</span><br><span class="line">-C       (min # of uppercase chars, default = 2)  指定密码中大写字母最少位数，默认是2位</span><br><span class="line">-s       (min # of special chars, default = 1)    指定密码中特殊字符最少位数，默认是1位</span><br></pre></td></tr></table></figure></p><p>比如现在要生成一个含有“六位数字而且5位特殊字符的总共16位”的密码，那么命令就是：<code>mkpasswd -l 16 -d 5 -s 5</code>，再聚几个其他的例子，感受一下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@zabbix General_LeChange_Chn_IS_V5.8.00.R.20170814]# mkpasswd -l 16 -d 5 -s 5</span><br><span class="line">g]<span class="number">7</span>Hu-L5,t+<span class="number">32</span>%<span class="number">0</span>m</span><br><span class="line">[root@zabbix General_LeChange_Chn_IS_V5.8.00.R.20170814]# mkpasswd -l 16 -C 5</span><br><span class="line">YvjtFWaV5jr8h%Wy</span><br><span class="line">[root@zabbix General_LeChange_Chn_IS_V5.8.00.R.20170814]# mkpasswd -l 16 -s 10</span><br><span class="line">qoB#^V_=/!??*59:</span><br><span class="line">[root@zabbix General_LeChange_Chn_IS_V5.8.00.R.20170814]# mkpasswd -l 16 -c 4 </span><br><span class="line"><span class="number">9</span>mJOqymatvg*n9sl</span><br></pre></td></tr></table></figure></p><h2><span id="脚本在此">脚本在此</span></h2><p>这个生成随机码的算法部分就使用上面那个<code>mkpasswd</code>了，省了我们不少事。</p><p>整个html界面的代码如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">"utf-8"</span>&gt;</span><br><span class="line">&lt;title&gt;随机密码生成器&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form action=<span class="string">"/cgi-bin/dropdown.py"</span> method=<span class="string">"post"</span> target=<span class="string">"_blank"</span>&gt;</span><br><span class="line">&lt;select name=<span class="string">"dropdown"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;h2&gt;密码长度：&lt;<span class="regexp">/h2&gt;&lt;option value="8" selected&gt;8&lt;/</span>option&gt;</span><br><span class="line">&lt;option value=<span class="string">"16"</span>&gt;<span class="number">16</span>&lt;<span class="regexp">/option&gt;</span></span><br><span class="line"><span class="regexp">&lt;option value="20"&gt;20&lt;/</span>option&gt;</span><br><span class="line">&lt;option value=<span class="string">"24"</span>&gt;<span class="number">24</span>&lt;<span class="regexp">/option&gt;</span></span><br><span class="line"><span class="regexp">&lt;option value="48"&gt;48&lt;/</span>option&gt;</span><br><span class="line">&lt;<span class="regexp">/select&gt; &lt;br /</span>&gt;</span><br><span class="line">&lt;input type=<span class="string">"checkbox"</span> name=<span class="string">"runoob"</span> value=<span class="string">"on"</span> /&gt; 包含小写字母 &lt;br /&gt;</span><br><span class="line">&lt;input type=<span class="string">"checkbox"</span> name=<span class="string">"google"</span> value=<span class="string">"on"</span> /&gt; 包含大写字母 &lt;br /&gt;</span><br><span class="line">&lt;input type=<span class="string">"checkbox"</span> name=<span class="string">"runoob"</span> value=<span class="string">"on"</span> /&gt; 包含数字 &lt;br /&gt;</span><br><span class="line">&lt;input type=<span class="string">"checkbox"</span> name=<span class="string">"google"</span> value=<span class="string">"on"</span> /&gt; 包含特殊字母 &lt;br /&gt;</span><br><span class="line">&lt;input type=<span class="string">"submit"</span> value=<span class="string">"提交"</span>/&gt; &lt;br /&gt;</span><br><span class="line">&lt;h2&gt;密码：&lt;/h2&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure></p><h2><span id="补充">补充</span></h2><p>再分享一个python生成密码的代码，但是这个密码不含特殊字符：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line">salt = <span class="string">''</span>.join(random.sample(string.ascii_letters + string.digits, <span class="number">8</span>))</span><br><span class="line">print salt</span><br></pre></td></tr></table></figure></p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://balajiommudali.wordpress.com/2015/11/27/unable-to-install-mkpasswd-on-centos-6-4/" target="_blank" rel="noopener">https://balajiommudali.wordpress.com/2015/11/27/unable-to-install-mkpasswd-on-centos-6-4/</a><br><a href="http://www.runoob.com/python/python-cgi.html" target="_blank" rel="noopener">http://www.runoob.com/python/python-cgi.html</a></p>]]></content>
    
    <summary type="html">
    
      明天把这篇文章全部写完
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>记一次mysql无法启动的解决过程</title>
    <link href="http://yoursite.com/2018/03/12/%E8%AE%B0%E4%B8%80%E6%AC%A1mysql%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%E7%9A%84%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/03/12/记一次mysql无法启动的解决过程/</id>
    <published>2018-03-12T13:35:15.000Z</published>
    <updated>2018-03-12T13:45:39.226Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="正文">正文</span></h2><p>今天开发人员反馈一个问题，就是某一台开发环境机器的mysql无法启动了，但是如果这台服务器重启的话，mysql就好使，而第二天就会出现mysql死掉然后无法启动的情况。我使用<code>service mysqld restart</code>，命令行反馈如下的内容：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2373j9xivZ data]# service mysqld restart</span><br><span class="line">MySQL server PID file could not be found!                  [FAILED]    </span><br><span class="line">Starting MySQL........The server quit without updating PID file (<span class="regexp">/data/my</span>sql/data/sock/mysql.pid).                                                         [FAILED]</span><br></pre></td></tr></table></figure></p><p>打开错误日志看一下，里面是这么写的：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-10</span> <span class="number">00</span>:<span class="number">26</span>:<span class="number">24</span> <span class="number">25919</span> [Note] InnoDB: Using CPU crc32 instructions</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-10</span> <span class="number">00</span>:<span class="number">26</span>:<span class="number">24</span> <span class="number">25919</span> [Note] InnoDB: Initializing buffer pool, size = <span class="number">4.0</span>G</span><br><span class="line">InnoDB: mmap(<span class="number">549453824</span> bytes) failed; errno <span class="number">12</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-10</span> <span class="number">00</span>:<span class="number">26</span>:<span class="number">24</span> <span class="number">25919</span> [ERROR] InnoDB: Cannot allocate memory <span class="keyword">for</span> the buffer pool</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-10</span> <span class="number">00</span>:<span class="number">26</span>:<span class="number">24</span> <span class="number">25919</span> [ERROR] Plugin <span class="string">'InnoDB'</span> init <span class="function"><span class="keyword">function</span> <span class="title">returned</span> <span class="title">error</span>.</span></span><br><span class="line">2018-03-10 00:26:24 25919 [ERROR] Plugin 'InnoDB' registration as a STORAGE ENGINE failed.</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-10</span> <span class="number">00</span>:<span class="number">26</span>:<span class="number">24</span> <span class="number">25919</span> [ERROR] Unknown/unsupported storage engine: INNODB</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-10</span> <span class="number">00</span>:<span class="number">26</span>:<span class="number">24</span> <span class="number">25919</span> [ERROR] Aborting</span><br></pre></td></tr></table></figure></p><p>爆<code>InnoDB: mmap(549453824 bytes) failed; errno 12</code>，然后我就<code>free -m</code>查看一下，当前服务器的内存已经不够用了。<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2373j9xivZ sock]# free -m</span><br><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line">Mem:          <span class="number">7869</span>       <span class="number">7747</span>        <span class="number">121</span>          <span class="number">0</span>         <span class="number">16</span>         <span class="number">15</span></span><br><span class="line">-<span class="regexp">/+ buffers/</span>cache:       <span class="number">7716</span>        <span class="number">152</span></span><br><span class="line">Swap:            <span class="number">0</span>          <span class="number">0</span>          <span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>那么是什么在占用这台服务器的内存？使用<code>ps aux | sort -k4nr |head -5</code> 这个命令查找当前占用内存最大的五个进程一看，全是<code>php-fpm</code>，同时也发现服务器里面运行大量的<code>php-fpm</code>，在征得开发人员的同意之后，重启<code>php-fpm</code>进程，内存空出来很多。</p><p>此时再次<code>service mysqld restart</code>，发现mysql的错误日志改成如下的样子了：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-12</span> <span class="number">10</span>:<span class="number">53</span>:<span class="number">42</span> <span class="number">28238</span> [Note] InnoDB: Highest supported file format is Barracuda.</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-12</span> <span class="number">10</span>:<span class="number">53</span>:<span class="number">42</span> <span class="number">28238</span> [Note] InnoDB: The log sequence numbers <span class="number">16939991440</span> and <span class="number">16939991440</span> <span class="keyword">in</span> ibdata files <span class="keyword">do</span> not match the log sequence number <span class="number">16940121908</span> <span class="keyword">in</span> the ib_logfiles!</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-12</span> <span class="number">10</span>:<span class="number">53</span>:<span class="number">42</span> <span class="number">28238</span> [Note] InnoDB: Database was not shutdown normally!</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-12</span> <span class="number">10</span>:<span class="number">53</span>:<span class="number">42</span> <span class="number">28238</span> [Note] InnoDB: Starting crash recovery.</span><br></pre></td></tr></table></figure></p><p>这次变成了<code>The log sequence numbers 16939991440 and 16939991440 in ibdata files do not match the log sequence number 16940121908 in the ib_logfiles!</code>，我打开<code>my.cnf</code>，适当的调小了<code>max_connections</code>和<code>innodb_buffer_pool_size</code>，然后<code>service mysqld restart</code>的时候发现错误又变了：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-12</span> <span class="number">11</span>:<span class="number">03</span>:<span class="number">57</span> <span class="number">29190</span> [Note] InnoDB: <span class="number">5.6</span><span class="number">.27</span> started; log sequence number <span class="number">16940121918</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-12</span> <span class="number">11</span>:<span class="number">03</span>:<span class="number">57</span> <span class="number">29190</span> [Note] Server hostname (bind-address): <span class="string">'*'</span>; port: <span class="number">3306</span></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-12</span> <span class="number">11</span>:<span class="number">03</span>:<span class="number">57</span> <span class="number">29190</span> [Note] IPv6 is not available.</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-12</span> <span class="number">11</span>:<span class="number">03</span>:<span class="number">57</span> <span class="number">29190</span> [Note]   - <span class="string">'0.0.0.0'</span> resolves to <span class="string">'0.0.0.0'</span>;</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-12</span> <span class="number">11</span>:<span class="number">03</span>:<span class="number">57</span> <span class="number">29190</span> [Note] Server socket created on IP: <span class="string">'0.0.0.0'</span>.</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-12</span> <span class="number">11</span>:<span class="number">03</span>:<span class="number">57</span> <span class="number">29190</span> [ERROR] Can<span class="string">'t start server : Bind on unix socket: Permission denied    </span></span><br><span class="line"><span class="string">2018-03-12 11:03:57 29190 [ERROR] Do you already have another mysqld server running on socket: /data/mysql/data/sock/mysql.sock ?</span></span><br><span class="line"><span class="string">2018-03-12 11:03:57 29190 [ERROR] Aborting</span></span><br></pre></td></tr></table></figure></p><p>这就是文件权限问题了，我再次打开<code>my.cnf</code>发现里面的<code>user</code>填写的是<code>mysql</code>，那么把<code>/data/mysql/data/sock/mysql.sock</code>这一系列的文件的所属人都改成了<code>mysql</code>用户，这一次重启mysql就OK了。</p><p>为什么这个<code>mysql</code>会好好的突然自动死掉呢？我发现日志里面有这样的字样：<code>InnoDB: Database was not shutdown normally!</code>，于是我猜想很有可能是<code>php-fpm</code>这进程不断地增长，占用的内存太大，导致<code>mysql</code>被<code>linux</code>的内核杀死了。于是查看<code>/var/log/message</code>的文件，结合mysql的错误日志时间找到了如下的字样：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Mar <span class="number">10</span> <span class="number">00</span>:<span class="number">26</span>:<span class="number">22</span> iZ2373j9xivZ kernel: Out <span class="keyword">of</span> memory: Kill process <span class="number">1883</span> (mysqld) score <span class="number">53</span> or sacrifice child</span><br><span class="line">Mar <span class="number">10</span> <span class="number">00</span>:<span class="number">26</span>:<span class="number">22</span> iZ2373j9xivZ kernel: Killed process <span class="number">1883</span>, UID <span class="number">501</span>, (mysqld) total-vm:<span class="number">6849508</span>kB, anon-rss:<span class="number">429368</span>kB, file-rss:<span class="number">176</span>kB</span><br><span class="line">Mar <span class="number">10</span> <span class="number">04</span>:<span class="number">11</span>:<span class="number">38</span> iZ2373j9xivZ kernel: php-fpm invoked oom-killer: gfp_mask=<span class="number">0x201da</span>, order=<span class="number">0</span>, oom_adj=<span class="number">0</span>, oom_score_adj=<span class="number">0</span></span><br><span class="line">Mar <span class="number">10</span> <span class="number">04</span>:<span class="number">11</span>:<span class="number">38</span> iZ2373j9xivZ kernel: php-fpm cpuset=<span class="regexp">/ mems_allowed=0</span></span><br><span class="line"><span class="regexp">Mar 10 04:11:38 iZ2373j9xivZ kernel: Pid: 4375, comm: php-fpm Not tainted 2.6.32-431.23.3.el6.x86_64 #1</span></span><br></pre></td></tr></table></figure></p><p>证据确凿，<code>php-fpm</code>的无休止增长导致服务器的可用内存变小，最后内核把<code>mysql</code>杀死，修改<code>php-fpm</code>的文件之后，暂时好了点…</p><h2><span id="参考资料">参考资料</span></h2><p><a href="http://robinchen.me/tech/2016/03/14/tech-aliyun-centos-mysql-shutdown-itself-irregularly.html" target="_blank" rel="noopener">http://robinchen.me/tech/2016/03/14/tech-aliyun-centos-mysql-shutdown-itself-irregularly.html</a></p>]]></content>
    
    <summary type="html">
    
      一次启动，三个问题
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="运维技术" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>关于HTTP-Alive应该知道的事</title>
    <link href="http://yoursite.com/2018/03/11/%E5%85%B3%E4%BA%8EHTTP-Alive%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8B/"/>
    <id>http://yoursite.com/2018/03/11/关于HTTP-Alive应该知道的事/</id>
    <published>2018-03-11T03:23:08.000Z</published>
    <updated>2018-03-12T14:44:15.387Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="总体概述">总体概述</span></h2><p>七层协议是一个广为人知的协议，<code>tcp</code>协议是在传输层，<code>http</code>协议是在应用层，也就是说客户端与服务器端先建立<code>tcp</code>连接，然后在<code>tcp</code>连接的基础上传送<code>http</code>报文。</p><p><code>http</code>协议是一个<code>请求-应答</code>的模式，也就是当没有启动<code>keep-alive</code>的时候，每一次建立<code>http</code>连接都是<code>现用现建立，用完就断开</code>的工作样式。而如果开启了<code>keep-alive</code>模式的话，客户端和服务器之间<code>http</code>连接就会被保持，不会断开（超过<code>Keep-Alive</code>规定的时间，意外断电等情况除外），当客户端发送另外一个请求时，就使用这条已经建立的连接。</p><p><code>Keep-Alive</code>的规定时间在客户端（浏览器里）是如何确定的呢？例如<code>Keep-Alive: timeout=5, max=100</code>，表示这个<code>TCP</code>通道可以保持5秒，<code>max=100</code>表示这个长连接最多接收100次请求就断开。</p><p><code>Keep-alive</code>在<code>http 1.1</code>版本里是默认开启的，只有加入<code>Connection: close</code>才会关闭，现在大部分浏览器都是使用<code>http 1.1</code>协议，所以说在客户端已经是默认发起<code>keep-alive</code>的连接请求。但是能否会完成一个完整的<code>keep-alive</code>还要看服务器端的具体配置情况。</p><p>在<code>nginx</code>里就直接支持<code>keepalive_timeout</code>指令，其使用0值来停用<code>keep-alive</code>，举例配置如下:<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location /XXX/ &#123;   </span><br><span class="line">   alias /url/<span class="keyword">var</span>/www/html/;   </span><br><span class="line">   keepalive_timeout  <span class="number">75</span>;  </span><br><span class="line">   expires <span class="number">5</span>m;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用长连接之后，客户端和服务端怎么知道本次传输结束呢？两部分：1. 判断传输数据是否达到了<code>Content-Length</code>指示的大小，这个是最简单的最傻瓜的，普遍应用于静态的图片或者页面；2. 往往动态生成的文件没有<code>Content-Length</code>，它是分块传输<code>（chunked）</code>，这时候怎么办呢？就要根据<code>chunked</code>编码来判断，<code>chunked</code>编码的数据在最后有一个空<code>chunked</code>块，表明本次传输数据结束，这种情况更多应用于动态的页面。</p><h2><span id="进一步的说chunked">进一步的说chunked</span></h2><p>HTTP请求报文的格式是这样的：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;method&gt; &lt;request-URL&gt; &lt;version&gt;</span><br><span class="line">&lt;headers&gt;</span><br><span class="line"></span><br><span class="line">&lt;entity-body&gt;</span><br></pre></td></tr></table></figure></p><p>其中在请求头的地方有一个叫<code>Content-Length</code>的字段，如果没有这个字段那么就会有叫<code>Transfer-encoding</code>的字段，它用来表示<code>http</code>报文的传输格式，这个字段的取值有很多，但是真正有意义的只有一个—<code>chunked</code>。</p><p>如果一个<code>HTTP</code>消息（请求消息或应答消息）的<code>Transfer-Encoding</code>消息头的值为<code>chunked</code>，那么，消息体由数量未定的块组成，并以最后一个大小为0的块为结束。</p><p>每一个非空的块都以该块包含数据的字节数（字节数以十六进制表示）开始，跟随一个<code>CRLF</code>（回车及换行），然后是数据本身，最后块<code>CRLF</code>结束。在一些实现中，块大小和<code>CRLF</code>之间填充有白空格（0x20）。</p><p>最后一块是单行，由块大小（0）、一些可选的填充白空格、以及<code>CRLF</code>组成。最后一块不再包含任何数据，但是可以发送可选的尾部，包括消息头字段。消息最后以<code>CRLF</code>结尾。</p><p>注意1.<code>chunked</code>和<code>multipart</code>两个名词在意义上有类似的地方，不过在<code>HTTP</code>协议当中这两个概念则不是一个类别的。<code>multipart</code>是一种<code>Content-Type</code>，标示<code>HTTP</code>报文内容的类型，而<code>chunked</code>是一种传输格式，标示报头将以何种方式进行传输；</p><p>注意2.<code>chunked</code>传输不能事先知道内容的长度，只能靠最后的空<code>chunk</code>块来判断，因此对于下载请求来说，是没有办法实现进度的。在浏览器和下载工具中，偶尔我们也会看到有些文件是看不到下载进度的，即采用<code>chunked</code>方式进行下载；</p><p>注意3.<code>chunked</code>的优势在于，服务器端可以边生成内容边发送，无需事先生成全部的内容。<code>HTTP/2</code>不支持<code>Transfer-Encoding: chunked</code>，因为<code>HTTP/2</code>有自己的<code>streaming</code>传输方式。</p><h2><span id="http-keep-alive与tcp-keep-alive">http keep-alive与tcp keep-alive</span></h2><p>http的<code>keep-alive</code>与tcp的<code>keep-alive</code>可不是同一回事，意图也不一样。http的<code>keep-alive</code>是为了让tcp活得更久一点，以便在同一个连接上传送多个http，提高<code>socket</code>的效率。而tcp的<code>keep-alive</code>是tcp的一种检测tcp连接状况的保鲜机制。tcp的<code>keep-alive</code>是一个保鲜定时器，支持三个系统内核配置参数：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="number">1800</span> &gt; <span class="regexp">/proc/</span>sys/net/ipv4/tcp_keepalive_time</span><br><span class="line">echo <span class="number">15</span> &gt; <span class="regexp">/proc/</span>sys/net/ipv4/tcp_keepalive_intvl</span><br><span class="line">echo <span class="number">5</span> &gt; <span class="regexp">/proc/</span>sys/net/ipv4/tcp_keepalive_probes</span><br></pre></td></tr></table></figure></p><p><code>keepalive</code>是TCP保鲜定时器，当网络两端建立了tcp连接之后，闲置idle（双方没有任何数据流发送往来）了<code>tcp_keepalive_time</code>后，服务器内核就会尝试向客户端发送侦测包，来判断TCP连接状况(有可能客户端崩溃、强制关闭了应用、主机不可达等等)。如果没有收到对方的回答(ack包)，则会在<code>tcp_keepalive_intvl</code>后再次尝试发送侦测包，直到收到对对方的<code>ack</code>,如果一直没有收到对方的<code>ack</code>,一共会尝试<code>tcp_keepalive_probes</code>次，每次的间隔时间在这里分别是<code>15s、30s、45s、60s、75s</code>。如果尝试<code>tcp_keepalive_probe</code>s,依然没有收到对方的ack包，则会丢弃该TCP连接。TCP连接默认闲置时间是2小时，一般设置为30分钟足够了。</p><p>也就是说，仅当<code>nginx</code>的<code>keepalive_timeout</code>值设置高于<code>tcp_keepalive_time</code>，并且距此tcp连接传输的最后一个<code>http</code>响应，经过了<code>tcp_keepalive_time</code>时间之后，操作系统才会发送侦测包来决定是否要丢弃这个TCP连接。一般不会出现这种情况，除非你需要这样做。</p><h2><span id="keep-alive与time_wait">keep-alive与TIME_WAIT</span></h2><p>使用http的<code>keep-alive</code>，可以减少服务端<code>TIME_WAIT</code>数量(因为由服务端<code>httpd</code>守护进程主动关闭连接)。道理很简单，相较而言，启用<code>keep-alive</code>，建立的<code>tcp</code>连接更少了，自然要被关闭的<code>tcp</code>连接也相应更少了。</p><h2><span id="补充">补充</span></h2><p>建议在服务器提供Web站点服务时(一个页面除了动态内容，还包含非常多的JS、图片、css文件等)开启keep-alive。在“服务器提供的是一个接口服务，除了动态内容，几乎没有引用任何静态内容”这样的场景，不建议开启<code>keep-alive</code>。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="http://www.cnblogs.com/skynet/archive/2010/12/11/1903347.html" target="_blank" rel="noopener">http://www.cnblogs.com/skynet/archive/2010/12/11/1903347.html</a><br><a href="https://hit-alibaba.github.io/interview/basic/network/HTTP.html" target="_blank" rel="noopener">https://hit-alibaba.github.io/interview/basic/network/HTTP.html</a><br><a href="http://51write.github.io/2014/04/09/keepalive/" target="_blank" rel="noopener">http://51write.github.io/2014/04/09/keepalive/</a><br><a href="http://www.nowamagic.net/academy/detail/23350305" target="_blank" rel="noopener">http://www.nowamagic.net/academy/detail/23350305</a></p>]]></content>
    
    <summary type="html">
    
      HTTP是一个无状态协议，这意味着每个请求都是独立的，Keep-Alive 没能改变这个结果。
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="大牛之路" scheme="http://yoursite.com/tags/%E5%A4%A7%E7%89%9B%E4%B9%8B%E8%B7%AF/"/>
    
      <category term="http协议" scheme="http://yoursite.com/tags/http%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>ssh连接port22:Socket error Event:32 Error:10053</title>
    <link href="http://yoursite.com/2018/03/07/ssh%E8%BF%9E%E6%8E%A5port22-Socket-error-Event-32-Error-10053/"/>
    <id>http://yoursite.com/2018/03/07/ssh连接port22-Socket-error-Event-32-Error-10053/</id>
    <published>2018-03-07T10:51:31.000Z</published>
    <updated>2018-03-07T11:41:48.711Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>今天遇到了一个奇怪的现象，据开发人员反馈，有一台阿里云服务器在控制台重启了之后，发现无法登陆了。我先使用阿里云的控制台打算远程登陆到这台机器发现，远程登陆总是显示密码错误。然后我使用xshell登陆对应的外网IP和22端口的时候发现爆出如下的错误：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Connecting to X.X.X.X:<span class="number">22.</span>..</span><br><span class="line">Connection established.</span><br><span class="line">To <span class="built_in">escape</span> to local shell, press <span class="string">'Ctrl+Alt+]'</span>.</span><br><span class="line"></span><br><span class="line">Socket error Event: <span class="number">32</span> <span class="built_in">Error</span>: <span class="number">10053.</span></span><br><span class="line">Connection closing...Socket close.</span><br><span class="line"></span><br><span class="line">Connection closed by foreign host.</span><br></pre></td></tr></table></figure></p><p>这种情况很罕见，google了一下也没有对于我有用的处理办法，于是我就只好给阿里云后台发了一下工单。授权给阿里云让他们登陆一下这台机器看一下里面发生了什么，阿里云的售后人员过了一会打过电话过来说，发现这台机器里面有人操作了<code>chmod -R 777 /</code>，破坏了比如<code>/etc/passwd</code>和<code>/etc/shadow</code>的权限，所以会爆出这样的错误。如图：<br><img src="/images/7771.png" alt="paradin"></p><p>阿里的售后说他们也把几个跟登陆有关的文件暂时恢复权限，这样这个机器就可以成功登陆了，如图：<br><img src="/images/7772.png" alt="paradin"></p>]]></content>
    
    <summary type="html">
    
      刚上的堡垒机，有点磨合是肯定的...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="ssh" scheme="http://yoursite.com/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>孤儿进程和僵尸进程</title>
    <link href="http://yoursite.com/2018/03/07/%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/03/07/孤儿进程和僵尸进程/</id>
    <published>2018-03-07T08:07:35.000Z</published>
    <updated>2018-03-08T14:55:08.182Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="原理与定义">原理与定义</span></h2><p>首先要知道，<code>linux</code>有父进程和子进程这样的说法。那父进程如何创建子进程呢？<code>fork</code>。</p><p>子进程的进行和父进程的进行是异步的，但是父进程就像父母一样对自己的小孩也有一定的控制欲，这个控制欲就表现在如果子进程如果结束了，它释放了之前占用的资源、内存、文件等等，但是它还保留了一点信息：进程号PID、退出状态、运行时间等等。而这些残留信息是父进程通过<code>wait/waitpid</code>来获取，如果父进程一直不获取，那么子进程就会一直保留这些信息直到海枯石烂。</p><p><strong>孤儿进程</strong>：父进程退出，子进程继续进行，那么此时子进程就是孤儿进程。这个时候<code>init</code>进程（进程号为1）来作为子进程的监护人，发出<code>wait/waitpid</code>来完成状态收集工作；<br><img src="/images/jiangshi.png" alt="paradin" title="这个nginx的worker process就成了孤儿进程"></p><p><strong>僵尸进程</strong>：父进程没有退出，但是它迟迟不发出<code>wait/waitpid</code>来回收子进程的资源。就好比儿子死了，当爹的不给收尸，这个儿子就成了孤魂野鬼成了僵尸。</p><h2><span id="影响与危害">影响与危害</span></h2><p>孤儿进程是没有什么大的危害，虽然他虽然没有了亲生父亲，但是也有<code>init</code>进程来通过循环的<code>wait()</code>来处理它的善后工作，所以迟早会把占用的资源释放掉。</p><p>甚至有的用户可以把进程弄成孤儿进程，以使之与用户会话脱钩，并转至后台运行。这一做法常应用于启动需要长时间运行的进程，也即守护进程。另外，<code>nohup</code>命令也可以完成这一操作。</p><p>但是僵尸进程不一样，要是父进程对子进程一直不使用<code>wait/waitpid</code>，那么<code>pid</code>就会不回收，可是系统内的pid总是是有限的，这样久而久之就是对pid的一个霸占，新的进程也无法生成，这就是僵尸进程的危害。</p><h2><span id="如何处理僵尸进程">如何处理僵尸进程</span></h2><p>僵尸进程是杀不死的，怎么办？杀他爹，把父进程杀掉了，那么这些僵尸就成了孤儿进程，然后再由init收养，最后入土为安。</p><p>查看当前服务器僵尸进程的方法：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -A -o stat,ppid,pid,cmd | grep -e <span class="string">'^[Zz]'</span></span><br></pre></td></tr></table></figure></p><p>如果服务器上的僵尸进程不是出自一个父进程之手，那么就用下面这个命令批量解决：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -A -o stat,ppid,pid,cmd | grep -e <span class="string">'^[Zz]'</span> | awk <span class="string">'&#123;print $2&#125;'</span> | xargs kill <span class="number">-9</span></span><br></pre></td></tr></table></figure></p><p>但是如果父进程是init进程，那么这样的僵尸进程怎么办？答案，不用刻意管他，相信<code>init</code>的能力，它迟早会被<code>init</code>回收的，成为僵尸进程也是暂时的。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://zh.wikipedia.org/wiki/%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B</a><br><a href="https://zh.wikipedia.org/wiki/%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B</a><br><a href="http://blog.csdn.net/YuZhiHui_No1/article/details/53011390" target="_blank" rel="noopener">http://blog.csdn.net/YuZhiHui_No1/article/details/53011390</a><br><img src="/images/perfume.jpg" alt="paradin"></p>]]></content>
    
    <summary type="html">
    
      面试的时候，我在回答“僵尸进程和孤儿进程”的时候回答的很不好，于是下午就赶紧拿出来这块的资料来看，认真总结一下。
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>蚂蚁金服运维面试全纪录</title>
    <link href="http://yoursite.com/2018/03/07/%E8%9A%82%E8%9A%81%E9%87%91%E6%9C%8D%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E5%85%A8%E7%BA%AA%E5%BD%95/"/>
    <id>http://yoursite.com/2018/03/07/蚂蚁金服运维面试全纪录/</id>
    <published>2018-03-07T03:33:01.000Z</published>
    <updated>2018-03-19T07:30:44.161Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>早上接到蚂蚁金服的运维面试电话，有点突然袭击，下面是整个的面试记录。</p><p>首先，面试官先向我讲述了一下他们平时运维的工作内容，然后结合我的简历开始提问。</p><p>1）都用过我们的什么产品？<br>这一阶段老老实实、正常回答工作中所用到的阿里云产品和使用情景。</p><p>2）VPC网络有哪些好处？<br>我就答出来更加安全…面试官说其他方面呢，我就不知道了。<br>【事后补充】VPC网路的灵活性更高，可以自由定义网段划分、IP地址和路由网络。</p><p>3)一个vpc的服务器如何与外网交互？<br>我说可以改写路由或者通过<code>iptables</code>转发。</p><p>4）iptables里PREROUTING和POSTROUTING都是啥？<br><code>PREROUTING</code>处理刚到达本机并在路由转发前的数据包；<code>POSTROUTING</code>处理即将离开本机的数据包。</p><p>5）问：RDS在什么操作下会CPU飙升，任举一例？<br>答：在我实际工作中，比较明显的是在数据同步的时候会飙升。</p><p>6）RDS为什么会在DTS的时候有飙升的现象？<br>这个我答的不好，有点东拉西扯…（尴尬）</p><p>7）mysql备份的时候使用过什么参数？<br>答：<code>--skip-opt</code> 防止运行中的MYSQL锁库<br>加速数据备份的参数是什么？<br><code>-q</code> 提高导出性能<br><code>-e</code> 提高导入性能，使用包括几个<code>VALUES</code>列表的多行<code>INSERT</code>语法；<br><code>--max_allowed_packet=XXX</code> 客户端/服务器之间通信的缓存区的最大大小；<br><code>--net_buffer_length=XXX</code> TCP/IP和套接字通信缓冲区大小，创建长度达到<code>net_buffer_length</code>的行；</p><p>注意！<code>max_allowed_packet</code>和<code>net_buffer_length</code>在mysql里有参数值，不能超过参数值！<br>查看方法：<code>show variables like &#39;max_allowed_packet&#39;;</code></p><p>8）cache和buffer有什么区别？<br><code>cache</code>是缓存，弥补高速设备与低速设备的鸿沟引入的中间层，达到数据快取的目的（救火车与蓄水池）；<br><code>buffer</code>是缓冲区，用户流量整形，把大量的小的io整理一个平稳的大io，减少磁盘响应次数；<br><code>buffer</code>是即将要写入磁盘的，<code>cache</code>是要被从磁盘里读出来的。当然这只是普通用途，<code>buffer</code>用来读、<code>cache</code>用来写也是有可能的。具体问题具体分析。</p><p>9）他俩的调用有什么区别？<br>我问是要说“块读取”什么的么，面试官说是。我就蒙说cache是块读取，buffer我不清楚…（尴尬 again）<br>【事后补充】</p><p>10）谈一谈time_wait和close_wait，各自在什么情况下出现？<br><code>time_wait</code>和<code>close_wait</code>是出现在“四次挥手”的环节里，<code>time_wait</code>是服务器接收到客户端发来的断开TCP连接的请求，并且服务器发送确认断开的包给客户端，此时服务器处于<code>time_wait</code>状态，如果服务器等待两个<code>msl</code>的话，就会默认断开连接，如果想修改<code>msl</code>可以通过修改<code>/etc/systl.conf</code>文件；<br><code>close_wait</code>是客户端已经发送了断开TCP请求，但是服务器端没有接收到，也就是<code>time_wait</code>的上一步，此时这个资源就一直被程序霸占。</p><p>11）为什么time_wait需要等待两个msl?1.99行不行？2.01行不行？<br>我当时说防止上一次连接中的包，迷路后重新出现，影响新连接。面试官好像觉得不是很满意…（尴尬 again）<br>【事后补充】MSL是指一个片段在网络中的最大存活时间，2MSL是一个发送和一个回复所需的最大时间，如果直到2MSL，客户端都没有收到fin包，那么客户端就可以断定他发出去的ack已经被服务端接收，结束TCP连接。</p><p>12）说出一个你使用过的python库。<br>我说我前两天用<code>matpoltlib</code>画图，就谈了谈这个画图的库。</p><p>13）python装饰器了解么？<br>没什么深入的了解，就没敢答，怕被问死。</p><p>14）僵尸进程和孤儿进程，了解么？<br>马蛋，这个让我给说反了…(闹心啊啊啊啊啊啊啊)<br>【事后补充】孤儿进程：父进程退出，而它的一个或者多个子进程还在运行，这些子进程就叫孤儿进程，孤儿进程被init进程收养，由init进程对它们完成状态收集工作；<br>僵尸进程：一个进程用fork创建了子进程，然后这个子进程退出了，而父进程并没有调用wait或者waitpid去获取子进程的状态信息，那么这个子进程的进程描述符还在系统中，这种进程叫僵尸进程；</p><p>孤儿进程不怕，由于孤儿虽然没有父母，但是有民政局（init进程）收养，孤儿进程退出后也有init做一切善后工作；而僵尸进程会一直霸占其PID号，但是系统总共的PID是有限的，这样就会让可用的PID越来越少，所以僵尸进程是要避免的。</p>]]></content>
    
    <summary type="html">
    
      呼~~不晓得会不会有下一轮...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="大牛之路" scheme="http://yoursite.com/tags/%E5%A4%A7%E7%89%9B%E4%B9%8B%E8%B7%AF/"/>
    
  </entry>
  
</feed>
